<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>matplotlib.mlab &mdash; Matplotlib 2.2.2 documentation</title>
    
    <link rel="stylesheet" href="../../_static/mpl.css"
type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css"
type="text/css" />
    <link rel="stylesheet" href="../../_static/gallery.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '2.2.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Matplotlib 2.2.2 documentation"
          href="../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html"
/>
    <link rel="search" title="Search" href="../../search.html"
/>
    <link rel="top" title="Matplotlib 2.2.2 documentation" href="../../index.html" />
    <link rel="up" title="matplotlib" href="../matplotlib.html" />
  <link rel="canonical" href="https://matplotlib.org/3.4.3/_modules/matplotlib/mlab.html" />



  </head>
  <body>
<div id="unreleased-message"> You are reading an old version of the documentation (v2.2.2).  For the latest version see <a href="/stable/">https://matplotlib.org/stable/</a> </div>



<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px; position: relative;">
<a href="../../index.html">
    <div style="float: left; position: absolute; width: 496px; bottom: 0; padding-bottom: 24px"><span style="float: right; color: #789; background: white">Version 2.2.2</span></div>
    <img src="../../_static/logo2.png" height="125px" border="0" alt="matplotlib"/></a>

<!-- The "Fork me on github" ribbon -->
<div id="forkongithub"><a href="https://github.com/matplotlib/matplotlib">Fork me on GitHub</a></div>
</div>




    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>

        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../gallery/index.html">examples</a>|&nbsp;</li>
        <li><a href="../../tutorials/index.html">tutorials</a>|&nbsp;</li>
        <li><a href="../../api/pyplot_summary.html">pyplot</a>|&nbsp;</li>
        <li><a href="../../contents.html">docs</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li>
          <li><a href="../matplotlib.html" accesskey="U">matplotlib</a> &raquo;</li> 
      </ul>
    </div>

  
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../contents.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  <li><a href="../matplotlib.html">matplotlib</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
        </div>
      </div>
    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for matplotlib.mlab</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">Numerical python functions written for compatibility with MATLAB</span>
<span class="sd">commands with the same names.</span>

<span class="sd">MATLAB compatible functions</span>
<span class="sd">---------------------------</span>

<span class="sd">:func:`cohere`</span>
<span class="sd">    Coherence (normalized cross spectral density)</span>

<span class="sd">:func:`csd`</span>
<span class="sd">    Cross spectral density using Welch&#39;s average periodogram</span>

<span class="sd">:func:`detrend`</span>
<span class="sd">    Remove the mean or best fit line from an array</span>

<span class="sd">:func:`find`</span>
<span class="sd">    Return the indices where some condition is true;</span>
<span class="sd">    numpy.nonzero is similar but more general.</span>

<span class="sd">:func:`griddata`</span>
<span class="sd">    Interpolate irregularly distributed data to a</span>
<span class="sd">    regular grid.</span>

<span class="sd">:func:`prctile`</span>
<span class="sd">    Find the percentiles of a sequence</span>

<span class="sd">:func:`prepca`</span>
<span class="sd">    Principal Component Analysis</span>

<span class="sd">:func:`psd`</span>
<span class="sd">    Power spectral density using Welch&#39;s average periodogram</span>

<span class="sd">:func:`rk4`</span>
<span class="sd">    A 4th order runge kutta integrator for 1D or ND systems</span>

<span class="sd">:func:`specgram`</span>
<span class="sd">    Spectrogram (spectrum over segments of time)</span>

<span class="sd">Miscellaneous functions</span>
<span class="sd">-----------------------</span>

<span class="sd">Functions that don&#39;t exist in MATLAB, but are useful anyway:</span>

<span class="sd">:func:`cohere_pairs`</span>
<span class="sd">    Coherence over all pairs.  This is not a MATLAB function, but we</span>
<span class="sd">    compute coherence a lot in my lab, and we compute it for a lot of</span>
<span class="sd">    pairs.  This function is optimized to do this efficiently by</span>
<span class="sd">    caching the direct FFTs.</span>

<span class="sd">:func:`rk4`</span>
<span class="sd">    A 4th order Runge-Kutta ODE integrator in case you ever find</span>
<span class="sd">    yourself stranded without scipy (and the far superior</span>
<span class="sd">    scipy.integrate tools)</span>

<span class="sd">:func:`contiguous_regions`</span>
<span class="sd">    Return the indices of the regions spanned by some logical mask</span>

<span class="sd">:func:`cross_from_below`</span>
<span class="sd">    Return the indices where a 1D array crosses a threshold from below</span>

<span class="sd">:func:`cross_from_above`</span>
<span class="sd">    Return the indices where a 1D array crosses a threshold from above</span>

<span class="sd">:func:`complex_spectrum`</span>
<span class="sd">    Return the complex-valued frequency spectrum of a signal</span>

<span class="sd">:func:`magnitude_spectrum`</span>
<span class="sd">    Return the magnitude of the frequency spectrum of a signal</span>

<span class="sd">:func:`angle_spectrum`</span>
<span class="sd">    Return the angle (wrapped phase) of the frequency spectrum of a signal</span>

<span class="sd">:func:`phase_spectrum`</span>
<span class="sd">    Return the phase (unwrapped angle) of the frequency spectrum of a signal</span>

<span class="sd">:func:`detrend_mean`</span>
<span class="sd">    Remove the mean from a line.</span>

<span class="sd">:func:`demean`</span>
<span class="sd">    Remove the mean from a line. This function is the same as</span>
<span class="sd">    :func:`detrend_mean` except for the default *axis*.</span>

<span class="sd">:func:`detrend_linear`</span>
<span class="sd">    Remove the best fit line from a line.</span>

<span class="sd">:func:`detrend_none`</span>
<span class="sd">    Return the original line.</span>

<span class="sd">:func:`stride_windows`</span>
<span class="sd">    Get all windows in an array in a memory-efficient manner</span>

<span class="sd">:func:`stride_repeat`</span>
<span class="sd">    Repeat an array in a memory-efficient manner</span>

<span class="sd">:func:`apply_window`</span>
<span class="sd">    Apply a window along a given axis</span>


<span class="sd">record array helper functions</span>
<span class="sd">-----------------------------</span>

<span class="sd">A collection of helper methods for numpyrecord arrays</span>

<span class="sd">.. _htmlonly:</span>

<span class="sd">    See :ref:`misc-examples-index`</span>

<span class="sd">:func:`rec2txt`</span>
<span class="sd">    Pretty print a record array</span>

<span class="sd">:func:`rec2csv`</span>
<span class="sd">    Store record array in CSV file</span>

<span class="sd">:func:`csv2rec`</span>
<span class="sd">    Import record array from CSV file with type inspection</span>

<span class="sd">:func:`rec_append_fields`</span>
<span class="sd">    Adds  field(s)/array(s) to record array</span>

<span class="sd">:func:`rec_drop_fields`</span>
<span class="sd">    Drop fields from record array</span>

<span class="sd">:func:`rec_join`</span>
<span class="sd">    Join two record arrays on sequence of fields</span>

<span class="sd">:func:`recs_join`</span>
<span class="sd">    A simple join of multiple recarrays using a single column as a key</span>

<span class="sd">:func:`rec_groupby`</span>
<span class="sd">    Summarize data by groups (similar to SQL GROUP BY)</span>

<span class="sd">:func:`rec_summarize`</span>
<span class="sd">    Helper code to filter rec array fields into new fields</span>

<span class="sd">For the rec viewer functions(e rec2csv), there are a bunch of Format</span>
<span class="sd">objects you can pass into the functions that will do things like color</span>
<span class="sd">negative values red, set percent formatting and scaling, etc.</span>

<span class="sd">Example usage::</span>

<span class="sd">    r = csv2rec(&#39;somefile.csv&#39;, checkrows=0)</span>

<span class="sd">    formatd = dict(</span>
<span class="sd">        weight = FormatFloat(2),</span>
<span class="sd">        change = FormatPercent(2),</span>
<span class="sd">        cost   = FormatThousands(2),</span>
<span class="sd">        )</span>


<span class="sd">    rec2excel(r, &#39;test.xls&#39;, formatd=formatd)</span>
<span class="sd">    rec2csv(r, &#39;test.csv&#39;, formatd=formatd)</span>
<span class="sd">    scroll = rec2gtk(r, formatd=formatd)</span>

<span class="sd">    win = gtk.Window()</span>
<span class="sd">    win.set_size_request(600,800)</span>
<span class="sd">    win.add(scroll)</span>
<span class="sd">    win.show_all()</span>
<span class="sd">    gtk.main()</span>


<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span>
                        <span class="n">unicode_literals</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="nb">map</span><span class="p">,</span> <span class="n">xrange</span><span class="p">,</span> <span class="nb">zip</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">matplotlib.cbook</span> <span class="k">as</span> <span class="nn">cbook</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">docstring</span>
<span class="kn">from</span> <span class="nn">matplotlib.path</span> <span class="k">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">math</span>


<span class="k">if</span> <span class="n">six</span><span class="o">.</span><span class="n">PY3</span><span class="p">:</span>
    <span class="n">long</span> <span class="o">=</span> <span class="nb">int</span>


<div class="viewcode-block" id="logspace"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.logspace">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s1">&#39;numpy.logspace or numpy.geomspace&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">logspace</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return N values logarithmically spaced between xmin and xmax.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">xmin</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">xmax</span><span class="p">),</span> <span class="n">N</span><span class="p">))</span></div>


<div class="viewcode-block" id="window_hanning"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.window_hanning">[docs]</a><span class="k">def</span> <span class="nf">window_hanning</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return x times the hanning window of len(x).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`window_none`</span>
<span class="sd">        :func:`window_none` is another window algorithm.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">x</span></div>


<div class="viewcode-block" id="window_none"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.window_none">[docs]</a><span class="k">def</span> <span class="nf">window_none</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    No window function; simply return x.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`window_hanning`</span>
<span class="sd">        :func:`window_hanning` is another window algorithm.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="apply_window"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.apply_window">[docs]</a><span class="k">def</span> <span class="nf">apply_window</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_window</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Apply the given window to the given 1D or 2D array along the given axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1D or 2D array or sequence</span>
<span class="sd">        Array or sequence containing the data.</span>

<span class="sd">    window : function or array.</span>
<span class="sd">        Either a function to generate a window or an array with length</span>
<span class="sd">        *x*.shape[*axis*]</span>

<span class="sd">    axis : integer</span>
<span class="sd">        The axis over which to do the repetition.</span>
<span class="sd">        Must be 0 or 1.  The default is 0</span>

<span class="sd">    return_window : bool</span>
<span class="sd">        If true, also return the 1D values of the window that was applied</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;only 1D or 2D arrays can be used&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;axis(=</span><span class="si">%s</span><span class="s1">) out of bounds&#39;</span> <span class="o">%</span> <span class="n">axis</span><span class="p">)</span>

    <span class="n">xshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">xshapetarg</span> <span class="o">=</span> <span class="n">xshape</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cbook</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">window</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="o">!=</span> <span class="n">xshapetarg</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The len(window) must be the same as the shape &#39;</span>
                             <span class="s1">&#39;of x for the chosen axis&#39;</span><span class="p">)</span>
        <span class="n">windowVals</span> <span class="o">=</span> <span class="n">window</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">windowVals</span> <span class="o">=</span> <span class="n">window</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">xshapetarg</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_window</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">windowVals</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">windowVals</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">windowVals</span> <span class="o">*</span> <span class="n">x</span>

    <span class="n">xshapeother</span> <span class="o">=</span> <span class="n">xshape</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="n">otheraxis</span> <span class="o">=</span> <span class="p">(</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span>

    <span class="n">windowValsRep</span> <span class="o">=</span> <span class="n">stride_repeat</span><span class="p">(</span><span class="n">windowVals</span><span class="p">,</span> <span class="n">xshapeother</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">otheraxis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_window</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">windowValsRep</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">windowVals</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">windowValsRep</span> <span class="o">*</span> <span class="n">x</span></div>


<div class="viewcode-block" id="detrend"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.detrend">[docs]</a><span class="k">def</span> <span class="nf">detrend</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return x with its trend removed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array or sequence</span>
<span class="sd">        Array or sequence containing the data.</span>

<span class="sd">    key : [ &#39;default&#39; | &#39;constant&#39; | &#39;mean&#39; | &#39;linear&#39; | &#39;none&#39;] or function</span>
<span class="sd">        Specifies the detrend algorithm to use. &#39;default&#39; is &#39;mean&#39;, which is</span>
<span class="sd">        the same as :func:`detrend_mean`. &#39;constant&#39; is the same. &#39;linear&#39; is</span>
<span class="sd">        the same as :func:`detrend_linear`. &#39;none&#39; is the same as</span>
<span class="sd">        :func:`detrend_none`. The default is &#39;mean&#39;. See the corresponding</span>
<span class="sd">        functions for more details regarding the algorithms. Can also be a</span>
<span class="sd">        function that carries out the detrend operation.</span>

<span class="sd">    axis : integer</span>
<span class="sd">        The axis along which to do the detrending.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`detrend_mean`</span>
<span class="sd">        :func:`detrend_mean` implements the &#39;mean&#39; algorithm.</span>

<span class="sd">    :func:`detrend_linear`</span>
<span class="sd">        :func:`detrend_linear` implements the &#39;linear&#39; algorithm.</span>

<span class="sd">    :func:`detrend_none`</span>
<span class="sd">        :func:`detrend_none` implements the &#39;none&#39; algorithm.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;default&#39;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">detrend</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">detrend_mean</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">detrend</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">detrend_linear</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">detrend</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">detrend_none</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown value for key </span><span class="si">%s</span><span class="s2">, must be one of: &quot;</span>
                         <span class="s2">&quot;&#39;default&#39;, &#39;constant&#39;, &#39;mean&#39;, &quot;</span>
                         <span class="s2">&quot;&#39;linear&#39;, or a function&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown value for key </span><span class="si">%s</span><span class="s2">, must be one of: &quot;</span>
                         <span class="s2">&quot;&#39;default&#39;, &#39;constant&#39;, &#39;mean&#39;, &quot;</span>
                         <span class="s2">&quot;&#39;linear&#39;, or a function&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">axis</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;axis(=</span><span class="si">%s</span><span class="s1">) out of bounds&#39;</span> <span class="o">%</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">axis</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">key</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># try to use the &#39;axis&#39; argument if the function supports it,</span>
    <span class="c1"># otherwise use apply_along_axis to do it</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">key</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="demean"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.demean">[docs]</a><span class="k">def</span> <span class="nf">demean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return x minus its mean along the specified axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array or sequence</span>
<span class="sd">        Array or sequence containing the data</span>
<span class="sd">        Can have any dimensionality</span>

<span class="sd">    axis : integer</span>
<span class="sd">        The axis along which to take the mean.  See numpy.mean for a</span>
<span class="sd">        description of this argument.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`delinear`</span>

<span class="sd">    :func:`denone`</span>
<span class="sd">        :func:`delinear` and :func:`denone` are other detrend algorithms.</span>

<span class="sd">    :func:`detrend_mean`</span>
<span class="sd">        This function is the same as :func:`detrend_mean` except for the</span>
<span class="sd">        default *axis*.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">detrend_mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>


<div class="viewcode-block" id="detrend_mean"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.detrend_mean">[docs]</a><span class="k">def</span> <span class="nf">detrend_mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return x minus the mean(x).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array or sequence</span>
<span class="sd">        Array or sequence containing the data</span>
<span class="sd">        Can have any dimensionality</span>

<span class="sd">    axis : integer</span>
<span class="sd">        The axis along which to take the mean.  See numpy.mean for a</span>
<span class="sd">        description of this argument.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`demean`</span>
<span class="sd">        This function is the same as :func:`demean` except for the default</span>
<span class="sd">        *axis*.</span>

<span class="sd">    :func:`detrend_linear`</span>

<span class="sd">    :func:`detrend_none`</span>
<span class="sd">        :func:`detrend_linear` and :func:`detrend_none` are other detrend</span>
<span class="sd">        algorithms.</span>

<span class="sd">    :func:`detrend`</span>
<span class="sd">        :func:`detrend` is a wrapper around all the detrend algorithms.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">axis</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;axis(=</span><span class="si">%s</span><span class="s1">) out of bounds&#39;</span> <span class="o">%</span> <span class="n">axis</span><span class="p">)</span>

    <span class="c1"># short-circuit 0-D array.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># short-circuit simple operations</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

    <span class="n">ind</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">ind</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="p">)[</span><span class="n">ind</span><span class="p">]</span></div>


<div class="viewcode-block" id="detrend_none"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.detrend_none">[docs]</a><span class="k">def</span> <span class="nf">detrend_none</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return x: no detrending.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : any object</span>
<span class="sd">        An object containing the data</span>

<span class="sd">    axis : integer</span>
<span class="sd">        This parameter is ignored.</span>
<span class="sd">        It is included for compatibility with detrend_mean</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`denone`</span>
<span class="sd">        This function is the same as :func:`denone` except for the default</span>
<span class="sd">        *axis*, which has no effect.</span>

<span class="sd">    :func:`detrend_mean`</span>

<span class="sd">    :func:`detrend_linear`</span>
<span class="sd">        :func:`detrend_mean` and :func:`detrend_linear` are other detrend</span>
<span class="sd">        algorithms.</span>

<span class="sd">    :func:`detrend`</span>
<span class="sd">        :func:`detrend` is a wrapper around all the detrend algorithms.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="detrend_linear"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.detrend_linear">[docs]</a><span class="k">def</span> <span class="nf">detrend_linear</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return x minus best fit line; &#39;linear&#39; detrending.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : 0-D or 1-D array or sequence</span>
<span class="sd">        Array or sequence containing the data</span>

<span class="sd">    axis : integer</span>
<span class="sd">        The axis along which to take the mean.  See numpy.mean for a</span>
<span class="sd">        description of this argument.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`delinear`</span>
<span class="sd">        This function is the same as :func:`delinear` except for the default</span>
<span class="sd">        *axis*.</span>

<span class="sd">    :func:`detrend_mean`</span>

<span class="sd">    :func:`detrend_none`</span>
<span class="sd">        :func:`detrend_mean` and :func:`detrend_none` are other detrend</span>
<span class="sd">        algorithms.</span>

<span class="sd">    :func:`detrend`</span>
<span class="sd">        :func:`detrend` is a wrapper around all the detrend algorithms.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># This is faster than an algorithm based on linalg.lstsq.</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;y cannot have ndim &gt; 1&#39;</span><span class="p">)</span>

    <span class="c1"># short-circuit 0-D array.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">-</span> <span class="n">b</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span></div>


<div class="viewcode-block" id="stride_windows"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.stride_windows">[docs]</a><span class="k">def</span> <span class="nf">stride_windows</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Get all windows of x with length n as a single array,</span>
<span class="sd">    using strides to avoid data duplication.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        It is not safe to write to the output array.  Multiple</span>
<span class="sd">        elements may point to the same piece of memory,</span>
<span class="sd">        so modifying one value may change others.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1D array or sequence</span>
<span class="sd">        Array or sequence containing the data.</span>

<span class="sd">    n : integer</span>
<span class="sd">        The number of data points in each window.</span>

<span class="sd">    noverlap : integer</span>
<span class="sd">        The overlap between adjacent windows.</span>
<span class="sd">        Default is 0 (no overlap)</span>

<span class="sd">    axis : integer</span>
<span class="sd">        The axis along which the windows will run.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    `stackoverflow: Rolling window for 1D arrays in Numpy?</span>
<span class="sd">    &lt;http://stackoverflow.com/a/6811241&gt;`_</span>
<span class="sd">    `stackoverflow: Using strides for an efficient moving average filter</span>
<span class="sd">    &lt;http://stackoverflow.com/a/4947453&gt;`_</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">noverlap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">noverlap</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">noverlap</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;noverlap must be less than n&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;n cannot be less than 1&#39;</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;only 1-dimensional arrays can be used&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">noverlap</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;n cannot be greater than the length of x&#39;</span><span class="p">)</span>

    <span class="c1"># np.lib.stride_tricks.as_strided easily leads to memory corruption for</span>
    <span class="c1"># non integer shape and strides, i.e. noverlap or n. See #3845.</span>
    <span class="n">noverlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">noverlap</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="n">step</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">noverlap</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">noverlap</span><span class="p">)</span><span class="o">//</span><span class="n">step</span><span class="p">)</span>
        <span class="n">strides</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">step</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">noverlap</span><span class="p">)</span><span class="o">//</span><span class="n">step</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">strides</span> <span class="o">=</span> <span class="p">(</span><span class="n">step</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">as_strided</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">)</span></div>


<div class="viewcode-block" id="stride_repeat"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.stride_repeat">[docs]</a><span class="k">def</span> <span class="nf">stride_repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Repeat the values in an array in a memory-efficient manner.  Array x is</span>
<span class="sd">    stacked vertically n times.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        It is not safe to write to the output array.  Multiple</span>
<span class="sd">        elements may point to the same piece of memory, so</span>
<span class="sd">        modifying one value may change others.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1D array or sequence</span>
<span class="sd">        Array or sequence containing the data.</span>

<span class="sd">    n : integer</span>
<span class="sd">        The number of time to repeat the array.</span>

<span class="sd">    axis : integer</span>
<span class="sd">        The axis along which the data will run.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    `stackoverflow: Repeat NumPy array without replicating data?</span>
<span class="sd">    &lt;http://stackoverflow.com/a/5568169&gt;`_</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;axis must be 0 or 1&#39;</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;only 1-dimensional arrays can be used&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;n cannot be less than 1&#39;</span><span class="p">)</span>

    <span class="c1"># np.lib.stride_tricks.as_strided easily leads to memory corruption for</span>
    <span class="c1"># non integer shape and strides, i.e. n. See #3845.</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">strides</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">strides</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">as_strided</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_spectral_helper</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">detrend_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This is a helper function that implements the commonality between the</span>
<span class="sd">    psd, csd, spectrogram and complex, magnitude, angle, and phase spectrums.</span>
<span class="sd">    It is *NOT* meant to be used outside of mlab and may change at any time.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># if y is None use x for y</span>
        <span class="n">same_data</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># The checks for if y is x are so that we can use the same function to</span>
        <span class="c1"># implement the core of psd(), csd(), and spectrogram() without doing</span>
        <span class="c1"># extra calculations.  We return the unaveraged Pxy, freqs, and t.</span>
        <span class="n">same_data</span> <span class="o">=</span> <span class="n">y</span> <span class="ow">is</span> <span class="n">x</span>

    <span class="k">if</span> <span class="n">Fs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Fs</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">noverlap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">noverlap</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">detrend_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">detrend_func</span> <span class="o">=</span> <span class="n">detrend_none</span>
    <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">window_hanning</span>

    <span class="c1"># if NFFT is set to None use the whole signal</span>
    <span class="k">if</span> <span class="n">NFFT</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">NFFT</span> <span class="o">=</span> <span class="mi">256</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;psd&#39;</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;psd&#39;</span><span class="p">,</span> <span class="s1">&#39;complex&#39;</span><span class="p">,</span> <span class="s1">&#39;magnitude&#39;</span><span class="p">,</span> <span class="s1">&#39;angle&#39;</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown value for mode </span><span class="si">%s</span><span class="s2">, must be one of: &quot;</span>
                         <span class="s2">&quot;&#39;default&#39;, &#39;psd&#39;, &#39;complex&#39;, &quot;</span>
                         <span class="s2">&quot;&#39;magnitude&#39;, &#39;angle&#39;, &#39;phase&#39;&quot;</span> <span class="o">%</span> <span class="n">mode</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">same_data</span> <span class="ow">and</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;psd&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x and y must be equal if mode is not &#39;psd&#39;&quot;</span><span class="p">)</span>

    <span class="c1"># Make sure we&#39;re dealing with a numpy array. If y and x were the same</span>
    <span class="c1"># object to start with, keep them that way</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">same_data</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sides</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">sides</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">sides</span> <span class="o">=</span> <span class="s1">&#39;twosided&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sides</span> <span class="o">=</span> <span class="s1">&#39;onesided&#39;</span>
    <span class="k">elif</span> <span class="n">sides</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;onesided&#39;</span><span class="p">,</span> <span class="s1">&#39;twosided&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown value for sides </span><span class="si">%s</span><span class="s2">, must be one of: &quot;</span>
                         <span class="s2">&quot;&#39;default&#39;, &#39;onesided&#39;, or &#39;twosided&#39;&quot;</span> <span class="o">%</span> <span class="n">sides</span><span class="p">)</span>

    <span class="c1"># zero pad x and y up to NFFT if they are shorter than NFFT</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">NFFT</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">NFFT</span><span class="p">,))</span>
        <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">same_data</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">NFFT</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="n">NFFT</span><span class="p">,))</span>
        <span class="n">y</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">pad_to</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pad_to</span> <span class="o">=</span> <span class="n">NFFT</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;psd&#39;</span><span class="p">:</span>
        <span class="n">scale_by_freq</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="n">scale_by_freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scale_by_freq</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># For real x, ignore the negative frequencies unless told otherwise</span>
    <span class="k">if</span> <span class="n">sides</span> <span class="o">==</span> <span class="s1">&#39;twosided&#39;</span><span class="p">:</span>
        <span class="n">numFreqs</span> <span class="o">=</span> <span class="n">pad_to</span>
        <span class="k">if</span> <span class="n">pad_to</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">freqcenter</span> <span class="o">=</span> <span class="p">(</span><span class="n">pad_to</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">freqcenter</span> <span class="o">=</span> <span class="n">pad_to</span><span class="o">//</span><span class="mi">2</span>
        <span class="n">scaling_factor</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="k">elif</span> <span class="n">sides</span> <span class="o">==</span> <span class="s1">&#39;onesided&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">pad_to</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">numFreqs</span> <span class="o">=</span> <span class="p">(</span><span class="n">pad_to</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numFreqs</span> <span class="o">=</span> <span class="n">pad_to</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">scaling_factor</span> <span class="o">=</span> <span class="mf">2.</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">stride_windows</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="p">,</span> <span class="n">noverlap</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">detrend</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">detrend_func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">result</span><span class="p">,</span> <span class="n">windowVals</span> <span class="o">=</span> <span class="n">apply_window</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                      <span class="n">return_window</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:</span><span class="n">numFreqs</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">pad_to</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">Fs</span><span class="p">)[:</span><span class="n">numFreqs</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">same_data</span><span class="p">:</span>
        <span class="c1"># if same_data is False, mode must be &#39;psd&#39;</span>
        <span class="n">resultY</span> <span class="o">=</span> <span class="n">stride_windows</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="p">,</span> <span class="n">noverlap</span><span class="p">)</span>
        <span class="n">resultY</span> <span class="o">=</span> <span class="n">detrend</span><span class="p">(</span><span class="n">resultY</span><span class="p">,</span> <span class="n">detrend_func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">resultY</span> <span class="o">=</span> <span class="n">apply_window</span><span class="p">(</span><span class="n">resultY</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">resultY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">resultY</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:</span><span class="n">numFreqs</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">*</span> <span class="n">resultY</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;psd&#39;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">*</span> <span class="n">result</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;magnitude&#39;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">windowVals</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;angle&#39;</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;phase&#39;</span><span class="p">:</span>
        <span class="c1"># we unwrap the phase later to handle the onesided vs. twosided case</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;complex&#39;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">windowVals</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;psd&#39;</span><span class="p">:</span>

        <span class="c1"># Also include scaling factors for one-sided densities and dividing by</span>
        <span class="c1"># the sampling frequency, if desired. Scale everything, except the DC</span>
        <span class="c1"># component and the NFFT/2 component:</span>

        <span class="c1"># if we have a even number of frequencies, don&#39;t scale NFFT/2</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">NFFT</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">slc</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># if we have an odd number, just don&#39;t scale DC</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slc</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">result</span><span class="p">[</span><span class="n">slc</span><span class="p">]</span> <span class="o">*=</span> <span class="n">scaling_factor</span>

        <span class="c1"># MATLAB divides by the sampling frequency so that density function</span>
        <span class="c1"># has units of dB/Hz and can be integrated by the plotted frequency</span>
        <span class="c1"># values. Perform the same scaling here.</span>
        <span class="k">if</span> <span class="n">scale_by_freq</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">/=</span> <span class="n">Fs</span>
            <span class="c1"># Scale the spectrum by the norm of the window to compensate for</span>
            <span class="c1"># windowing loss; see Bendat &amp; Piersol Sec 11.5.2.</span>
            <span class="n">result</span> <span class="o">/=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">windowVals</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># In this case, preserve power in the segment, not amplitude</span>
            <span class="n">result</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">windowVals</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">**</span><span class="mi">2</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">NFFT</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">NFFT</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">NFFT</span> <span class="o">-</span> <span class="n">noverlap</span><span class="p">)</span><span class="o">/</span><span class="n">Fs</span>

    <span class="k">if</span> <span class="n">sides</span> <span class="o">==</span> <span class="s1">&#39;twosided&#39;</span><span class="p">:</span>
        <span class="c1"># center the frequency range at zero</span>
        <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">freqs</span><span class="p">[</span><span class="n">freqcenter</span><span class="p">:],</span> <span class="n">freqs</span><span class="p">[:</span><span class="n">freqcenter</span><span class="p">]))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">result</span><span class="p">[</span><span class="n">freqcenter</span><span class="p">:,</span> <span class="p">:],</span>
                                 <span class="n">result</span><span class="p">[:</span><span class="n">freqcenter</span><span class="p">,</span> <span class="p">:]),</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">pad_to</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># get the last value correctly, it is negative otherwise</span>
        <span class="n">freqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># we unwrap the phase here to handle the onesided vs. twosided case</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;phase&#39;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">t</span>


<span class="k">def</span> <span class="nf">_single_spectrum_helper</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This is a helper function that implements the commonality between the</span>
<span class="sd">    complex, magnitude, angle, and phase spectrums.</span>
<span class="sd">    It is *NOT* meant to be used outside of mlab and may change at any time.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;psd&#39;</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;_single_spectrum_helper does not work with </span><span class="si">%s</span><span class="s1"> mode&#39;</span>
                         <span class="o">%</span> <span class="n">mode</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">pad_to</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pad_to</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_spectral_helper</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span>
                                      <span class="n">detrend_func</span><span class="o">=</span><span class="n">detrend_none</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                      <span class="n">noverlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                                      <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span>
                                      <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;complex&#39;</span><span class="p">:</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">real</span>

    <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">spec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span>


<span class="c1"># Split out these keyword docs so that they can be used elsewhere</span>
<span class="n">docstring</span><span class="o">.</span><span class="n">interpd</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">Spectral</span><span class="o">=</span><span class="n">cbook</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Fs : scalar</span>
<span class="s2">        The sampling frequency (samples per time unit).  It is used</span>
<span class="s2">        to calculate the Fourier frequencies, freqs, in cycles per time</span>
<span class="s2">        unit. The default value is 2.</span>

<span class="s2">    window : callable or ndarray</span>
<span class="s2">        A function or a vector of length *NFFT*. To create window</span>
<span class="s2">        vectors see :func:`window_hanning`, :func:`window_none`,</span>
<span class="s2">        :func:`numpy.blackman`, :func:`numpy.hamming`,</span>
<span class="s2">        :func:`numpy.bartlett`, :func:`scipy.signal`,</span>
<span class="s2">        :func:`scipy.signal.get_window`, etc. The default is</span>
<span class="s2">        :func:`window_hanning`.  If a function is passed as the</span>
<span class="s2">        argument, it must take a data segment as an argument and</span>
<span class="s2">        return the windowed version of the segment.</span>

<span class="s2">    sides : [ &#39;default&#39; | &#39;onesided&#39; | &#39;twosided&#39; ]</span>
<span class="s2">        Specifies which sides of the spectrum to return.  Default gives the</span>
<span class="s2">        default behavior, which returns one-sided for real data and both</span>
<span class="s2">        for complex data.  &#39;onesided&#39; forces the return of a one-sided</span>
<span class="s2">        spectrum, while &#39;twosided&#39; forces two-sided.</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">))</span>


<span class="n">docstring</span><span class="o">.</span><span class="n">interpd</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">Single_Spectrum</span><span class="o">=</span><span class="n">cbook</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    pad_to : integer</span>
<span class="s2">        The number of points to which the data segment is padded when</span>
<span class="s2">        performing the FFT.  While not increasing the actual resolution of</span>
<span class="s2">        the spectrum (the minimum distance between resolvable peaks),</span>
<span class="s2">        this can give more points in the plot, allowing for more</span>
<span class="s2">        detail. This corresponds to the *n* parameter in the call to fft().</span>
<span class="s2">        The default is None, which sets *pad_to* equal to the length of the</span>
<span class="s2">        input signal (i.e. no padding).</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">))</span>


<span class="n">docstring</span><span class="o">.</span><span class="n">interpd</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">PSD</span><span class="o">=</span><span class="n">cbook</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    pad_to : integer</span>
<span class="s2">        The number of points to which the data segment is padded when</span>
<span class="s2">        performing the FFT.  This can be different from *NFFT*, which</span>
<span class="s2">        specifies the number of data points used.  While not increasing</span>
<span class="s2">        the actual resolution of the spectrum (the minimum distance between</span>
<span class="s2">        resolvable peaks), this can give more points in the plot,</span>
<span class="s2">        allowing for more detail. This corresponds to the *n* parameter</span>
<span class="s2">        in the call to fft(). The default is None, which sets *pad_to*</span>
<span class="s2">        equal to *NFFT*</span>

<span class="s2">    NFFT : integer</span>
<span class="s2">        The number of data points used in each block for the FFT.</span>
<span class="s2">        A power 2 is most efficient.  The default value is 256.</span>
<span class="s2">        This should *NOT* be used to get zero padding, or the scaling of the</span>
<span class="s2">        result will be incorrect. Use *pad_to* for this instead.</span>

<span class="s2">    detrend : {&#39;default&#39;, &#39;constant&#39;, &#39;mean&#39;, &#39;linear&#39;, &#39;none&#39;} or callable</span>
<span class="s2">        The function applied to each segment before fft-ing,</span>
<span class="s2">        designed to remove the mean or linear trend.  Unlike in</span>
<span class="s2">        MATLAB, where the *detrend* parameter is a vector, in</span>
<span class="s2">        matplotlib is it a function.  The :mod:`~matplotlib.pylab`</span>
<span class="s2">        module defines :func:`~matplotlib.pylab.detrend_none`,</span>
<span class="s2">        :func:`~matplotlib.pylab.detrend_mean`, and</span>
<span class="s2">        :func:`~matplotlib.pylab.detrend_linear`, but you can use</span>
<span class="s2">        a custom function as well.  You can also use a string to choose</span>
<span class="s2">        one of the functions.  &#39;default&#39;, &#39;constant&#39;, and &#39;mean&#39; call</span>
<span class="s2">        :func:`~matplotlib.pylab.detrend_mean`.  &#39;linear&#39; calls</span>
<span class="s2">        :func:`~matplotlib.pylab.detrend_linear`.  &#39;none&#39; calls</span>
<span class="s2">        :func:`~matplotlib.pylab.detrend_none`.</span>

<span class="s2">    scale_by_freq : boolean, optional</span>
<span class="s2">        Specifies whether the resulting density values should be scaled</span>
<span class="s2">        by the scaling frequency, which gives density in units of Hz^-1.</span>
<span class="s2">        This allows for integration over the returned frequency values.</span>
<span class="s2">        The default is True for MATLAB compatibility.</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">))</span>


<div class="viewcode-block" id="psd"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.psd">[docs]</a><span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
<span class="k">def</span> <span class="nf">psd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the power spectral density.</span>

<span class="sd">    Call signature::</span>

<span class="sd">        psd(x, NFFT=256, Fs=2, detrend=mlab.detrend_none,</span>
<span class="sd">            window=mlab.window_hanning, noverlap=0, pad_to=None,</span>
<span class="sd">            sides=&#39;default&#39;, scale_by_freq=None)</span>

<span class="sd">    The power spectral density :math:`P_{xx}` by Welch&#39;s average</span>
<span class="sd">    periodogram method.  The vector *x* is divided into *NFFT* length</span>
<span class="sd">    segments.  Each segment is detrended by function *detrend* and</span>
<span class="sd">    windowed by function *window*.  *noverlap* gives the length of</span>
<span class="sd">    the overlap between segments.  The :math:`|\mathrm{fft}(i)|^2`</span>
<span class="sd">    of each segment :math:`i` are averaged to compute :math:`P_{xx}`.</span>

<span class="sd">    If len(*x*) &lt; *NFFT*, it will be zero padded to *NFFT*.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1-D array or sequence</span>
<span class="sd">        Array or sequence containing the data</span>

<span class="sd">    %(Spectral)s</span>

<span class="sd">    %(PSD)s</span>

<span class="sd">    noverlap : integer</span>
<span class="sd">        The number of points of overlap between segments.</span>
<span class="sd">        The default value is 0 (no overlap).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Pxx : 1-D array</span>
<span class="sd">        The values for the power spectrum `P_{xx}` (real valued)</span>

<span class="sd">    freqs : 1-D array</span>
<span class="sd">        The frequencies corresponding to the elements in *Pxx*</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Bendat &amp; Piersol -- Random Data: Analysis and Measurement Procedures, John</span>
<span class="sd">    Wiley &amp; Sons (1986)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`specgram`</span>
<span class="sd">        :func:`specgram` differs in the default overlap; in not returning the</span>
<span class="sd">        mean of the segment periodograms; and in returning the times of the</span>
<span class="sd">        segments.</span>

<span class="sd">    :func:`magnitude_spectrum`</span>
<span class="sd">        :func:`magnitude_spectrum` returns the magnitude spectrum.</span>

<span class="sd">    :func:`csd`</span>
<span class="sd">        :func:`csd` returns the spectral density between two signals.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Pxx</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">csd</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span>
                     <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                     <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="n">scale_by_freq</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Pxx</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">freqs</span></div>


<div class="viewcode-block" id="csd"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.csd">[docs]</a><span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
<span class="k">def</span> <span class="nf">csd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the cross-spectral density.</span>

<span class="sd">    Call signature::</span>

<span class="sd">        csd(x, y, NFFT=256, Fs=2, detrend=mlab.detrend_none,</span>
<span class="sd">            window=mlab.window_hanning, noverlap=0, pad_to=None,</span>
<span class="sd">            sides=&#39;default&#39;, scale_by_freq=None)</span>

<span class="sd">    The cross spectral density :math:`P_{xy}` by Welch&#39;s average</span>
<span class="sd">    periodogram method.  The vectors *x* and *y* are divided into</span>
<span class="sd">    *NFFT* length segments.  Each segment is detrended by function</span>
<span class="sd">    *detrend* and windowed by function *window*.  *noverlap* gives</span>
<span class="sd">    the length of the overlap between segments.  The product of</span>
<span class="sd">    the direct FFTs of *x* and *y* are averaged over each segment</span>
<span class="sd">    to compute :math:`P_{xy}`, with a scaling to correct for power</span>
<span class="sd">    loss due to windowing.</span>

<span class="sd">    If len(*x*) &lt; *NFFT* or len(*y*) &lt; *NFFT*, they will be zero</span>
<span class="sd">    padded to *NFFT*.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y : 1-D arrays or sequences</span>
<span class="sd">        Arrays or sequences containing the data</span>

<span class="sd">    %(Spectral)s</span>

<span class="sd">    %(PSD)s</span>

<span class="sd">    noverlap : integer</span>
<span class="sd">        The number of points of overlap between segments.</span>
<span class="sd">        The default value is 0 (no overlap).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Pxy : 1-D array</span>
<span class="sd">        The values for the cross spectrum `P_{xy}` before scaling (real valued)</span>

<span class="sd">    freqs : 1-D array</span>
<span class="sd">        The frequencies corresponding to the elements in *Pxy*</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Bendat &amp; Piersol -- Random Data: Analysis and Measurement Procedures, John</span>
<span class="sd">    Wiley &amp; Sons (1986)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`psd`</span>
<span class="sd">        :func:`psd` is the equivalent to setting y=x.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">NFFT</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">NFFT</span> <span class="o">=</span> <span class="mi">256</span>
    <span class="n">Pxy</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_spectral_helper</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span>
                                     <span class="n">detrend_func</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                     <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                                     <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="n">scale_by_freq</span><span class="p">,</span>
                                     <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;psd&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">Pxy</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">Pxy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">Pxy</span> <span class="o">=</span> <span class="n">Pxy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Pxy</span> <span class="o">=</span> <span class="n">Pxy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">Pxy</span><span class="p">,</span> <span class="n">freqs</span></div>


<div class="viewcode-block" id="complex_spectrum"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.complex_spectrum">[docs]</a><span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
<span class="k">def</span> <span class="nf">complex_spectrum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the complex-valued frequency spectrum of *x*.  Data is padded to a</span>
<span class="sd">    length of *pad_to* and the windowing function *window* is applied to the</span>
<span class="sd">    signal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1-D array or sequence</span>
<span class="sd">        Array or sequence containing the data</span>

<span class="sd">    %(Spectral)s</span>

<span class="sd">    %(Single_Spectrum)s</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    spectrum : 1-D array</span>
<span class="sd">        The values for the complex spectrum (complex valued)</span>

<span class="sd">    freqs : 1-D array</span>
<span class="sd">        The frequencies corresponding to the elements in *spectrum*</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`magnitude_spectrum`</span>
<span class="sd">        :func:`magnitude_spectrum` returns the absolute value of this function.</span>

<span class="sd">    :func:`angle_spectrum`</span>
<span class="sd">        :func:`angle_spectrum` returns the angle of this function.</span>

<span class="sd">    :func:`phase_spectrum`</span>
<span class="sd">        :func:`phase_spectrum` returns the phase (unwrapped angle) of this</span>
<span class="sd">        function.</span>

<span class="sd">    :func:`specgram`</span>
<span class="sd">        :func:`specgram` can return the complex spectrum of segments within the</span>
<span class="sd">        signal.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_single_spectrum_helper</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                                   <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;complex&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="magnitude_spectrum"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.magnitude_spectrum">[docs]</a><span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
<span class="k">def</span> <span class="nf">magnitude_spectrum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the magnitude (absolute value) of the frequency spectrum of</span>
<span class="sd">    *x*.  Data is padded to a length of *pad_to* and the windowing function</span>
<span class="sd">    *window* is applied to the signal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1-D array or sequence</span>
<span class="sd">        Array or sequence containing the data</span>

<span class="sd">    %(Spectral)s</span>

<span class="sd">    %(Single_Spectrum)s</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    spectrum : 1-D array</span>
<span class="sd">        The values for the magnitude spectrum (real valued)</span>

<span class="sd">    freqs : 1-D array</span>
<span class="sd">        The frequencies corresponding to the elements in *spectrum*</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`psd`</span>
<span class="sd">        :func:`psd` returns the power spectral density.</span>

<span class="sd">    :func:`complex_spectrum`</span>
<span class="sd">        This function returns the absolute value of :func:`complex_spectrum`.</span>

<span class="sd">    :func:`angle_spectrum`</span>
<span class="sd">        :func:`angle_spectrum` returns the angles of the corresponding</span>
<span class="sd">        frequencies.</span>

<span class="sd">    :func:`phase_spectrum`</span>
<span class="sd">        :func:`phase_spectrum` returns the phase (unwrapped angle) of the</span>
<span class="sd">        corresponding frequencies.</span>

<span class="sd">    :func:`specgram`</span>
<span class="sd">        :func:`specgram` can return the magnitude spectrum of segments within</span>
<span class="sd">        the signal.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_single_spectrum_helper</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                                   <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;magnitude&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="angle_spectrum"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.angle_spectrum">[docs]</a><span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
<span class="k">def</span> <span class="nf">angle_spectrum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the angle of the frequency spectrum (wrapped phase spectrum) of</span>
<span class="sd">    *x*.  Data is padded to a length of *pad_to* and the windowing function</span>
<span class="sd">    *window* is applied to the signal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1-D array or sequence</span>
<span class="sd">        Array or sequence containing the data</span>

<span class="sd">    %(Spectral)s</span>

<span class="sd">    %(Single_Spectrum)s</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    spectrum : 1-D array</span>
<span class="sd">        The values for the angle spectrum in radians (real valued)</span>

<span class="sd">    freqs : 1-D array</span>
<span class="sd">        The frequencies corresponding to the elements in *spectrum*</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`complex_spectrum`</span>
<span class="sd">        This function returns the angle value of :func:`complex_spectrum`.</span>

<span class="sd">    :func:`magnitude_spectrum`</span>
<span class="sd">        :func:`angle_spectrum` returns the magnitudes of the corresponding</span>
<span class="sd">        frequencies.</span>

<span class="sd">    :func:`phase_spectrum`</span>
<span class="sd">        :func:`phase_spectrum` returns the unwrapped version of this function.</span>

<span class="sd">    :func:`specgram`</span>
<span class="sd">        :func:`specgram` can return the angle spectrum of segments within the</span>
<span class="sd">        signal.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_single_spectrum_helper</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                                   <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;angle&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="phase_spectrum"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.phase_spectrum">[docs]</a><span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
<span class="k">def</span> <span class="nf">phase_spectrum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the phase of the frequency spectrum (unwrapped angle spectrum) of</span>
<span class="sd">    *x*.  Data is padded to a length of *pad_to* and the windowing function</span>
<span class="sd">    *window* is applied to the signal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1-D array or sequence</span>
<span class="sd">        Array or sequence containing the data</span>

<span class="sd">    %(Spectral)s</span>

<span class="sd">    %(Single_Spectrum)s</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    spectrum : 1-D array</span>
<span class="sd">        The values for the phase spectrum in radians (real valued)</span>

<span class="sd">    freqs : 1-D array</span>
<span class="sd">        The frequencies corresponding to the elements in *spectrum*</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`complex_spectrum`</span>
<span class="sd">        This function returns the angle value of :func:`complex_spectrum`.</span>

<span class="sd">    :func:`magnitude_spectrum`</span>
<span class="sd">        :func:`magnitude_spectrum` returns the magnitudes of the corresponding</span>
<span class="sd">        frequencies.</span>

<span class="sd">    :func:`angle_spectrum`</span>
<span class="sd">        :func:`angle_spectrum` returns the wrapped version of this function.</span>

<span class="sd">    :func:`specgram`</span>
<span class="sd">        :func:`specgram` can return the phase spectrum of segments within the</span>
<span class="sd">        signal.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_single_spectrum_helper</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                                   <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;phase&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="specgram"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.specgram">[docs]</a><span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
<span class="k">def</span> <span class="nf">specgram</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute a spectrogram.</span>

<span class="sd">    Compute and plot a spectrogram of data in x.  Data are split into</span>
<span class="sd">    NFFT length segments and the spectrum of each section is</span>
<span class="sd">    computed.  The windowing function window is applied to each</span>
<span class="sd">    segment, and the amount of overlap of each segment is</span>
<span class="sd">    specified with noverlap.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        1-D array or sequence.</span>

<span class="sd">    %(Spectral)s</span>

<span class="sd">    %(PSD)s</span>

<span class="sd">    noverlap : int, optional</span>
<span class="sd">        The number of points of overlap between blocks.  The default</span>
<span class="sd">        value is 128.</span>
<span class="sd">    mode : str, optional</span>
<span class="sd">        What sort of spectrum to use, default is &#39;psd&#39;.</span>
<span class="sd">            &#39;psd&#39;</span>
<span class="sd">                Returns the power spectral density.</span>

<span class="sd">            &#39;complex&#39;</span>
<span class="sd">                Returns the complex-valued frequency spectrum.</span>

<span class="sd">            &#39;magnitude&#39;</span>
<span class="sd">                Returns the magnitude spectrum.</span>

<span class="sd">            &#39;angle&#39;</span>
<span class="sd">                Returns the phase spectrum without unwrapping.</span>

<span class="sd">            &#39;phase&#39;</span>
<span class="sd">                Returns the phase spectrum with unwrapping.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    spectrum : array_like</span>
<span class="sd">        2-D array, columns are the periodograms of successive segments.</span>

<span class="sd">    freqs : array_like</span>
<span class="sd">        1-D array, frequencies corresponding to the rows in *spectrum*.</span>

<span class="sd">    t : array_like</span>
<span class="sd">        1-D array, the times corresponding to midpoints of segments</span>
<span class="sd">        (i.e the columns in *spectrum*).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    psd : differs in the overlap and in the return values.</span>
<span class="sd">    complex_spectrum : similar, but with complex valued frequencies.</span>
<span class="sd">    magnitude_spectrum : similar single segment when mode is &#39;magnitude&#39;.</span>
<span class="sd">    angle_spectrum : similar to single segment when mode is &#39;angle&#39;.</span>
<span class="sd">    phase_spectrum : similar to single segment when mode is &#39;phase&#39;.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    detrend and scale_by_freq only apply when *mode* is set to &#39;psd&#39;.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">noverlap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">noverlap</span> <span class="o">=</span> <span class="mi">128</span>  <span class="c1"># default in _spectral_helper() is noverlap = 0</span>
    <span class="k">if</span> <span class="n">NFFT</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">NFFT</span> <span class="o">=</span> <span class="mi">256</span>  <span class="c1"># same default as in _spectral_helper()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">NFFT</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Only one segment is calculated since parameter NFFT &quot;</span> <span class="o">+</span>
                      <span class="s2">&quot;(=</span><span class="si">%d</span><span class="s2">) &gt;= signal length (=</span><span class="si">%d</span><span class="s2">).&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">NFFT</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>

    <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">_spectral_helper</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span>
                                      <span class="n">detrend_func</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                      <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                                      <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span>
                                      <span class="n">scale_by_freq</span><span class="o">=</span><span class="n">scale_by_freq</span><span class="p">,</span>
                                      <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;complex&#39;</span><span class="p">:</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">real</span>  <span class="c1"># Needed since helper implements generically</span>

    <span class="k">return</span> <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">t</span></div>


<span class="n">_coh_error</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Coherence is calculated by averaging over *NFFT*</span>
<span class="s2">length segments.  Your signal is too short for your choice of *NFFT*.</span>
<span class="s2">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="cohere"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.cohere">[docs]</a><span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
<span class="k">def</span> <span class="nf">cohere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend_none</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window_hanning</span><span class="p">,</span>
           <span class="n">noverlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The coherence between *x* and *y*.  Coherence is the normalized</span>
<span class="sd">    cross spectral density:</span>

<span class="sd">    .. math::</span>

<span class="sd">        C_{xy} = \\frac{|P_{xy}|^2}{P_{xx}P_{yy}}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y</span>
<span class="sd">        Array or sequence containing the data</span>

<span class="sd">    %(Spectral)s</span>

<span class="sd">    %(PSD)s</span>

<span class="sd">    noverlap : integer</span>
<span class="sd">        The number of points of overlap between blocks.  The default value</span>
<span class="sd">        is 0 (no overlap).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    The return value is the tuple (*Cxy*, *f*), where *f* are the</span>
<span class="sd">    frequencies of the coherence vector. For cohere, scaling the</span>
<span class="sd">    individual densities by the sampling frequency has no effect,</span>
<span class="sd">    since the factors cancel out.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`psd`, :func:`csd` :</span>
<span class="sd">        For information about the methods used to compute :math:`P_{xy}`,</span>
<span class="sd">        :math:`P_{xx}` and :math:`P_{yy}`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">NFFT</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_coh_error</span><span class="p">)</span>
    <span class="n">Pxx</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">psd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="p">,</span> <span class="n">detrend</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="p">,</span> <span class="n">sides</span><span class="p">,</span>
                 <span class="n">scale_by_freq</span><span class="p">)</span>
    <span class="n">Pyy</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">psd</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="p">,</span> <span class="n">detrend</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="p">,</span> <span class="n">sides</span><span class="p">,</span>
                 <span class="n">scale_by_freq</span><span class="p">)</span>
    <span class="n">Pxy</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">csd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="p">,</span> <span class="n">detrend</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="p">,</span> <span class="n">sides</span><span class="p">,</span>
                 <span class="n">scale_by_freq</span><span class="p">)</span>
    <span class="n">Cxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Pxy</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">Pxx</span> <span class="o">*</span> <span class="n">Pyy</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Cxy</span><span class="p">,</span> <span class="n">f</span></div>


<div class="viewcode-block" id="donothing_callback"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.donothing_callback">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s1">&#39;2.2&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">donothing_callback</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="cohere_pairs"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.cohere_pairs">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s1">&#39;2.2&#39;</span><span class="p">,</span> <span class="s1">&#39;scipy.signal.coherence&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">cohere_pairs</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">ij</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend_none</span><span class="p">,</span>
                 <span class="n">window</span><span class="o">=</span><span class="n">window_hanning</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">preferSpeedOverMemory</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">progressCallback</span><span class="o">=</span><span class="n">donothing_callback</span><span class="p">,</span>
                 <span class="n">returnPxx</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the coherence and phase for all pairs *ij*, in *X*.</span>

<span class="sd">    *X* is a *numSamples* * *numCols* array</span>

<span class="sd">    *ij* is a list of tuples.  Each tuple is a pair of indexes into</span>
<span class="sd">    the columns of X for which you want to compute coherence.  For</span>
<span class="sd">    example, if *X* has 64 columns, and you want to compute all</span>
<span class="sd">    nonredundant pairs, define *ij* as::</span>

<span class="sd">      ij = []</span>
<span class="sd">      for i in range(64):</span>
<span class="sd">          for j in range(i+1,64):</span>
<span class="sd">              ij.append( (i,j) )</span>

<span class="sd">    *preferSpeedOverMemory* is an optional bool. Defaults to true. If</span>
<span class="sd">    False, limits the caching by only making one, rather than two,</span>
<span class="sd">    complex cache arrays. This is useful if memory becomes critical.</span>
<span class="sd">    Even when *preferSpeedOverMemory* is False, :func:`cohere_pairs`</span>
<span class="sd">    will still give significant performance gains over calling</span>
<span class="sd">    :func:`cohere` for each pair, and will use subtantially less</span>
<span class="sd">    memory than if *preferSpeedOverMemory* is True.  In my tests with</span>
<span class="sd">    a 43000,64 array over all nonredundant pairs,</span>
<span class="sd">    *preferSpeedOverMemory* = True delivered a 33% performance boost</span>
<span class="sd">    on a 1.7GHZ Athlon with 512MB RAM compared with</span>
<span class="sd">    *preferSpeedOverMemory* = False.  But both solutions were more</span>
<span class="sd">    than 10x faster than naively crunching all possible pairs through</span>
<span class="sd">    :func:`cohere`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Cxy : dictionary of (*i*, *j*) tuples -&gt; coherence vector for</span>
<span class="sd">        that pair.  i.e., ``Cxy[(i,j) = cohere(X[:,i], X[:,j])``.</span>
<span class="sd">        Number of dictionary keys is ``len(ij)``.</span>

<span class="sd">    Phase : dictionary of phases of the cross spectral density at</span>
<span class="sd">        each frequency for each pair.  Keys are (*i*, *j*).</span>

<span class="sd">    freqs : vector of frequencies, equal in length to either the</span>
<span class="sd">         coherence or phase vectors for any (*i*, *j*) key.</span>

<span class="sd">    e.g., to make a coherence Bode plot::</span>

<span class="sd">          subplot(211)</span>
<span class="sd">          plot( freqs, Cxy[(12,19)])</span>
<span class="sd">          subplot(212)</span>
<span class="sd">          plot( freqs, Phase[(12,19)])</span>

<span class="sd">    For a large number of pairs, :func:`cohere_pairs` can be much more</span>
<span class="sd">    efficient than just calling :func:`cohere` for each pair, because</span>
<span class="sd">    it caches most of the intensive computations.  If :math:`N` is the</span>
<span class="sd">    number of pairs, this function is :math:`O(N)` for most of the</span>
<span class="sd">    heavy lifting, whereas calling cohere for each pair is</span>
<span class="sd">    :math:`O(N^2)`.  However, because of the caching, it is also more</span>
<span class="sd">    memory intensive, making 2 additional complex arrays with</span>
<span class="sd">    approximately the same number of elements as *X*.</span>

<span class="sd">    See :file:`test/cohere_pairs_test.py` in the src tree for an</span>
<span class="sd">    example script that shows that this :func:`cohere_pairs` and</span>
<span class="sd">    :func:`cohere` give the same results for a given pair.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`psd`</span>
<span class="sd">        For information about the methods used to compute :math:`P_{xy}`,</span>
<span class="sd">        :math:`P_{xx}` and :math:`P_{yy}`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">numRows</span><span class="p">,</span> <span class="n">numCols</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># zero pad if X is too short</span>
    <span class="k">if</span> <span class="n">numRows</span> <span class="o">&lt;</span> <span class="n">NFFT</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">X</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">numCols</span><span class="p">),</span> <span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">X</span><span class="p">[:</span><span class="n">numRows</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">del</span> <span class="n">tmp</span>

    <span class="n">numRows</span><span class="p">,</span> <span class="n">numCols</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="c1"># get all the columns of X that we are interested in by checking</span>
    <span class="c1"># the ij tuples</span>
    <span class="n">allColumns</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ij</span><span class="p">:</span>
        <span class="n">allColumns</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">allColumns</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
    <span class="n">Ncols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">allColumns</span><span class="p">)</span>

    <span class="c1"># for real X, ignore the negative frequencies</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
        <span class="n">numFreqs</span> <span class="o">=</span> <span class="n">NFFT</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">numFreqs</span> <span class="o">=</span> <span class="n">NFFT</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span>

    <span class="c1"># cache the FFT of every windowed, detrended NFFT length segment</span>
    <span class="c1"># of every channel.  If preferSpeedOverMemory, cache the conjugate</span>
    <span class="c1"># as well</span>
    <span class="k">if</span> <span class="n">cbook</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">window</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="o">!=</span> <span class="n">NFFT</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The length of the window must be equal to NFFT&quot;</span><span class="p">)</span>
        <span class="n">windowVals</span> <span class="o">=</span> <span class="n">window</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">windowVals</span> <span class="o">=</span> <span class="n">window</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">numRows</span><span class="o">-</span><span class="n">NFFT</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">-</span><span class="n">noverlap</span><span class="p">))</span>
    <span class="n">numSlices</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
    <span class="n">FFTSlices</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">FFTConjSlices</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">Pxx</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">numSlices</span><span class="p">)</span>
    <span class="n">normVal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">windowVals</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">for</span> <span class="n">iCol</span> <span class="ow">in</span> <span class="n">allColumns</span><span class="p">:</span>
        <span class="n">progressCallback</span><span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="n">Ncols</span><span class="p">,</span> <span class="s1">&#39;Cacheing FFTs&#39;</span><span class="p">)</span>
        <span class="n">Slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">numSlices</span><span class="p">,</span> <span class="n">numFreqs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iSlice</span> <span class="ow">in</span> <span class="n">slices</span><span class="p">:</span>
            <span class="n">thisSlice</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">iSlice</span><span class="p">]:</span><span class="n">ind</span><span class="p">[</span><span class="n">iSlice</span><span class="p">]</span><span class="o">+</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">iCol</span><span class="p">]</span>
            <span class="n">thisSlice</span> <span class="o">=</span> <span class="n">windowVals</span><span class="o">*</span><span class="n">detrend</span><span class="p">(</span><span class="n">thisSlice</span><span class="p">)</span>
            <span class="n">Slices</span><span class="p">[</span><span class="n">iSlice</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">thisSlice</span><span class="p">)[:</span><span class="n">numFreqs</span><span class="p">]</span>

        <span class="n">FFTSlices</span><span class="p">[</span><span class="n">iCol</span><span class="p">]</span> <span class="o">=</span> <span class="n">Slices</span>
        <span class="k">if</span> <span class="n">preferSpeedOverMemory</span><span class="p">:</span>
            <span class="n">FFTConjSlices</span><span class="p">[</span><span class="n">iCol</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">Slices</span><span class="p">)</span>
        <span class="n">Pxx</span><span class="p">[</span><span class="n">iCol</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Slices</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">normVal</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">Slices</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">windowVals</span>

    <span class="c1"># compute the coherences and phases for all pairs using the</span>
    <span class="c1"># cached FFTs</span>
    <span class="n">Cxy</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">Phase</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ij</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ij</span><span class="p">:</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">progressCallback</span><span class="p">(</span><span class="n">count</span><span class="o">/</span><span class="n">N</span><span class="p">,</span> <span class="s1">&#39;Computing coherences&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">preferSpeedOverMemory</span><span class="p">:</span>
            <span class="n">Pxy</span> <span class="o">=</span> <span class="n">FFTSlices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">FFTConjSlices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Pxy</span> <span class="o">=</span> <span class="n">FFTSlices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">FFTSlices</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">numSlices</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">Pxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Pxy</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="c1">#       Pxy = np.divide(Pxy, normVal)</span>
        <span class="n">Pxy</span> <span class="o">/=</span> <span class="n">normVal</span>
<span class="c1">#       Cxy[(i,j)] = np.divide(np.absolute(Pxy)**2, Pxx[i]*Pxx[j])</span>
        <span class="n">Cxy</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">Pxy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">Pxx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">Pxx</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="n">Phase</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">Pxy</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">Pxy</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>

    <span class="n">freqs</span> <span class="o">=</span> <span class="n">Fs</span><span class="o">/</span><span class="n">NFFT</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numFreqs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">returnPxx</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Cxy</span><span class="p">,</span> <span class="n">Phase</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">Pxx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Cxy</span><span class="p">,</span> <span class="n">Phase</span><span class="p">,</span> <span class="n">freqs</span></div>


<div class="viewcode-block" id="entropy"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.entropy">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s1">&#39;2.2&#39;</span><span class="p">,</span> <span class="s1">&#39;scipy.stats.entropy&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">entropy</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">bins</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the entropy of the data in *y* in units of nat.</span>

<span class="sd">    .. math::</span>

<span class="sd">      -\sum p_i \ln(p_i)</span>

<span class="sd">    where :math:`p_i` is the probability of observing *y* in the</span>
<span class="sd">    :math:`i^{th}` bin of *bins*.  *bins* can be a number of bins or a</span>
<span class="sd">    range of bins; see :func:`numpy.histogram`.</span>

<span class="sd">    Compare *S* with analytic calculation for a Gaussian::</span>

<span class="sd">      x = mu + sigma * randn(200000)</span>
<span class="sd">      Sanalytic = 0.5 * ( 1.0 + log(2*pi*sigma**2.0) )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">n</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>         <span class="c1"># get the positive</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

    <span class="n">delta</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">S</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">S</span></div>


<div class="viewcode-block" id="normpdf"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.normpdf">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s1">&#39;2.2&#39;</span><span class="p">,</span> <span class="s1">&#39;scipy.stats.norm.pdf&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">normpdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="s2">&quot;Return the normal pdf evaluated at *x*; args provides *mu*, *sigma*&quot;</span>
    <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">args</span>
    <span class="k">return</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">sigma</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">sigma</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">mu</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="find"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.find">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s1">&#39;2.2&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">condition</span><span class="p">):</span>
    <span class="s2">&quot;Return the indices where ravel(condition) is true&quot;</span>
    <span class="n">res</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">condition</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="longest_contiguous_ones"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.longest_contiguous_ones">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s1">&#39;2.2&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">longest_contiguous_ones</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the indices of the longest stretch of contiguous ones in *x*,</span>
<span class="sd">    assuming *x* is a vector of zeros and ones.  If there are two</span>
<span class="sd">    equally long stretches, pick the first.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="n">ind</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">,),</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">dif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">up</span> <span class="o">=</span> <span class="p">(</span><span class="n">dif</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dn</span> <span class="o">=</span> <span class="p">(</span><span class="n">dif</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">dn</span><span class="o">-</span><span class="n">up</span> <span class="o">==</span> <span class="nb">max</span><span class="p">(</span><span class="n">dn</span> <span class="o">-</span> <span class="n">up</span><span class="p">))</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">up</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dn</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">ind</span></div>


<div class="viewcode-block" id="longest_ones"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.longest_ones">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s1">&#39;2.2&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">longest_ones</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;alias for longest_contiguous_ones&#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">longest_contiguous_ones</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="PCA"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.PCA">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s1">&#39;2.2&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">PCA</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        compute the SVD of a and store data for PCA.  Use project to</span>
<span class="sd">        project the data onto a reduced set of dimensions</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a : np.ndarray</span>
<span class="sd">            A numobservations x numdims array</span>
<span class="sd">        standardize : bool</span>
<span class="sd">            True if input data are to be standardized. If False, only centering</span>
<span class="sd">            will be carried out.</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        a</span>
<span class="sd">            A centered unit sigma version of input ``a``.</span>

<span class="sd">        numrows, numcols</span>
<span class="sd">            The dimensions of ``a``.</span>

<span class="sd">        mu</span>
<span class="sd">            A numdims array of means of ``a``. This is the vector that points</span>
<span class="sd">            to the origin of PCA space.</span>

<span class="sd">        sigma</span>
<span class="sd">            A numdims array of standard deviation of ``a``.</span>

<span class="sd">        fracs</span>
<span class="sd">            The proportion of variance of each of the principal components.</span>

<span class="sd">        s</span>
<span class="sd">            The actual eigenvalues of the decomposition.</span>

<span class="sd">        Wt</span>
<span class="sd">            The weight vector for projecting a numdims point or array into</span>
<span class="sd">            PCA space.</span>

<span class="sd">        Y</span>
<span class="sd">            A projected into PCA space.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The factor loadings are in the ``Wt`` factor, i.e., the factor loadings</span>
<span class="sd">        for the first principal component are given by ``Wt[0]``. This row is</span>
<span class="sd">        also the first eigenvector.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;we assume data in a is organized with &#39;</span>
                               <span class="s1">&#39;numrows&gt;numcols&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">numrows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">numcols</span> <span class="o">=</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span> <span class="o">=</span> <span class="n">standardize</span>

        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>

        <span class="n">U</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">Vh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Note: .H indicates the conjugate transposed / Hermitian.</span>

        <span class="c1"># The SVD is commonly written as a = U s V.H.</span>
        <span class="c1"># If U is a unitary matrix, it means that it satisfies U.H = inv(U).</span>

        <span class="c1"># The rows of Vh are the eigenvectors of a.H a.</span>
        <span class="c1"># The columns of U are the eigenvectors of a a.H.</span>
        <span class="c1"># For row i in Vh and column i in U, the corresponding eigenvalue is</span>
        <span class="c1"># s[i]**2.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Wt</span> <span class="o">=</span> <span class="n">Vh</span>

        <span class="c1"># save the transposed coordinates</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Vh</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span>

        <span class="c1"># save the eigenvalues</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">**</span><span class="mi">2</span>

        <span class="c1"># and now the contribution of the individual components</span>
        <span class="nb">vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fracs</span> <span class="o">=</span> <span class="nb">vars</span><span class="o">/</span><span class="nb">vars</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

<div class="viewcode-block" id="PCA.project"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.PCA.project">[docs]</a>    <span class="k">def</span> <span class="nf">project</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">minfrac</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        project x onto the principle axes, dropping any axes where fraction</span>
<span class="sd">        of variance&lt;minfrac</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">numcols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Expected an array with dims[-1]==</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">numcols</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Wt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fracs</span> <span class="o">&gt;=</span> <span class="n">minfrac</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">Yreduced</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[:,</span> <span class="n">mask</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Yreduced</span> <span class="o">=</span> <span class="n">Y</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Yreduced</span></div>

<div class="viewcode-block" id="PCA.center"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.PCA.center">[docs]</a>    <span class="k">def</span> <span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        center and optionally standardize the data using the mean and sigma</span>
<span class="sd">        from training set a</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_colinear</span><span class="p">():</span>
        <span class="n">c0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="mf">0.19294738</span><span class="p">,</span>  <span class="mf">0.6202667</span><span class="p">,</span>   <span class="mf">0.45962655</span><span class="p">,</span>  <span class="mf">0.07608613</span><span class="p">,</span>  <span class="mf">0.135818</span><span class="p">,</span>
            <span class="mf">0.83580842</span><span class="p">,</span>  <span class="mf">0.07218851</span><span class="p">,</span>  <span class="mf">0.48318321</span><span class="p">,</span>  <span class="mf">0.84472463</span><span class="p">,</span>  <span class="mf">0.18348462</span><span class="p">,</span>
            <span class="mf">0.81585306</span><span class="p">,</span>  <span class="mf">0.96923926</span><span class="p">,</span>  <span class="mf">0.12835919</span><span class="p">,</span>  <span class="mf">0.35075355</span><span class="p">,</span>  <span class="mf">0.15807861</span><span class="p">,</span>
            <span class="mf">0.837437</span><span class="p">,</span>    <span class="mf">0.10824303</span><span class="p">,</span>  <span class="mf">0.1723387</span><span class="p">,</span>   <span class="mf">0.43926494</span><span class="p">,</span>  <span class="mf">0.83705486</span><span class="p">])</span>

        <span class="n">c1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="o">-</span><span class="mf">1.17705601</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.513883</span><span class="p">,</span>   <span class="o">-</span><span class="mf">0.26614584</span><span class="p">,</span>  <span class="mf">0.88067144</span><span class="p">,</span>  <span class="mf">1.00474954</span><span class="p">,</span>
            <span class="o">-</span><span class="mf">1.1616545</span><span class="p">,</span>   <span class="mf">0.0266109</span><span class="p">,</span>   <span class="mf">0.38227157</span><span class="p">,</span>  <span class="mf">1.80489433</span><span class="p">,</span>  <span class="mf">0.21472396</span><span class="p">,</span>
            <span class="o">-</span><span class="mf">1.41920399</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.08158544</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.10559009</span><span class="p">,</span>  <span class="mf">1.68999268</span><span class="p">,</span>  <span class="mf">0.34847107</span><span class="p">,</span>
            <span class="o">-</span><span class="mf">0.4685737</span><span class="p">,</span>   <span class="mf">1.23980423</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.14638744</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.35907697</span><span class="p">,</span>  <span class="mf">0.22442616</span><span class="p">])</span>

        <span class="n">c2</span> <span class="o">=</span> <span class="n">c0</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">c1</span>
        <span class="n">c3</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">c0</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">c1</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c3</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">a</span></div>


<div class="viewcode-block" id="prctile"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.prctile">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s1">&#39;2.2&#39;</span><span class="p">,</span> <span class="s1">&#39;numpy.percentile&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">prctile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">25.0</span><span class="p">,</span> <span class="mf">50.0</span><span class="p">,</span> <span class="mf">75.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the percentiles of *x*.  *p* can either be a sequence of</span>
<span class="sd">    percentile values or a scalar.  If *p* is a sequence, the ith</span>
<span class="sd">    element of the return sequence is the *p*(i)-th percentile of *x*.</span>
<span class="sd">    If *p* is a scalar, the largest value of *x* less than or equal to</span>
<span class="sd">    the *p* percentage point in the sequence is returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># This implementation derived from scipy.stats.scoreatpercentile</span>
    <span class="k">def</span> <span class="nf">_interpolate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">fraction</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the point at the given fraction between a and b, where</span>
<span class="sd">        &#39;fraction&#39; must be between 0 and 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">fraction</span>

    <span class="n">per</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

    <span class="n">idxs</span> <span class="o">=</span> <span class="n">per</span> <span class="o">/</span> <span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">ai</span> <span class="o">=</span> <span class="n">idxs</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">bi</span> <span class="o">=</span> <span class="n">ai</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">frac</span> <span class="o">=</span> <span class="n">idxs</span> <span class="o">%</span> <span class="mi">1</span>

    <span class="c1"># handle cases where attempting to interpolate past last index</span>
    <span class="n">cond</span> <span class="o">=</span> <span class="n">bi</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">per</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="n">ai</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">bi</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">frac</span><span class="p">[</span><span class="n">cond</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">cond</span><span class="p">:</span>
            <span class="n">ai</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">bi</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">frac</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">_interpolate</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">ai</span><span class="p">],</span> <span class="n">values</span><span class="p">[</span><span class="n">bi</span><span class="p">],</span> <span class="n">frac</span><span class="p">)</span></div>


<div class="viewcode-block" id="prctile_rank"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.prctile_rank">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s1">&#39;2.2&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">prctile_rank</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the rank for each element in *x*, return the rank</span>
<span class="sd">    0..len(*p*).  e.g., if *p* = (25, 50, 75), the return value will be a</span>
<span class="sd">    len(*x*) array with values in [0,1,2,3] where 0 indicates the</span>
<span class="sd">    value is less than the 25th percentile, 1 indicates the value is</span>
<span class="sd">    &gt;= the 25th and &lt; 50th percentile, ... and 3 indicates the value</span>
<span class="sd">    is above the 75th percentile cutoff.</span>

<span class="sd">    *p* is either an array of percentiles in [0..100] or a scalar which</span>
<span class="sd">    indicates how many quantiles of data you want ranked.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">cbook</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">100.0</span><span class="o">/</span><span class="n">p</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="o">/</span><span class="n">p</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">p</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">p</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;percentiles should be in range 0..100, not 0..1&#39;</span><span class="p">)</span>

    <span class="n">ptiles</span> <span class="o">=</span> <span class="n">prctile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">ptiles</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="center_matrix"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.center_matrix">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s1">&#39;2.2&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">center_matrix</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the matrix *M* with each row having zero mean and unit std.</span>

<span class="sd">    If *dim* = 1 operate on columns instead of rows.  (*dim* is</span>
<span class="sd">    opposite to the numpy axis kwarg.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dim</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">M</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="n">M</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">M</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">M</span> <span class="o">/</span> <span class="n">M</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">M</span></div>


<div class="viewcode-block" id="rk4"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.rk4">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s1">&#39;2.2&#39;</span><span class="p">,</span> <span class="s1">&#39;scipy.integrate.ode&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">rk4</span><span class="p">(</span><span class="n">derivs</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Integrate 1D or ND system of ODEs using 4-th order Runge-Kutta.</span>
<span class="sd">    This is a toy implementation which may be useful if you find</span>
<span class="sd">    yourself stranded on a system w/o scipy.  Otherwise use</span>
<span class="sd">    :func:`scipy.integrate`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y0</span>
<span class="sd">        initial state vector</span>

<span class="sd">    t</span>
<span class="sd">        sample times</span>

<span class="sd">    derivs</span>
<span class="sd">        returns the derivative of the system and has the</span>
<span class="sd">        signature ``dy = derivs(yi, ti)``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    A 2D system::</span>

<span class="sd">        def derivs6(x,t):</span>
<span class="sd">            d1 =  x[0] + 2*x[1]</span>
<span class="sd">            d2 =  -3*x[0] + 4*x[1]</span>
<span class="sd">            return (d1, d2)</span>
<span class="sd">        dt = 0.0005</span>
<span class="sd">        t = arange(0.0, 2.0, dt)</span>
<span class="sd">        y0 = (1,2)</span>
<span class="sd">        yout = rk4(derivs6, y0, t)</span>

<span class="sd">    A 1D system::</span>

<span class="sd">        alpha = 2</span>
<span class="sd">        def derivs(x,t):</span>
<span class="sd">            return -alpha*x + exp(-t)</span>

<span class="sd">        y0 = 1</span>
<span class="sd">        yout = rk4(derivs, y0, t)</span>

<span class="sd">    If you have access to scipy, you should probably be using the</span>
<span class="sd">    scipy.integrate tools rather than this function.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">Ny</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y0</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">yout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),),</span> <span class="nb">float</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">yout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">Ny</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>

    <span class="n">yout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">y0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>

        <span class="n">thist</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">thist</span>
        <span class="n">dt2</span> <span class="o">=</span> <span class="n">dt</span><span class="o">/</span><span class="mf">2.0</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="n">yout</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">k1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">derivs</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">thist</span><span class="p">))</span>
        <span class="n">k2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">derivs</span><span class="p">(</span><span class="n">y0</span> <span class="o">+</span> <span class="n">dt2</span><span class="o">*</span><span class="n">k1</span><span class="p">,</span> <span class="n">thist</span><span class="o">+</span><span class="n">dt2</span><span class="p">))</span>
        <span class="n">k3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">derivs</span><span class="p">(</span><span class="n">y0</span> <span class="o">+</span> <span class="n">dt2</span><span class="o">*</span><span class="n">k2</span><span class="p">,</span> <span class="n">thist</span><span class="o">+</span><span class="n">dt2</span><span class="p">))</span>
        <span class="n">k4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">derivs</span><span class="p">(</span><span class="n">y0</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">k3</span><span class="p">,</span> <span class="n">thist</span><span class="o">+</span><span class="n">dt</span><span class="p">))</span>
        <span class="n">yout</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">dt</span><span class="o">/</span><span class="mf">6.0</span><span class="o">*</span><span class="p">(</span><span class="n">k1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">k2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">k3</span> <span class="o">+</span> <span class="n">k4</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">yout</span></div>


<div class="viewcode-block" id="bivariate_normal"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.bivariate_normal">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s1">&#39;2.2&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">bivariate_normal</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">sigmax</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">sigmay</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                     <span class="n">mux</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">muy</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">sigmaxy</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Bivariate Gaussian distribution for equal shape *X*, *Y*.</span>

<span class="sd">    See `bivariate normal</span>
<span class="sd">    &lt;http://mathworld.wolfram.com/BivariateNormalDistribution.html&gt;`_</span>
<span class="sd">    at mathworld.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Xmu</span> <span class="o">=</span> <span class="n">X</span><span class="o">-</span><span class="n">mux</span>
    <span class="n">Ymu</span> <span class="o">=</span> <span class="n">Y</span><span class="o">-</span><span class="n">muy</span>

    <span class="n">rho</span> <span class="o">=</span> <span class="n">sigmaxy</span><span class="o">/</span><span class="p">(</span><span class="n">sigmax</span><span class="o">*</span><span class="n">sigmay</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">Xmu</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">sigmax</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">Ymu</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">sigmay</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">rho</span><span class="o">*</span><span class="n">Xmu</span><span class="o">*</span><span class="n">Ymu</span><span class="o">/</span><span class="p">(</span><span class="n">sigmax</span><span class="o">*</span><span class="n">sigmay</span><span class="p">)</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">sigmax</span><span class="o">*</span><span class="n">sigmay</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rho</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span> <span class="o">/</span> <span class="n">denom</span></div>


<div class="viewcode-block" id="get_xyz_where"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.get_xyz_where">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s1">&#39;2.2&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_xyz_where</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">Cond</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    *Z* and *Cond* are *M* x *N* matrices.  *Z* are data and *Cond* is</span>
<span class="sd">    a boolean matrix where some condition is satisfied.  Return value</span>
<span class="sd">    is (*x*, *y*, *z*) where *x* and *y* are the indices into *Z* and</span>
<span class="sd">    *z* are the values of *Z* at those indices.  *x*, *y*, and *z* are</span>
<span class="sd">    1D arrays.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">X</span><span class="p">[</span><span class="n">Cond</span><span class="p">],</span> <span class="n">Y</span><span class="p">[</span><span class="n">Cond</span><span class="p">],</span> <span class="n">Z</span><span class="p">[</span><span class="n">Cond</span><span class="p">]</span></div>


<div class="viewcode-block" id="get_sparse_matrix"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.get_sparse_matrix">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s1">&#39;2.2&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_sparse_matrix</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">frac</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a *M* x *N* sparse matrix with *frac* elements randomly</span>
<span class="sd">    filled.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span><span class="o">*</span><span class="mf">0.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">M</span><span class="o">*</span><span class="n">N</span><span class="o">*</span><span class="n">frac</span><span class="p">)):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="dist"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.dist">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s1">&#39;2.2&#39;</span><span class="p">,</span> <span class="s1">&#39;numpy.hypot&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">dist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the distance between two points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">x</span><span class="o">-</span><span class="n">y</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span></div>


<div class="viewcode-block" id="dist_point_to_segment"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.dist_point_to_segment">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s1">&#39;2.2&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">dist_point_to_segment</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the distance of a point to a segment.</span>

<span class="sd">      *p*, *s0*, *s1* are *xy* sequences</span>

<span class="sd">    This algorithm from</span>
<span class="sd">    http://geomalgorithms.com/a02-_lines.html</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">s0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">s0</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">-</span> <span class="n">s0</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">s0</span>

    <span class="n">c1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">c1</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dist</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">s0</span><span class="p">)</span>

    <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">c2</span> <span class="o">&lt;=</span> <span class="n">c1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dist</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span>

    <span class="n">b</span> <span class="o">=</span> <span class="n">c1</span> <span class="o">/</span> <span class="n">c2</span>
    <span class="n">pb</span> <span class="o">=</span> <span class="n">s0</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">v</span>
    <span class="k">return</span> <span class="n">dist</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pb</span><span class="p">)</span></div>


<div class="viewcode-block" id="segments_intersect"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.segments_intersect">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s1">&#39;2.2&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">segments_intersect</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return *True* if *s1* and *s2* intersect.</span>
<span class="sd">    *s1* and *s2* are defined as::</span>

<span class="sd">      s1: (x1, y1), (x2, y2)</span>
<span class="sd">      s2: (x3, y3), (x4, y4)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="o">=</span> <span class="n">s1</span>
    <span class="p">(</span><span class="n">x3</span><span class="p">,</span> <span class="n">y3</span><span class="p">),</span> <span class="p">(</span><span class="n">x4</span><span class="p">,</span> <span class="n">y4</span><span class="p">)</span> <span class="o">=</span> <span class="n">s2</span>

    <span class="n">den</span> <span class="o">=</span> <span class="p">((</span><span class="n">y4</span><span class="o">-</span><span class="n">y3</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x2</span><span class="o">-</span><span class="n">x1</span><span class="p">))</span> <span class="o">-</span> <span class="p">((</span><span class="n">x4</span><span class="o">-</span><span class="n">x3</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">y2</span><span class="o">-</span><span class="n">y1</span><span class="p">))</span>

    <span class="n">n1</span> <span class="o">=</span> <span class="p">((</span><span class="n">x4</span><span class="o">-</span><span class="n">x3</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y1</span><span class="o">-</span><span class="n">y3</span><span class="p">))</span> <span class="o">-</span> <span class="p">((</span><span class="n">y4</span><span class="o">-</span><span class="n">y3</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x1</span><span class="o">-</span><span class="n">x3</span><span class="p">))</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="p">((</span><span class="n">x2</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y1</span><span class="o">-</span><span class="n">y3</span><span class="p">))</span> <span class="o">-</span> <span class="p">((</span><span class="n">y2</span><span class="o">-</span><span class="n">y1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x1</span><span class="o">-</span><span class="n">x3</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">den</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># lines parallel</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="n">u1</span> <span class="o">=</span> <span class="n">n1</span><span class="o">/</span><span class="n">den</span>
    <span class="n">u2</span> <span class="o">=</span> <span class="n">n2</span><span class="o">/</span><span class="n">den</span>

    <span class="k">return</span> <span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">u1</span> <span class="o">&lt;=</span> <span class="mf">1.0</span> <span class="ow">and</span> <span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">u2</span> <span class="o">&lt;=</span> <span class="mf">1.0</span></div>


<div class="viewcode-block" id="fftsurr"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.fftsurr">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s1">&#39;2.2&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fftsurr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend_none</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window_none</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute an FFT phase randomized surrogate of *x*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cbook</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">window</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">window</span><span class="o">*</span><span class="n">detrend</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">window</span><span class="p">(</span><span class="n">detrend</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">real</span></div>


<div class="viewcode-block" id="movavg"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.movavg">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s1">&#39;2.2&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">movavg</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the len(*n*) moving average of *x*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">w</span><span class="p">[:]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">n</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">)</span></div>


<span class="c1"># the following code was written and submitted by Fernando Perez</span>
<span class="c1"># from the ipython numutils package under a BSD license</span>
<span class="c1"># begin fperez functions</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A set of convenient utilities for numerical work.</span>

<span class="sd">Most of this module requires numpy or is meant to be used with it.</span>

<span class="sd">Copyright (c) 2001-2004, Fernando Perez. &lt;Fernando.Perez@colorado.edu&gt;</span>
<span class="sd">All rights reserved.</span>

<span class="sd">This license was generated from the BSD license template as found in:</span>
<span class="sd">http://www.opensource.org/licenses/bsd-license.php</span>

<span class="sd">Redistribution and use in source and binary forms, with or without</span>
<span class="sd">modification, are permitted provided that the following conditions are met:</span>

<span class="sd">    * Redistributions of source code must retain the above copyright notice,</span>
<span class="sd">      this list of conditions and the following disclaimer.</span>

<span class="sd">    * Redistributions in binary form must reproduce the above copyright</span>
<span class="sd">      notice, this list of conditions and the following disclaimer in the</span>
<span class="sd">      documentation and/or other materials provided with the distribution.</span>

<span class="sd">    * Neither the name of the IPython project nor the names of its</span>
<span class="sd">      contributors may be used to endorse or promote products derived from</span>
<span class="sd">      this software without specific prior written permission.</span>

<span class="sd">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="sd">AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="sd">IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<span class="sd">DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE</span>
<span class="sd">FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span class="sd">DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
<span class="sd">SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
<span class="sd">CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span>
<span class="sd">OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="sd">OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="c1"># *****************************************************************************</span>
<span class="c1"># Globals</span>
<span class="c1"># ****************************************************************************</span>
<span class="c1"># function definitions</span>
<span class="n">exp_safe_MIN</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">2.2250738585072014e-308</span><span class="p">)</span>
<span class="n">exp_safe_MAX</span> <span class="o">=</span> <span class="mf">1.7976931348623157e+308</span>


<div class="viewcode-block" id="exp_safe"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.exp_safe">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">,</span> <span class="s1">&#39;numpy.exp&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">exp_safe</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute exponentials which safely underflow to zero.</span>

<span class="sd">    Slow, but convenient to use. Note that numpy provides proper</span>
<span class="sd">    floating point exception handling with access to the underlying</span>
<span class="sd">    hardware.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">exp_safe_MIN</span><span class="p">,</span> <span class="n">exp_safe_MAX</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="amap"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.amap">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s1">&#39;numpy.array(list(map(...)))&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">amap</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    amap(function, sequence[, sequence, ...]) -&gt; array.</span>

<span class="sd">    Works like :func:`map`, but it returns an array.  This is just a</span>
<span class="sd">    convenient shorthand for ``numpy.array(map(...))``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)))</span></div>


<div class="viewcode-block" id="rms_flat"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.rms_flat">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">rms_flat</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the root mean square of all the elements of *a*, flattened out.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span></div>


<div class="viewcode-block" id="l1norm"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.l1norm">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s1">&#39;numpy.linalg.norm(a, ord=1)&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">l1norm</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the *l1* norm of *a*, flattened out.</span>

<span class="sd">    Implemented as a separate function (not a call to :func:`norm` for speed).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="p">))</span></div>


<div class="viewcode-block" id="l2norm"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.l2norm">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s1">&#39;numpy.linalg.norm(a, ord=2)&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">l2norm</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the *l2* norm of *a*, flattened out.</span>

<span class="sd">    Implemented as a separate function (not a call to :func:`norm` for speed).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span></div>


<div class="viewcode-block" id="norm_flat"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.norm_flat">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s1">&#39;numpy.linalg.norm(a.flat, ord=p)&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">norm_flat</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    norm(a,p=2) -&gt; l-p norm of a.flat</span>

<span class="sd">    Return the l-p norm of *a*, considered as a flat array.  This is NOT a true</span>
<span class="sd">    matrix norm, since arrays of arbitrary rank are always flattened.</span>

<span class="sd">    *p* can be a number or the string &#39;Infinity&#39; to get the L-infinity norm.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># This function was being masked by a more general norm later in</span>
    <span class="c1"># the file.  We may want to simply delete it.</span>
    <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="s1">&#39;Infinity&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">**</span> <span class="n">p</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">p</span><span class="p">)</span></div>


<div class="viewcode-block" id="frange"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.frange">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">,</span> <span class="s1">&#39;numpy.arange&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">frange</span><span class="p">(</span><span class="n">xini</span><span class="p">,</span> <span class="n">xfin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    frange([start,] stop[, step, keywords]) -&gt; array of floats</span>

<span class="sd">    Return a numpy ndarray containing a progression of floats. Similar to</span>
<span class="sd">    :func:`numpy.arange`, but defaults to a closed interval.</span>

<span class="sd">    ``frange(x0, x1)`` returns ``[x0, x0+1, x0+2, ..., x1]``; *start*</span>
<span class="sd">    defaults to 0, and the endpoint *is included*. This behavior is</span>
<span class="sd">    different from that of :func:`range` and</span>
<span class="sd">    :func:`numpy.arange`. This is deliberate, since :func:`frange`</span>
<span class="sd">    will probably be more useful for generating lists of points for</span>
<span class="sd">    function evaluation, and endpoints are often desired in this</span>
<span class="sd">    use. The usual behavior of :func:`range` can be obtained by</span>
<span class="sd">    setting the keyword *closed* = 0, in this case, :func:`frange`</span>
<span class="sd">    basically becomes :func:numpy.arange`.</span>

<span class="sd">    When *step* is given, it specifies the increment (or</span>
<span class="sd">    decrement). All arguments can be floating point numbers.</span>

<span class="sd">    ``frange(x0,x1,d)`` returns ``[x0,x0+d,x0+2d,...,xfin]`` where</span>
<span class="sd">    *xfin* &lt;= *x1*.</span>

<span class="sd">    :func:`frange` can also be called with the keyword *npts*. This</span>
<span class="sd">    sets the number of points the list should contain (and overrides</span>
<span class="sd">    the value *step* might have been given). :func:`numpy.arange`</span>
<span class="sd">    doesn&#39;t offer this option.</span>

<span class="sd">    Examples::</span>

<span class="sd">      &gt;&gt;&gt; frange(3)</span>
<span class="sd">      array([ 0.,  1.,  2.,  3.])</span>
<span class="sd">      &gt;&gt;&gt; frange(3,closed=0)</span>
<span class="sd">      array([ 0.,  1.,  2.])</span>
<span class="sd">      &gt;&gt;&gt; frange(1,6,2)</span>
<span class="sd">      array([1, 3, 5])   or 1,3,5,7, depending on floating point vagueries</span>
<span class="sd">      &gt;&gt;&gt; frange(1,6.5,npts=5)</span>
<span class="sd">      array([ 1.   ,  2.375,  3.75 ,  5.125,  6.5  ])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># defaults</span>
    <span class="n">kw</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;closed&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">endpoint</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;closed&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span>

    <span class="c1"># funny logic to allow the *first* argument to be optional (like range())</span>
    <span class="c1"># This was modified with a simpler version from a similar frange() found</span>
    <span class="c1"># at http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/66472</span>
    <span class="k">if</span> <span class="n">xfin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">xfin</span> <span class="o">=</span> <span class="n">xini</span> <span class="o">+</span> <span class="mf">0.0</span>
        <span class="n">xini</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">if</span> <span class="n">delta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="c1"># compute # of points, spacing and return final list</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">npts</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;npts&#39;</span><span class="p">]</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">xfin</span><span class="o">-</span><span class="n">xini</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">npts</span><span class="o">-</span><span class="n">endpoint</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="n">npts</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="n">xfin</span><span class="o">-</span><span class="n">xini</span><span class="p">)</span><span class="o">/</span><span class="n">delta</span><span class="p">))</span> <span class="o">+</span> <span class="n">endpoint</span>
        <span class="c1"># round finds the nearest, so the endpoint can be up to</span>
        <span class="c1"># delta/2 larger than xfin.</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">npts</span><span class="p">)</span><span class="o">*</span><span class="n">delta</span><span class="o">+</span><span class="n">xini</span></div>
<span class="c1"># end frange()</span>


<div class="viewcode-block" id="identity"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.identity">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">,</span> <span class="s1">&#39;numpy.identity&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">identity</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;l&#39;</span><span class="p">,</span> <span class="n">typecode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the identity matrix of shape (*n*, *n*, ..., *n*) (rank *r*).</span>

<span class="sd">    For ranks higher than 2, this object is simply a multi-index Kronecker</span>
<span class="sd">    delta::</span>

<span class="sd">                            /  1  if i0=i1=...=iR,</span>
<span class="sd">        id[i0,i1,...,iR] = -|</span>
<span class="sd">                            \\  0  otherwise.</span>

<span class="sd">    Optionally a *dtype* (or typecode) may be given (it defaults to &#39;l&#39;).</span>

<span class="sd">    Since rank defaults to 2, this function behaves in the default case (when</span>
<span class="sd">    only *n* is given) like ``numpy.identity(n)`` -- but surprisingly, it is</span>
<span class="sd">    much faster.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">typecode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">typecode</span>
    <span class="n">iden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,)</span><span class="o">*</span><span class="n">rank</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,)</span><span class="o">*</span><span class="n">rank</span>
        <span class="n">iden</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">iden</span></div>


<div class="viewcode-block" id="base_repr"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.base_repr">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">base_repr</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the representation of a *number* in any given *base*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">chars</span> <span class="o">=</span> <span class="s1">&#39;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;</span>
    <span class="k">if</span> <span class="n">number</span> <span class="o">&lt;</span> <span class="n">base</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">padding</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">chars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">chars</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">number</span><span class="p">)]</span>
    <span class="n">max_exponent</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">number</span><span class="p">)</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">base</span><span class="p">))</span>
    <span class="n">max_power</span> <span class="o">=</span> <span class="n">long</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">**</span> <span class="n">max_exponent</span>
    <span class="n">lead_digit</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">number</span><span class="o">/</span><span class="n">max_power</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">chars</span><span class="p">[</span><span class="n">lead_digit</span><span class="p">]</span> <span class="o">+</span>
            <span class="n">base_repr</span><span class="p">(</span><span class="n">number</span> <span class="o">-</span> <span class="n">max_power</span> <span class="o">*</span> <span class="n">lead_digit</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span>
                      <span class="nb">max</span><span class="p">(</span><span class="n">padding</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_exponent</span><span class="p">)))</span></div>


<div class="viewcode-block" id="binary_repr"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.binary_repr">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">binary_repr</span><span class="p">(</span><span class="n">number</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">1025</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the binary representation of the input *number* as a</span>
<span class="sd">    string.</span>

<span class="sd">    This is more efficient than using :func:`base_repr` with base 2.</span>

<span class="sd">    Increase the value of max_length for very large numbers. Note that</span>
<span class="sd">    on 32-bit machines, 2**1023 is the largest integer power of 2</span>
<span class="sd">    which can be converted to a Python float.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="c1">#   assert number &lt; 2L &lt;&lt; max_length</span>
    <span class="n">shifts</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">rshift</span><span class="p">,</span> <span class="n">max_length</span> <span class="o">*</span> <span class="p">[</span><span class="n">number</span><span class="p">],</span>
                 <span class="nb">range</span><span class="p">(</span><span class="n">max_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">digits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mod</span><span class="p">,</span> <span class="n">shifts</span><span class="p">,</span> <span class="n">max_length</span> <span class="o">*</span> <span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">digits</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="n">digits</span> <span class="o">=</span> <span class="n">digits</span><span class="p">[</span><span class="n">digits</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">1</span><span class="p">):]</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">repr</span><span class="p">,</span> <span class="n">digits</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="log2"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.log2">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">,</span> <span class="s1">&#39;numpy.log2&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">log2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ln2</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the log(*x*) in base 2.</span>

<span class="sd">    This is a _slow_ function but which is guaranteed to return the correct</span>
<span class="sd">    integer value if the input is an integer exact power of 2.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">bin_n</span> <span class="o">=</span> <span class="n">binary_repr</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AssertionError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">ln2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;1&#39;</span> <span class="ow">in</span> <span class="n">bin_n</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">ln2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_n</span><span class="p">)</span></div>


<div class="viewcode-block" id="ispower2"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.ispower2">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ispower2</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the log base 2 of *n* if *n* is a power of 2, zero otherwise.</span>

<span class="sd">    Note the potential ambiguity if *n* == 1: 2**0 == 1, interpret accordingly.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">bin_n</span> <span class="o">=</span> <span class="n">binary_repr</span><span class="p">(</span><span class="n">n</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">if</span> <span class="s1">&#39;1&#39;</span> <span class="ow">in</span> <span class="n">bin_n</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_n</span><span class="p">)</span></div>


<div class="viewcode-block" id="isvector"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.isvector">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">isvector</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Like the MATLAB function with the same name, returns *True*</span>
<span class="sd">    if the supplied numpy array or matrix *X* looks like a vector,</span>
<span class="sd">    meaning it has a one non-singleton axis (i.e., it can have</span>
<span class="sd">    multiple axes, but all must have length 1, except for one of</span>
<span class="sd">    them).</span>

<span class="sd">    If you just want to see if the array has 1 axis, use X.ndim == 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span></div>

<span class="c1"># end fperez numutils code</span>


<span class="c1"># helpers for loading, saving, manipulating and viewing numpy record arrays</span>
<div class="viewcode-block" id="safe_isnan"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.safe_isnan">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">,</span> <span class="s1">&#39;numpy.isnan&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">safe_isnan</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="s1">&#39;:func:`numpy.isnan` for arbitrary types&#39;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">b</span></div>


<div class="viewcode-block" id="safe_isinf"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.safe_isinf">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">,</span> <span class="s1">&#39;numpy.isinf&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">safe_isinf</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="s1">&#39;:func:`numpy.isinf` for arbitrary types&#39;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">b</span></div>


<div class="viewcode-block" id="rec_append_fields"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.rec_append_fields">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">rec_append_fields</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">arrs</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a new record array with field names populated with data</span>
<span class="sd">    from arrays in *arrs*.  If appending a single field, then *names*,</span>
<span class="sd">    *arrs* and *dtypes* do not have to be lists. They can just be the</span>
<span class="sd">    values themselves.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">)</span> <span class="ow">and</span> <span class="n">cbook</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">)):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;number of arrays do not match number of names&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># we have only 1 name and 1 array</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span>
        <span class="n">arrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">arrs</span><span class="p">]</span>
    <span class="n">arrs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">,</span> <span class="n">arrs</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">dtypes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrs</span><span class="p">]</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">cbook</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">dtypes</span><span class="p">):</span>
        <span class="n">dtypes</span> <span class="o">=</span> <span class="p">[</span><span class="n">dtypes</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dtypes</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dtypes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">dtypes</span> <span class="o">=</span> <span class="n">dtypes</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dtypes must be None, a single dtype or a list&quot;</span><span class="p">)</span>
    <span class="n">old_dtypes</span> <span class="o">=</span> <span class="n">rec</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">descr</span>
    <span class="k">if</span> <span class="n">six</span><span class="o">.</span><span class="n">PY2</span><span class="p">:</span>
        <span class="n">old_dtypes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">name</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span> <span class="n">dt</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">old_dtypes</span><span class="p">]</span>
    <span class="n">newdtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">old_dtypes</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">dtypes</span><span class="p">)))</span>
    <span class="n">newrec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">(</span><span class="n">rec</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">newdtype</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">rec</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">fields</span><span class="p">:</span>
        <span class="n">newrec</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">rec</span><span class="p">[</span><span class="n">field</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">arr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">arrs</span><span class="p">):</span>
        <span class="n">newrec</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span>
    <span class="k">return</span> <span class="n">newrec</span></div>


<div class="viewcode-block" id="rec_drop_fields"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.rec_drop_fields">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">rec_drop_fields</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a new numpy record array with fields in *names* dropped.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

    <span class="n">newdtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="n">name</span><span class="p">,</span> <span class="n">rec</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">name</span><span class="p">])</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">rec</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
                         <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names</span><span class="p">])</span>

    <span class="n">newrec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">(</span><span class="n">rec</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">newdtype</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">newdtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
        <span class="n">newrec</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">rec</span><span class="p">[</span><span class="n">field</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">newrec</span></div>


<div class="viewcode-block" id="rec_keep_fields"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.rec_keep_fields">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">rec_keep_fields</span><span class="p">(</span><span class="n">rec</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a new numpy record array with only fields listed in names</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>

    <span class="n">arrays</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
        <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rec</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">fromarrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">)</span></div>


<div class="viewcode-block" id="rec_groupby"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.rec_groupby">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">rec_groupby</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">groupby</span><span class="p">,</span> <span class="n">stats</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    *r* is a numpy record array</span>

<span class="sd">    *groupby* is a sequence of record array attribute names that</span>
<span class="sd">    together form the grouping key.  e.g., (&#39;date&#39;, &#39;productcode&#39;)</span>

<span class="sd">    *stats* is a sequence of (*attr*, *func*, *outname*) tuples which</span>
<span class="sd">    will call ``x = func(attr)`` and assign *x* to the record array</span>
<span class="sd">    output with attribute *outname*.  For example::</span>

<span class="sd">      stats = ( (&#39;sales&#39;, len, &#39;numsales&#39;), (&#39;sales&#39;, np.mean, &#39;avgsale&#39;) )</span>

<span class="sd">    Return record array has *dtype* names for each attribute name in</span>
<span class="sd">    the *groupby* argument, with the associated group values, and</span>
<span class="sd">    for each outname name in the *stats* argument, with the associated</span>
<span class="sd">    stat summary output.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># build a dictionary from groupby keys-&gt; list of indices into r with</span>
    <span class="c1"># those keys</span>
    <span class="n">rowd</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">row</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">groupby</span><span class="p">])</span>
        <span class="n">rowd</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># sort the output by groupby keys</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">rowd</span><span class="p">):</span>
        <span class="n">row</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="c1"># get the indices for this groupby key</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">rowd</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">thisr</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="c1"># call each stat function for this groupby slice</span>
        <span class="n">row</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">func</span><span class="p">(</span><span class="n">thisr</span><span class="p">[</span><span class="n">attr</span><span class="p">])</span> <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">outname</span> <span class="ow">in</span> <span class="n">stats</span><span class="p">])</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>

    <span class="c1"># build the output record array with groupby and outname attributes</span>
    <span class="n">attrs</span><span class="p">,</span> <span class="n">funcs</span><span class="p">,</span> <span class="n">outnames</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">stats</span><span class="p">))</span>
    <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">groupby</span><span class="p">)</span>
    <span class="n">names</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">outnames</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">fromrecords</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">)</span></div>


<div class="viewcode-block" id="rec_summarize"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.rec_summarize">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">rec_summarize</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">summaryfuncs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    *r* is a numpy record array</span>

<span class="sd">    *summaryfuncs* is a list of (*attr*, *func*, *outname*) tuples</span>
<span class="sd">    which will apply *func* to the array *r*[attr] and assign the</span>
<span class="sd">    output to a new attribute name *outname*.  The returned record</span>
<span class="sd">    array is identical to *r*, with extra arrays for each element in</span>
<span class="sd">    *summaryfuncs*.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
    <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">attr</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">outname</span> <span class="ow">in</span> <span class="n">summaryfuncs</span><span class="p">:</span>
        <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">outname</span><span class="p">)</span>
        <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">attr</span><span class="p">])))</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">fromarrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">)</span></div>


<div class="viewcode-block" id="rec_join"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.rec_join">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">rec_join</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">jointype</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">,</span> <span class="n">defaults</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">r1postfix</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="p">,</span>
             <span class="n">r2postfix</span><span class="o">=</span><span class="s1">&#39;2&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Join record arrays *r1* and *r2* on *key*; *key* is a tuple of</span>
<span class="sd">    field names -- if *key* is a string it is assumed to be a single</span>
<span class="sd">    attribute name. If *r1* and *r2* have equal values on all the keys</span>
<span class="sd">    in the *key* tuple, then their fields will be merged into a new</span>
<span class="sd">    record array containing the intersection of the fields of *r1* and</span>
<span class="sd">    *r2*.</span>

<span class="sd">    *r1* (also *r2*) must not have any duplicate keys.</span>

<span class="sd">    The *jointype* keyword can be &#39;inner&#39;, &#39;outer&#39;, &#39;leftouter&#39;.  To</span>
<span class="sd">    do a rightouter join just reverse *r1* and *r2*.</span>

<span class="sd">    The *defaults* keyword is a dictionary filled with</span>
<span class="sd">    ``{column_name:default_value}`` pairs.</span>

<span class="sd">    The keywords *r1postfix* and *r2postfix* are postfixed to column names</span>
<span class="sd">    (other than keys) that are both in *r1* and *r2*.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">)</span>

    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">key</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">r1</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;r1 does not have key field </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">r2</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;r2 does not have key field </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">makekey</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">row</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">key</span><span class="p">])</span>

    <span class="n">r1d</span> <span class="o">=</span> <span class="p">{</span><span class="n">makekey</span><span class="p">(</span><span class="n">row</span><span class="p">):</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">r1</span><span class="p">)}</span>
    <span class="n">r2d</span> <span class="o">=</span> <span class="p">{</span><span class="n">makekey</span><span class="p">(</span><span class="n">row</span><span class="p">):</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">r2</span><span class="p">)}</span>

    <span class="n">r1keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">r1d</span><span class="p">)</span>
    <span class="n">r2keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">r2d</span><span class="p">)</span>

    <span class="n">common_keys</span> <span class="o">=</span> <span class="n">r1keys</span> <span class="o">&amp;</span> <span class="n">r2keys</span>

    <span class="n">r1ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">r1d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">common_keys</span><span class="p">])</span>
    <span class="n">r2ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">r2d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">common_keys</span><span class="p">])</span>

    <span class="n">common_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_keys</span><span class="p">)</span>
    <span class="n">left_len</span> <span class="o">=</span> <span class="n">right_len</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">jointype</span> <span class="o">==</span> <span class="s2">&quot;outer&quot;</span> <span class="ow">or</span> <span class="n">jointype</span> <span class="o">==</span> <span class="s2">&quot;leftouter&quot;</span><span class="p">:</span>
        <span class="n">left_keys</span> <span class="o">=</span> <span class="n">r1keys</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">r2keys</span><span class="p">)</span>
        <span class="n">left_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">r1d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">left_keys</span><span class="p">])</span>
        <span class="n">left_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">left_ind</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">jointype</span> <span class="o">==</span> <span class="s2">&quot;outer&quot;</span><span class="p">:</span>
        <span class="n">right_keys</span> <span class="o">=</span> <span class="n">r2keys</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">r1keys</span><span class="p">)</span>
        <span class="n">right_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">r2d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">right_keys</span><span class="p">])</span>
        <span class="n">right_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">right_ind</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">key_desc</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        if name is a string key, use the larger size of r1 or r2 before</span>
<span class="sd">        merging</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">dt1</span> <span class="o">=</span> <span class="n">r1</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">dt1</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">string_</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dt1</span><span class="o">.</span><span class="n">descr</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">dt2</span> <span class="o">=</span> <span class="n">r2</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">dt1</span> <span class="o">!=</span> <span class="n">dt2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The &#39;</span><span class="si">{}</span><span class="s2">&#39; fields in arrays &#39;r1&#39; and &#39;r2&#39; must &quot;</span>
                             <span class="s2">&quot;have the same dtype&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">dt1</span><span class="o">.</span><span class="n">num</span> <span class="o">&gt;</span> <span class="n">dt2</span><span class="o">.</span><span class="n">num</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dt1</span><span class="o">.</span><span class="n">descr</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">dt2</span><span class="o">.</span><span class="n">descr</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">keydesc</span> <span class="o">=</span> <span class="p">[</span><span class="n">key_desc</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">mapped_r1field</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The column name in *newrec* that corresponds to the column in *r1*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">key</span> <span class="ow">or</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">r2</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">name</span> <span class="o">+</span> <span class="n">r1postfix</span>

    <span class="k">def</span> <span class="nf">mapped_r2field</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The column name in *newrec* that corresponds to the column in *r2*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">key</span> <span class="ow">or</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">r1</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">name</span> <span class="o">+</span> <span class="n">r2postfix</span>

    <span class="n">r1desc</span> <span class="o">=</span> <span class="p">[(</span><span class="n">mapped_r1field</span><span class="p">(</span><span class="n">desc</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">desc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">desc</span> <span class="ow">in</span> <span class="n">r1</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">descr</span>
              <span class="k">if</span> <span class="n">desc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">key</span><span class="p">]</span>
    <span class="n">r2desc</span> <span class="o">=</span> <span class="p">[(</span><span class="n">mapped_r2field</span><span class="p">(</span><span class="n">desc</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">desc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">desc</span> <span class="ow">in</span> <span class="n">r2</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">descr</span>
              <span class="k">if</span> <span class="n">desc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">key</span><span class="p">]</span>
    <span class="n">all_dtypes</span> <span class="o">=</span> <span class="n">keydesc</span> <span class="o">+</span> <span class="n">r1desc</span> <span class="o">+</span> <span class="n">r2desc</span>
    <span class="k">if</span> <span class="n">six</span><span class="o">.</span><span class="n">PY2</span><span class="p">:</span>
        <span class="n">all_dtypes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">name</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">),</span> <span class="n">dt</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">all_dtypes</span><span class="p">]</span>
    <span class="n">newdtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">all_dtypes</span><span class="p">)</span>
    <span class="n">newrec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">((</span><span class="n">common_len</span> <span class="o">+</span> <span class="n">left_len</span> <span class="o">+</span> <span class="n">right_len</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">newdtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">defaults</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">thiskey</span> <span class="ow">in</span> <span class="n">defaults</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">thiskey</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">newdtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;rec_join defaults key=&quot;</span><span class="si">%s</span><span class="s1">&quot; not in new dtype &#39;</span>
                              <span class="s1">&#39;names &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">thiskey</span><span class="p">,</span> <span class="n">newdtype</span><span class="o">.</span><span class="n">names</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">newdtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">newdtype</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">dt</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">):</span>
            <span class="n">newrec</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">jointype</span> <span class="o">!=</span> <span class="s1">&#39;inner&#39;</span> <span class="ow">and</span> <span class="n">defaults</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># fill in the defaults enmasse</span>
        <span class="n">newrec_fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">newrec</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">fields</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">defaults</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">newrec_fields</span><span class="p">:</span>
                <span class="n">newrec</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

    <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">r1</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
        <span class="n">newfield</span> <span class="o">=</span> <span class="n">mapped_r1field</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">common_len</span><span class="p">:</span>
            <span class="n">newrec</span><span class="p">[</span><span class="n">newfield</span><span class="p">][:</span><span class="n">common_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">r1</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="n">r1ind</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">jointype</span> <span class="o">==</span> <span class="s2">&quot;outer&quot;</span> <span class="ow">or</span> <span class="n">jointype</span> <span class="o">==</span> <span class="s2">&quot;leftouter&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">left_len</span><span class="p">:</span>
            <span class="n">newrec</span><span class="p">[</span><span class="n">newfield</span><span class="p">][</span><span class="n">common_len</span><span class="p">:(</span><span class="n">common_len</span><span class="o">+</span><span class="n">left_len</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">r1</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="n">left_ind</span><span class="p">]</span>
            <span class="p">)</span>

    <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">r2</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
        <span class="n">newfield</span> <span class="o">=</span> <span class="n">mapped_r2field</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">key</span> <span class="ow">and</span> <span class="n">common_len</span><span class="p">:</span>
            <span class="n">newrec</span><span class="p">[</span><span class="n">newfield</span><span class="p">][:</span><span class="n">common_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">r2</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="n">r2ind</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">jointype</span> <span class="o">==</span> <span class="s2">&quot;outer&quot;</span> <span class="ow">and</span> <span class="n">right_len</span><span class="p">:</span>
            <span class="n">newrec</span><span class="p">[</span><span class="n">newfield</span><span class="p">][</span><span class="o">-</span><span class="n">right_len</span><span class="p">:]</span> <span class="o">=</span> <span class="n">r2</span><span class="p">[</span><span class="n">field</span><span class="p">][</span><span class="n">right_ind</span><span class="p">]</span>

    <span class="n">newrec</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">newrec</span></div>


<div class="viewcode-block" id="recs_join"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.recs_join">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">recs_join</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">recs</span><span class="p">,</span> <span class="n">jointype</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">postfixes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Join a sequence of record arrays on single column key.</span>

<span class="sd">    This function only joins a single column of the multiple record arrays</span>

<span class="sd">    *key*</span>
<span class="sd">      is the column name that acts as a key</span>

<span class="sd">    *name*</span>
<span class="sd">      is the name of the column that we want to join</span>

<span class="sd">    *recs*</span>
<span class="sd">      is a list of record arrays to join</span>

<span class="sd">    *jointype*</span>
<span class="sd">      is a string &#39;inner&#39; or &#39;outer&#39;</span>

<span class="sd">    *missing*</span>
<span class="sd">      is what any missing field is replaced by</span>

<span class="sd">    *postfixes*</span>
<span class="sd">      if not None, a len recs sequence of postfixes</span>

<span class="sd">    returns a record array with columns [rowkey, name0, name1, ... namen-1].</span>
<span class="sd">    or if postfixes [PF0, PF1, ..., PFN-1] are supplied,</span>
<span class="sd">    [rowkey, namePF0, namePF1, ... namePFN-1].</span>

<span class="sd">    Example::</span>

<span class="sd">      r = recs_join(&quot;date&quot;, &quot;close&quot;, recs=[r0, r1], missing=0.)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">aligned_iters</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">align_iterators</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="n">key</span><span class="p">),</span>
                                          <span class="o">*</span><span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">recs</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">missing</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">r</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">jointype</span> <span class="o">==</span> <span class="s2">&quot;outer&quot;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">rowkey</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">aligned_iters</span><span class="p">:</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">rowkey</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">extract</span><span class="p">,</span> <span class="n">row</span><span class="p">)))</span>
    <span class="k">elif</span> <span class="n">jointype</span> <span class="o">==</span> <span class="s2">&quot;inner&quot;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">rowkey</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">aligned_iters</span><span class="p">:</span>
            <span class="k">if</span> <span class="kc">None</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">row</span><span class="p">:</span>  <span class="c1"># throw out any Nones</span>
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">rowkey</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">extract</span><span class="p">,</span> <span class="n">row</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">postfixes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">postfixes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">recs</span><span class="p">))]</span>
    <span class="n">names</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">key</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">postfix</span><span class="p">)</span>
                              <span class="k">for</span> <span class="n">postfix</span> <span class="ow">in</span> <span class="n">postfixes</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">fromrecords</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">)</span></div>


<div class="viewcode-block" id="csv2rec"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.csv2rec">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">csv2rec</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">comments</span><span class="o">=</span><span class="s1">&#39;#&#39;</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">checkrows</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span>
            <span class="n">converterd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">missingd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">use_mrecords</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dayfirst</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">yearfirst</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load data from comma/space/tab delimited file in *fname* into a</span>
<span class="sd">    numpy record array and return the record array.</span>

<span class="sd">    If *names* is *None*, a header row is required to automatically</span>
<span class="sd">    assign the recarray names.  The headers will be lower cased,</span>
<span class="sd">    spaces will be converted to underscores, and illegal attribute</span>
<span class="sd">    name characters removed.  If *names* is not *None*, it is a</span>
<span class="sd">    sequence of names to use for the column names.  In this case, it</span>
<span class="sd">    is assumed there is no header row.</span>


<span class="sd">    - *fname*: can be a filename or a file handle.  Support for gzipped</span>
<span class="sd">      files is automatic, if the filename ends in &#39;.gz&#39;</span>

<span class="sd">    - *comments*: the character used to indicate the start of a comment</span>
<span class="sd">      in the file, or *None* to switch off the removal of comments</span>

<span class="sd">    - *skiprows*: is the number of rows from the top to skip</span>

<span class="sd">    - *checkrows*: is the number of rows to check to validate the column</span>
<span class="sd">      data type.  When set to zero all rows are validated.</span>

<span class="sd">    - *converterd*: if not *None*, is a dictionary mapping column number or</span>
<span class="sd">      munged column name to a converter function.</span>

<span class="sd">    - *names*: if not None, is a list of header names.  In this case, no</span>
<span class="sd">      header will be read from the file</span>

<span class="sd">    - *missingd* is a dictionary mapping munged column names to field values</span>
<span class="sd">      which signify that the field does not contain actual data and should</span>
<span class="sd">      be masked, e.g., &#39;0000-00-00&#39; or &#39;unused&#39;</span>

<span class="sd">    - *missing*: a string whose value signals a missing field regardless of</span>
<span class="sd">      the column it appears in</span>

<span class="sd">    - *use_mrecords*: if True, return an mrecords.fromrecords record array if</span>
<span class="sd">      any of the data are missing</span>

<span class="sd">    - *dayfirst*: default is False so that MM-DD-YY has precedence over</span>
<span class="sd">      DD-MM-YY.  See</span>
<span class="sd">      http://labix.org/python-dateutil#head-b95ce2094d189a89f80f5ae52a05b4ab7b41af47</span>
<span class="sd">      for further information.</span>

<span class="sd">    - *yearfirst*: default is False so that MM-DD-YY has precedence over</span>
<span class="sd">      YY-MM-DD. See</span>
<span class="sd">      http://labix.org/python-dateutil#head-b95ce2094d189a89f80f5ae52a05b4ab7b41af47</span>
<span class="sd">      for further information.</span>

<span class="sd">      If no rows are found, *None* is returned</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">converterd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">converterd</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">missingd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">missingd</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="kn">import</span> <span class="nn">dateutil.parser</span>
    <span class="kn">import</span> <span class="nn">datetime</span>

    <span class="n">fh</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">to_filehandle</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>

    <span class="n">delimiter</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">delimiter</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">FH</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For space-delimited files, we want different behavior than</span>
<span class="sd">        comma or tab.  Generally, we want multiple spaces to be</span>
<span class="sd">        treated as a single separator, whereas with comma and tab we</span>
<span class="sd">        want multiple commas to return multiple (empty) fields.  The</span>
<span class="sd">        join/strip trick below effects this.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fh</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fh</span> <span class="o">=</span> <span class="n">fh</span>

        <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fh</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">fix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>

        <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fh</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fh</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">delimiter</span> <span class="o">==</span> <span class="s1">&#39; &#39;</span><span class="p">:</span>
        <span class="n">fh</span> <span class="o">=</span> <span class="n">FH</span><span class="p">(</span><span class="n">fh</span><span class="p">)</span>

    <span class="n">reader</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">fh</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="n">delimiter</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">process_skiprows</span><span class="p">(</span><span class="n">reader</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">skiprows</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">reader</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">skiprows</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">break</span>

        <span class="k">return</span> <span class="n">fh</span><span class="p">,</span> <span class="n">reader</span>

    <span class="n">process_skiprows</span><span class="p">(</span><span class="n">reader</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ismissing</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="s2">&quot;Should the value val in column name be masked?&quot;</span>
        <span class="k">return</span> <span class="n">val</span> <span class="o">==</span> <span class="n">missing</span> <span class="ow">or</span> <span class="n">val</span> <span class="o">==</span> <span class="n">missingd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">or</span> <span class="n">val</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">with_default_value</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">default</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">newfunc</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ismissing</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">default</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newfunc</span>

    <span class="k">def</span> <span class="nf">mybool</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;True&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;False&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid bool&#39;</span><span class="p">)</span>

    <span class="n">dateparser</span> <span class="o">=</span> <span class="n">dateutil</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">parse</span>

    <span class="k">def</span> <span class="nf">mydateparser</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="c1"># try and return a datetime object</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">dateparser</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dayfirst</span><span class="o">=</span><span class="n">dayfirst</span><span class="p">,</span> <span class="n">yearfirst</span><span class="o">=</span><span class="n">yearfirst</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="n">mydateparser</span> <span class="o">=</span> <span class="n">with_default_value</span><span class="p">(</span><span class="n">mydateparser</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">myfloat</span> <span class="o">=</span> <span class="n">with_default_value</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">myint</span> <span class="o">=</span> <span class="n">with_default_value</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">mystr</span> <span class="o">=</span> <span class="n">with_default_value</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">mybool</span> <span class="o">=</span> <span class="n">with_default_value</span><span class="p">(</span><span class="n">mybool</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mydate</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="c1"># try and return a date object</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">dateparser</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dayfirst</span><span class="o">=</span><span class="n">dayfirst</span><span class="p">,</span> <span class="n">yearfirst</span><span class="o">=</span><span class="n">yearfirst</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">hour</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">d</span><span class="o">.</span><span class="n">minute</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">d</span><span class="o">.</span><span class="n">second</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;not a date&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">date</span><span class="p">()</span>
    <span class="n">mydate</span> <span class="o">=</span> <span class="n">with_default_value</span><span class="p">(</span><span class="n">mydate</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get_func</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="c1"># promote functions in this order</span>
        <span class="n">funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">mybool</span><span class="p">,</span> <span class="n">myint</span><span class="p">,</span> <span class="n">myfloat</span><span class="p">,</span> <span class="n">mydate</span><span class="p">,</span> <span class="n">mydateparser</span><span class="p">,</span> <span class="n">mystr</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">[</span><span class="n">funcs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">func</span><span class="p">):]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">func</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">return</span> <span class="n">func</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Could not find a working conversion function&#39;</span><span class="p">)</span>

    <span class="c1"># map column names that clash with builtins -- TODO - extend this list</span>
    <span class="n">itemd</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;return&#39;</span><span class="p">:</span> <span class="s1">&#39;return_&#39;</span><span class="p">,</span>
        <span class="s1">&#39;file&#39;</span><span class="p">:</span>   <span class="s1">&#39;file_&#39;</span><span class="p">,</span>
        <span class="s1">&#39;print&#39;</span><span class="p">:</span>  <span class="s1">&#39;print_&#39;</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">get_converters</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">comments</span><span class="p">):</span>

        <span class="n">converters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">reader</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="ow">and</span> <span class="n">comments</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                    <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">comments</span><span class="p">)):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">converters</span> <span class="o">=</span> <span class="p">[</span><span class="n">mybool</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">checkrows</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">checkrows</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">row</span><span class="p">)):</span>
                <span class="n">func</span> <span class="o">=</span> <span class="n">converterd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">func</span> <span class="o">=</span> <span class="n">converterd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">func</span> <span class="o">=</span> <span class="n">converters</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">strip</span><span class="p">()):</span>
                        <span class="n">func</span> <span class="o">=</span> <span class="n">get_func</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># how should we handle custom converters and defaults?</span>
                    <span class="n">func</span> <span class="o">=</span> <span class="n">with_default_value</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">converters</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span>
        <span class="k">return</span> <span class="n">converters</span>

    <span class="c1"># Get header and remove invalid characters</span>
    <span class="n">needheader</span> <span class="o">=</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">needheader</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">reader</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="ow">and</span> <span class="n">comments</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                    <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">comments</span><span class="p">)):</span>
                <span class="k">continue</span>
            <span class="n">headers</span> <span class="o">=</span> <span class="n">row</span>
            <span class="k">break</span>

        <span class="c1"># remove these chars</span>
        <span class="n">delete</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;~!@#$%^&amp;*()-=+~\|}[]{&#39;;: /?.&gt;,&lt;&quot;&quot;&quot;</span><span class="p">)</span>
        <span class="n">delete</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">)</span>

        <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">headers</span><span class="p">):</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span>
            <span class="n">item</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">item</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">delete</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
                <span class="n">item</span> <span class="o">=</span> <span class="s1">&#39;column</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span>

            <span class="n">item</span> <span class="o">=</span> <span class="n">itemd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
            <span class="n">cnt</span> <span class="o">=</span> <span class="n">seen</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span> <span class="o">+</span> <span class="s1">&#39;_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">cnt</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="n">seen</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt</span><span class="o">+</span><span class="mi">1</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)]</span>

    <span class="c1"># get the converter functions by inspecting checkrows</span>
    <span class="n">converters</span> <span class="o">=</span> <span class="n">get_converters</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">comments</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">converters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Could not find any valid data in CSV file&#39;</span><span class="p">)</span>

    <span class="c1"># reset the reader and start over</span>
    <span class="n">fh</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">reader</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">fh</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="n">delimiter</span><span class="p">)</span>
    <span class="n">process_skiprows</span><span class="p">(</span><span class="n">reader</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">needheader</span><span class="p">:</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># skip past any comments and consume one line of column header</span>
            <span class="n">row</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">reader</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="ow">and</span> <span class="n">comments</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                    <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">comments</span><span class="p">)):</span>
                <span class="k">continue</span>
            <span class="k">break</span>

    <span class="c1"># iterate over the remaining rows and convert the data to date</span>
    <span class="c1"># objects, ints, or floats as appropriate</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">rowmasks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">reader</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">comments</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">comments</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="c1"># Ensure that the row returned always has the same nr of elements</span>
        <span class="n">row</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">converters</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)))</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">func</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">func</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">converters</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">row</span><span class="p">)])</span>
        <span class="n">rowmasks</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ismissing</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">row</span><span class="p">)])</span>
    <span class="n">fh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">use_mrecords</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">rowmasks</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mrecords</span><span class="o">.</span><span class="n">fromrecords</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">rowmasks</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">fromrecords</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span></div>


<span class="c1"># a series of classes for describing the format intentions of various rec views</span>
<div class="viewcode-block" id="FormatObj"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.FormatObj">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">FormatObj</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<div class="viewcode-block" id="FormatObj.tostr"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.FormatObj.tostr">[docs]</a>    <span class="k">def</span> <span class="nf">tostr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">toval</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="FormatObj.toval"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.FormatObj.toval">[docs]</a>    <span class="k">def</span> <span class="nf">toval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="FormatObj.fromstr"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.FormatObj.fromstr">[docs]</a>    <span class="k">def</span> <span class="nf">fromstr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">s</span></div>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        override the hash function of any of the formatters, so that we don&#39;t</span>
<span class="sd">        create duplicate excel format styles</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span></div>


<div class="viewcode-block" id="FormatString"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.FormatString">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">FormatString</span><span class="p">(</span><span class="n">FormatObj</span><span class="p">):</span>
<div class="viewcode-block" id="FormatString.tostr"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.FormatString.tostr">[docs]</a>    <span class="k">def</span> <span class="nf">tostr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="FormatFormatStr"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.FormatFormatStr">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">FormatFormatStr</span><span class="p">(</span><span class="n">FormatObj</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span>

<div class="viewcode-block" id="FormatFormatStr.tostr"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.FormatFormatStr.tostr">[docs]</a>    <span class="k">def</span> <span class="nf">tostr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;None&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">toval</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="FormatFloat"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.FormatFloat">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">FormatFloat</span><span class="p">(</span><span class="n">FormatFormatStr</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
        <span class="n">FormatFormatStr</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%%</span><span class="s1">1.</span><span class="si">%d</span><span class="s1">f&#39;</span> <span class="o">%</span> <span class="n">precision</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">precision</span> <span class="o">=</span> <span class="n">precision</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">))</span>

<div class="viewcode-block" id="FormatFloat.toval"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.FormatFloat.toval">[docs]</a>    <span class="k">def</span> <span class="nf">toval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
        <span class="k">return</span> <span class="n">x</span></div>

<div class="viewcode-block" id="FormatFloat.fromstr"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.FormatFloat.fromstr">[docs]</a>    <span class="k">def</span> <span class="nf">fromstr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span></div></div>


<div class="viewcode-block" id="FormatInt"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.FormatInt">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">FormatInt</span><span class="p">(</span><span class="n">FormatObj</span><span class="p">):</span>

<div class="viewcode-block" id="FormatInt.tostr"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.FormatInt.tostr">[docs]</a>    <span class="k">def</span> <span class="nf">tostr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="FormatInt.toval"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.FormatInt.toval">[docs]</a>    <span class="k">def</span> <span class="nf">toval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="FormatInt.fromstr"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.FormatInt.fromstr">[docs]</a>    <span class="k">def</span> <span class="nf">fromstr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="FormatBool"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.FormatBool">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">FormatBool</span><span class="p">(</span><span class="n">FormatObj</span><span class="p">):</span>
<div class="viewcode-block" id="FormatBool.toval"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.FormatBool.toval">[docs]</a>    <span class="k">def</span> <span class="nf">toval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="FormatBool.fromstr"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.FormatBool.fromstr">[docs]</a>    <span class="k">def</span> <span class="nf">fromstr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">s</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="FormatPercent"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.FormatPercent">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">FormatPercent</span><span class="p">(</span><span class="n">FormatFloat</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">FormatFloat</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">100.</span><span class="p">)</span></div>


<div class="viewcode-block" id="FormatThousands"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.FormatThousands">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">FormatThousands</span><span class="p">(</span><span class="n">FormatFloat</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">FormatFloat</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">)</span></div>


<div class="viewcode-block" id="FormatMillions"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.FormatMillions">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">FormatMillions</span><span class="p">(</span><span class="n">FormatFloat</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">FormatFloat</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">)</span></div>


<div class="viewcode-block" id="FormatDate"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.FormatDate">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s1">&#39;date.strftime&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">FormatDate</span><span class="p">(</span><span class="n">FormatObj</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span><span class="p">))</span>

<div class="viewcode-block" id="FormatDate.toval"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.FormatDate.toval">[docs]</a>    <span class="k">def</span> <span class="nf">toval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;None&#39;</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fmt</span><span class="p">)</span></div>

<div class="viewcode-block" id="FormatDate.fromstr"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.FormatDate.fromstr">[docs]</a>    <span class="k">def</span> <span class="nf">fromstr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">dateutil.parser</span>
        <span class="k">return</span> <span class="n">dateutil</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="FormatDatetime"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.FormatDatetime">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s1">&#39;datetime.strftime&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">FormatDatetime</span><span class="p">(</span><span class="n">FormatDate</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span><span class="p">):</span>
        <span class="n">FormatDate</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="p">)</span>

<div class="viewcode-block" id="FormatDatetime.fromstr"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.FormatDatetime.fromstr">[docs]</a>    <span class="k">def</span> <span class="nf">fromstr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">dateutil.parser</span>
        <span class="k">return</span> <span class="n">dateutil</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="get_formatd"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.get_formatd">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_formatd</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">formatd</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="s1">&#39;build a formatd guaranteed to have a key for every dtype name&#39;</span>
    <span class="n">defaultformatd</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span> <span class="n">FormatBool</span><span class="p">(),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">:</span> <span class="n">FormatInt</span><span class="p">(),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">:</span> <span class="n">FormatInt</span><span class="p">(),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">:</span> <span class="n">FormatInt</span><span class="p">(),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">:</span> <span class="n">FormatFloat</span><span class="p">(),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span> <span class="n">FormatFloat</span><span class="p">(),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">:</span> <span class="n">FormatObj</span><span class="p">(),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">string_</span><span class="p">:</span> <span class="n">FormatString</span><span class="p">()}</span>

    <span class="k">if</span> <span class="n">formatd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">formatd</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="nb">format</span> <span class="o">=</span> <span class="n">formatd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">format</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">format</span> <span class="o">=</span> <span class="n">defaultformatd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">FormatObj</span><span class="p">())</span>
        <span class="n">formatd</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">format</span>
    <span class="k">return</span> <span class="n">formatd</span></div>


<div class="viewcode-block" id="csvformat_factory"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.csvformat_factory">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">csvformat_factory</span><span class="p">(</span><span class="nb">format</span><span class="p">):</span>
    <span class="nb">format</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">format</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">format</span><span class="p">,</span> <span class="n">FormatFloat</span><span class="p">):</span>
        <span class="nb">format</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># override scaling for storage</span>
        <span class="nb">format</span><span class="o">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%r</span><span class="s1">&#39;</span>
    <span class="k">return</span> <span class="nb">format</span></div>


<div class="viewcode-block" id="rec2txt"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.rec2txt">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s1">&#39;numpy.recarray.tofile&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">rec2txt</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a textual representation of a record array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r: numpy recarray</span>

<span class="sd">    header: list</span>
<span class="sd">        column headers</span>

<span class="sd">    padding:</span>
<span class="sd">        space between each column</span>

<span class="sd">    precision: number of decimal places to use for floats.</span>
<span class="sd">        Set to an integer to apply to all floats.  Set to a</span>
<span class="sd">        list of integers to apply precision individually.</span>
<span class="sd">        Precision for non-floats is simply ignored.</span>

<span class="sd">    fields : list</span>
<span class="sd">        If not None, a list of field names to print.  fields</span>
<span class="sd">        can be a list of strings like [&#39;field1&#39;, &#39;field2&#39;] or a single</span>
<span class="sd">        comma separated string like &#39;field1,field2&#39;</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    For ``precision=[0,2,3]``, the output is ::</span>

<span class="sd">      ID    Price   Return</span>
<span class="sd">      ABC   12.54    0.234</span>
<span class="sd">      XYZ    6.32   -0.076</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">fields</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">rec_keep_fields</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">fields</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cbook</span><span class="o">.</span><span class="n">is_numlike</span><span class="p">(</span><span class="n">precision</span><span class="p">):</span>
        <span class="n">precision</span> <span class="o">=</span> <span class="p">[</span><span class="n">precision</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_type</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">atype</span><span class="o">=</span><span class="nb">int</span><span class="p">):</span>
        <span class="n">tdict</span> <span class="o">=</span> <span class="p">{</span><span class="kc">None</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">:</span> <span class="nb">str</span><span class="p">}</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">atype</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">get_type</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">tdict</span><span class="p">[</span><span class="n">atype</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">atype</span>

    <span class="k">def</span> <span class="nf">get_justify</span><span class="p">(</span><span class="n">colname</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">precision</span><span class="p">):</span>
        <span class="n">ntype</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">dtype</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">ntype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">character</span><span class="p">):</span>
            <span class="n">fixed_width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ntype</span><span class="o">.</span><span class="n">str</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">colname</span><span class="p">),</span> <span class="n">fixed_width</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="o">+</span><span class="n">padding</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span>  <span class="c1"># left justify</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">ntype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">colname</span><span class="p">),</span>
                         <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">column</span><span class="p">))))))</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">,</span> <span class="n">length</span><span class="o">+</span><span class="n">padding</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">&quot;</span>  <span class="c1"># right justify</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">ntype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="s2">&quot;%.&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">precision</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;f&quot;</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">colname</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">fmt</span> <span class="o">%</span> <span class="n">x</span><span class="p">,</span> <span class="n">column</span><span class="p">)))))</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">,</span> <span class="n">length</span><span class="o">+</span><span class="n">padding</span><span class="p">,</span> <span class="n">fmt</span>   <span class="c1"># right justify</span>

        <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span>
                <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">colname</span><span class="p">),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">column</span><span class="p">))))))</span><span class="o">+</span><span class="n">padding</span><span class="p">,</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">header</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>

    <span class="n">justify_pad_prec</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_justify</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">r</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">colname</span><span class="p">),</span>
                                    <span class="n">precision</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">colname</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">)]</span>

    <span class="n">justify_pad_prec_spacer</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">justify_pad_prec</span><span class="p">)):</span>
        <span class="n">just</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">prec</span> <span class="o">=</span> <span class="n">justify_pad_prec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">justify_pad_prec_spacer</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">just</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pjust</span><span class="p">,</span> <span class="n">ppad</span><span class="p">,</span> <span class="n">pprec</span> <span class="o">=</span> <span class="n">justify_pad_prec</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">pjust</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">just</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">justify_pad_prec_spacer</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">just</span><span class="p">,</span> <span class="n">pad</span><span class="o">-</span><span class="n">padding</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">pjust</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">just</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">justify_pad_prec_spacer</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">just</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">padding</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">justify_pad_prec_spacer</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">just</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">format</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">just_pad_prec_spacer</span><span class="p">):</span>
        <span class="n">just</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">spacer</span> <span class="o">=</span> <span class="n">just_pad_prec_spacer</span>
        <span class="k">if</span> <span class="n">just</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">spacer</span><span class="o">*</span><span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">item</span><span class="p">)</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">pad</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">get_type</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
                <span class="n">item</span> <span class="o">=</span> <span class="p">(</span><span class="n">prec</span> <span class="o">%</span> <span class="nb">float</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">get_type</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
                <span class="n">item</span> <span class="o">=</span> <span class="p">(</span><span class="n">prec</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">item</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="n">pad</span><span class="p">)</span>

    <span class="n">textl</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">textl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">format</span><span class="p">(</span><span class="n">colitem</span><span class="p">,</span> <span class="n">justify_pad_prec_spacer</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                          <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">colitem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">header</span><span class="p">)]))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
        <span class="n">textl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">format</span><span class="p">(</span><span class="n">colitem</span><span class="p">,</span> <span class="n">justify_pad_prec_spacer</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                              <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">colitem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row</span><span class="p">)]))</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">textl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">textl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>

    <span class="n">text</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">linesep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">textl</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">text</span></div>


<div class="viewcode-block" id="rec2csv"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.rec2csv">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s1">&#39;numpy.recarray.tofile&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">rec2csv</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">formatd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
            <span class="n">missingd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">withheader</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Save the data from numpy recarray *r* into a</span>
<span class="sd">    comma-/space-/tab-delimited file.  The record array dtype names</span>
<span class="sd">    will be used for column headers.</span>

<span class="sd">    *fname*: can be a filename or a file handle.  Support for gzipped</span>
<span class="sd">      files is automatic, if the filename ends in &#39;.gz&#39;</span>

<span class="sd">    *withheader*: if withheader is False, do not write the attribute</span>
<span class="sd">      names in the first row</span>

<span class="sd">    for formatd type FormatFloat, we override the precision to store</span>
<span class="sd">    full precision floats in the CSV file</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`csv2rec`</span>
<span class="sd">        For information about *missing* and *missingd*, which can be used to</span>
<span class="sd">        fill in masked values into your CSV file.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">delimiter</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">delimiter</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">missingd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">missingd</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">with_mask</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">newfunc</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mval</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mask</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">mval</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newfunc</span>

    <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;rec2csv only operates on 1 dimensional recarrays&#39;</span><span class="p">)</span>

    <span class="n">formatd</span> <span class="o">=</span> <span class="n">get_formatd</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">formatd</span><span class="p">)</span>
    <span class="n">funcs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
        <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">with_mask</span><span class="p">(</span><span class="n">csvformat_factory</span><span class="p">(</span><span class="n">formatd</span><span class="p">[</span><span class="n">name</span><span class="p">])</span><span class="o">.</span><span class="n">tostr</span><span class="p">))</span>

    <span class="n">fh</span><span class="p">,</span> <span class="n">opened</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">to_filehandle</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">,</span> <span class="n">return_opened</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">writer</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">fh</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="n">delimiter</span><span class="p">)</span>
    <span class="n">header</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
    <span class="k">if</span> <span class="n">withheader</span><span class="p">:</span>
        <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>

    <span class="c1"># Our list of specials for missing values</span>
    <span class="n">mvals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">header</span><span class="p">:</span>
        <span class="n">mvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">missingd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">missing</span><span class="p">))</span>

    <span class="n">ismasked</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ismasked</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="s1">&#39;_fieldmask&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ismasked</span><span class="p">:</span>
            <span class="n">row</span><span class="p">,</span> <span class="n">rowmask</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="n">row</span><span class="o">.</span><span class="n">_fieldmask</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rowmask</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
        <span class="n">writer</span><span class="o">.</span><span class="n">writerow</span><span class="p">([</span><span class="n">func</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mval</span><span class="p">)</span> <span class="k">for</span> <span class="n">func</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">mval</span>
                         <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">rowmask</span><span class="p">,</span> <span class="n">mvals</span><span class="p">)])</span>
    <span class="k">if</span> <span class="n">opened</span><span class="p">:</span>
        <span class="n">fh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<div class="viewcode-block" id="griddata"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.griddata">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s1">&#39;2.2&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">griddata</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">interp</span><span class="o">=</span><span class="s1">&#39;nn&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpolates from a nonuniformly spaced grid to some other grid.</span>

<span class="sd">    Fits a surface of the form z = f(`x`, `y`) to the data in the</span>
<span class="sd">    (usually) nonuniformly spaced vectors (`x`, `y`, `z`), then</span>
<span class="sd">    interpolates this surface at the points specified by</span>
<span class="sd">    (`xi`, `yi`) to produce `zi`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y, z : 1d array_like</span>
<span class="sd">        Coordinates of grid points to interpolate from.</span>
<span class="sd">    xi, yi : 1d or 2d array_like</span>
<span class="sd">        Coordinates of grid points to interpolate to.</span>
<span class="sd">    interp : string key from {&#39;nn&#39;, &#39;linear&#39;}</span>
<span class="sd">        Interpolation algorithm, either &#39;nn&#39; for natural neighbor, or</span>
<span class="sd">        &#39;linear&#39; for linear interpolation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    2d float array</span>
<span class="sd">        Array of values interpolated at (`xi`, `yi`) points.  Array</span>
<span class="sd">        will be masked is any of (`xi`, `yi`) are outside the convex</span>
<span class="sd">        hull of (`x`, `y`).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If `interp` is &#39;nn&#39; (the default), uses natural neighbor</span>
<span class="sd">    interpolation based on Delaunay triangulation.  This option is</span>
<span class="sd">    only available if the mpl_toolkits.natgrid module is installed.</span>
<span class="sd">    This can be downloaded from https://github.com/matplotlib/natgrid.</span>
<span class="sd">    The (`xi`, `yi`) grid must be regular and monotonically increasing</span>
<span class="sd">    in this case.</span>

<span class="sd">    If `interp` is &#39;linear&#39;, linear interpolation is used via</span>
<span class="sd">    matplotlib.tri.LinearTriInterpolator.</span>

<span class="sd">    Instead of using `griddata`, more flexible functionality and other</span>
<span class="sd">    interpolation options are available using a</span>
<span class="sd">    matplotlib.tri.Triangulation and a matplotlib.tri.TriInterpolator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check input arguments.</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="ow">or</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span> <span class="ow">or</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x, y and z must be equal-length 1-D arrays&quot;</span><span class="p">)</span>

    <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">yi</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">xi</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">yi</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;xi and yi must be arrays with the same number of &quot;</span>
                         <span class="s2">&quot;dimensions (1 or 2)&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">xi</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">xi</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">yi</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;if xi and yi are 2D arrays, they must have the same &quot;</span>
                         <span class="s2">&quot;shape&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">xi</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">interp</span> <span class="o">==</span> <span class="s1">&#39;nn&#39;</span><span class="p">:</span>
        <span class="n">use_nn_interpolation</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">interp</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
        <span class="n">use_nn_interpolation</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;interp keyword must be one of &#39;linear&#39; (for linear &quot;</span>
                         <span class="s2">&quot;interpolation) or &#39;nn&#39; (for natural neighbor &quot;</span>
                         <span class="s2">&quot;interpolation).  Default is &#39;nn&#39;.&quot;</span><span class="p">)</span>

    <span class="c1"># Remove masked points.</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">nomask</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">use_nn_interpolation</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">mpl_toolkits.natgrid</span> <span class="k">import</span> <span class="n">_natgrid</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="s2">&quot;To use interp=&#39;nn&#39; (Natural Neighbor interpolation) in &quot;</span>
                <span class="s2">&quot;griddata, natgrid must be installed. Either install it &quot;</span>
                <span class="s2">&quot;from http://github.com/matplotlib/natgrid or use &quot;</span>
                <span class="s2">&quot;interp=&#39;linear&#39; instead.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">xi</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># natgrid expects 1D xi and yi arrays.</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="n">xi</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">yi</span> <span class="o">=</span> <span class="n">yi</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Override default natgrid internal parameters.</span>
        <span class="n">_natgrid</span><span class="o">.</span><span class="n">seti</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;ext&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">_natgrid</span><span class="o">.</span><span class="n">setr</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;nul&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xi</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">yi</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Output grid defined by xi,yi must be monotone &quot;</span>
                             <span class="s2">&quot;increasing&quot;</span><span class="p">)</span>

        <span class="c1"># Allocate array for output (buffer will be overwritten by natgridd)</span>
        <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">yi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># Natgrid requires each array to be contiguous rather than e.g. a view</span>
        <span class="c1"># that is a non-contiguous slice of another array.  Use numpy.require</span>
        <span class="c1"># to deal with this, which will copy if necessary.</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">])</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">])</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">])</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">])</span>
        <span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">yi</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">])</span>
        <span class="n">_natgrid</span><span class="o">.</span><span class="n">natgridd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">zi</span><span class="p">)</span>

        <span class="c1"># Mask points on grid outside convex hull of input data.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">zi</span><span class="p">)):</span>
            <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">zi</span><span class="p">),</span> <span class="n">zi</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">zi</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Linear interpolation performed using a matplotlib.tri.Triangulation</span>
        <span class="c1"># and a matplotlib.tri.LinearTriInterpolator.</span>
        <span class="kn">from</span> <span class="nn">.tri</span> <span class="k">import</span> <span class="n">Triangulation</span><span class="p">,</span> <span class="n">LinearTriInterpolator</span>
        <span class="n">triang</span> <span class="o">=</span> <span class="n">Triangulation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">interpolator</span> <span class="o">=</span> <span class="n">LinearTriInterpolator</span><span class="p">(</span><span class="n">triang</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">interpolator</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span></div>


<span class="c1">##################################################</span>
<span class="c1"># Linear interpolation algorithms</span>
<span class="c1">##################################################</span>
<div class="viewcode-block" id="less_simple_linear_interpolation"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.less_simple_linear_interpolation">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;numpy.interp&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">less_simple_linear_interpolation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">extrap</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function provides simple (but somewhat less so than</span>
<span class="sd">    :func:`cbook.simple_linear_interpolation`) linear interpolation.</span>
<span class="sd">    :func:`simple_linear_interpolation` will give a list of point</span>
<span class="sd">    between a start and an end, while this does true linear</span>
<span class="sd">    interpolation at an arbitrary set of points.</span>

<span class="sd">    This is very inefficient linear interpolation meant to be used</span>
<span class="sd">    only for a small number of points in relatively non-intensive use</span>
<span class="sd">    cases.  For real linear interpolation, use scipy.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>

    <span class="n">s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
    <span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">xx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xi</span><span class="p">):</span>
        <span class="n">bb</span> <span class="o">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">xx</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">bb</span><span class="p">):</span>
            <span class="n">jj</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">bb</span><span class="p">)</span>
            <span class="n">yi</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">jj</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="n">xx</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">extrap</span><span class="p">:</span>
                <span class="n">yi</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">xx</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">extrap</span><span class="p">:</span>
                <span class="n">yi</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">jj</span><span class="p">,</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">xx</span><span class="p">)</span>
            <span class="n">jj</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">jj</span><span class="p">)</span>

            <span class="n">yi</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">xx</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">jj</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="n">jj</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="n">jj</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">yi</span></div>


<div class="viewcode-block" id="slopes"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.slopes">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">slopes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :func:`slopes` calculates the slope *y*&#39;(*x*)</span>

<span class="sd">    The slope is estimated using the slope obtained from that of a</span>
<span class="sd">    parabola through any three consecutive points.</span>

<span class="sd">    This method should be superior to that described in the appendix</span>
<span class="sd">    of A CONSISTENTLY WELL BEHAVED METHOD OF INTERPOLATION by Russel</span>
<span class="sd">    W. Stineman (Creative Computing July 1980) in at least one aspect:</span>

<span class="sd">      Circles for interpolation demand a known aspect ratio between</span>
<span class="sd">      *x*- and *y*-values.  For many functions, however, the abscissa</span>
<span class="sd">      are given in different dimensions, so an aspect ratio is</span>
<span class="sd">      completely arbitrary.</span>

<span class="sd">    The parabola method gives very similar results to the circle</span>
<span class="sd">    method for most regular cases but behaves much better in special</span>
<span class="sd">    cases.</span>

<span class="sd">    Norbert Nemec, Institute of Theoretical Physics, University or</span>
<span class="sd">    Regensburg, April 2006 Norbert.Nemec at physik.uni-regensburg.de</span>

<span class="sd">    (inspired by a original implementation by Halldor Bjornsson,</span>
<span class="sd">    Icelandic Meteorological Office, March 2006 halldor at vedur.is)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Cast key variables as float.</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

    <span class="n">yp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

    <span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">dydx</span> <span class="o">=</span> <span class="n">dy</span><span class="o">/</span><span class="n">dx</span>
    <span class="n">yp</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dydx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dx</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">dydx</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">*</span> <span class="n">dx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">dx</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">dx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">yp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">dy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">yp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">yp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">dy</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">dx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">yp</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">yp</span></div>


<div class="viewcode-block" id="stineman_interp"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.stineman_interp">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">stineman_interp</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">yp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given data vectors *x* and *y*, the slope vector *yp* and a new</span>
<span class="sd">    abscissa vector *xi*, the function :func:`stineman_interp` uses</span>
<span class="sd">    Stineman interpolation to calculate a vector *yi* corresponding to</span>
<span class="sd">    *xi*.</span>

<span class="sd">    Here&#39;s an example that generates a coarse sine curve, then</span>
<span class="sd">    interpolates over a finer abscissa::</span>

<span class="sd">      x = linspace(0,2*pi,20);  y = sin(x); yp = cos(x)</span>
<span class="sd">      xi = linspace(0,2*pi,40);</span>
<span class="sd">      yi = stineman_interp(xi,x,y,yp);</span>
<span class="sd">      plot(x,y,&#39;o&#39;,xi,yi)</span>

<span class="sd">    The interpolation method is described in the article A</span>
<span class="sd">    CONSISTENTLY WELL BEHAVED METHOD OF INTERPOLATION by Russell</span>
<span class="sd">    W. Stineman. The article appeared in the July 1980 issue of</span>
<span class="sd">    Creative Computing with a note from the editor stating that while</span>
<span class="sd">    they were:</span>

<span class="sd">      not an academic journal but once in a while something serious</span>
<span class="sd">      and original comes in adding that this was</span>
<span class="sd">      &quot;apparently a real solution&quot; to a well known problem.</span>

<span class="sd">    For *yp* = *None*, the routine automatically determines the slopes</span>
<span class="sd">    using the :func:`slopes` routine.</span>

<span class="sd">    *x* is assumed to be sorted in increasing order.</span>

<span class="sd">    For values ``xi[j] &lt; x[0]`` or ``xi[j] &gt; x[-1]``, the routine</span>
<span class="sd">    tries an extrapolation.  The relevance of the data obtained from</span>
<span class="sd">    this, of course, is questionable...</span>

<span class="sd">    Original implementation by Halldor Bjornsson, Icelandic</span>
<span class="sd">    Meteorolocial Office, March 2006 halldor at vedur.is</span>

<span class="sd">    Completely reworked and optimized for Python by Norbert Nemec,</span>
<span class="sd">    Institute of Theoretical Physics, University or Regensburg, April</span>
<span class="sd">    2006 Norbert.Nemec at physik.uni-regensburg.de</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Cast key variables as float.</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;x&#39; and &#39;y&#39; must be of same shape&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">yp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">yp</span> <span class="o">=</span> <span class="n">slopes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">yp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">yp</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

    <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

    <span class="c1"># calculate linear slopes</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">dy</span><span class="o">/</span><span class="n">dx</span>  <span class="c1"># note length of s is N-1 so last element is #N-2</span>

    <span class="c1"># find the segment each xi is in</span>
    <span class="c1"># this line actually is the key to the efficiency of this implementation</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">xi</span><span class="p">)</span>

    <span class="c1"># now we have generally: x[idx[j]] &lt;= xi[j] &lt;= x[idx[j]+1]</span>
    <span class="c1"># except at the boundaries, where it may be that xi[j] &lt; x[0] or</span>
    <span class="c1"># xi[j] &gt; x[-1]</span>

    <span class="c1"># the y-values that would come out from a linear interpolation:</span>
    <span class="n">sidx</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
    <span class="n">xidx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
    <span class="n">yidx</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
    <span class="n">xidxp1</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">yo</span> <span class="o">=</span> <span class="n">yidx</span> <span class="o">+</span> <span class="n">sidx</span> <span class="o">*</span> <span class="p">(</span><span class="n">xi</span> <span class="o">-</span> <span class="n">xidx</span><span class="p">)</span>

    <span class="c1"># the difference that comes when using the slopes given in yp</span>
    <span class="c1"># using the yp slope of the left point</span>
    <span class="n">dy1</span> <span class="o">=</span> <span class="p">(</span><span class="n">yp</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">-</span> <span class="n">sidx</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">xi</span> <span class="o">-</span> <span class="n">xidx</span><span class="p">)</span>
    <span class="c1"># using the yp slope of the right point</span>
    <span class="n">dy2</span> <span class="o">=</span> <span class="p">(</span><span class="n">yp</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">sidx</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">xi</span> <span class="o">-</span> <span class="n">xidxp1</span><span class="p">)</span>

    <span class="n">dy1dy2</span> <span class="o">=</span> <span class="n">dy1</span><span class="o">*</span><span class="n">dy2</span>
    <span class="c1"># The following is optimized for Python. The solution actually</span>
    <span class="c1"># does more calculations than necessary but exploiting the power</span>
    <span class="c1"># of numpy, this is far more efficient than coding a loop by hand</span>
    <span class="c1"># in Python</span>
    <span class="n">yi</span> <span class="o">=</span> <span class="n">yo</span> <span class="o">+</span> <span class="n">dy1dy2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">dy1dy2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                                 <span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">xi</span><span class="o">-</span><span class="n">xidx</span><span class="o">-</span><span class="n">xidxp1</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="n">dy1</span><span class="o">-</span><span class="n">dy2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">xidxp1</span><span class="o">-</span><span class="n">xidx</span><span class="p">)),</span>
                                  <span class="mf">0.0</span><span class="p">,</span>
                                  <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">dy1</span><span class="o">+</span><span class="n">dy2</span><span class="p">),))</span>
    <span class="k">return</span> <span class="n">yi</span></div>


<div class="viewcode-block" id="GaussianKDE"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.GaussianKDE">[docs]</a><span class="k">class</span> <span class="nc">GaussianKDE</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Representation of a kernel-density estimate using Gaussian kernels.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dataset : array_like</span>
<span class="sd">        Datapoints to estimate from. In case of univariate data this is a 1-D</span>
<span class="sd">        array, otherwise a 2-D array with shape (# of dims, # of data).</span>

<span class="sd">    bw_method : str, scalar or callable, optional</span>
<span class="sd">        The method used to calculate the estimator bandwidth.  This can be</span>
<span class="sd">        &#39;scott&#39;, &#39;silverman&#39;, a scalar constant or a callable.  If a</span>
<span class="sd">        scalar, this will be used directly as `kde.factor`.  If a</span>
<span class="sd">        callable, it should take a `GaussianKDE` instance as only</span>
<span class="sd">        parameter and return a scalar. If None (default), &#39;scott&#39; is used.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    dataset : ndarray</span>
<span class="sd">        The dataset with which `gaussian_kde` was initialized.</span>

<span class="sd">    dim : int</span>
<span class="sd">        Number of dimensions.</span>

<span class="sd">    num_dp : int</span>
<span class="sd">        Number of datapoints.</span>

<span class="sd">    factor : float</span>
<span class="sd">        The bandwidth factor, obtained from `kde.covariance_factor`, with which</span>
<span class="sd">        the covariance matrix is multiplied.</span>

<span class="sd">    covariance : ndarray</span>
<span class="sd">        The covariance matrix of `dataset`, scaled by the calculated bandwidth</span>
<span class="sd">        (`kde.factor`).</span>

<span class="sd">    inv_cov : ndarray</span>
<span class="sd">        The inverse of `covariance`.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    kde.evaluate(points) : ndarray</span>
<span class="sd">        Evaluate the estimated pdf on a provided set of points.</span>

<span class="sd">    kde(points) : ndarray</span>
<span class="sd">        Same as kde.evaluate(points)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># This implementation with minor modification was too good to pass up.</span>
    <span class="c1"># from scipy: https://github.com/scipy/scipy/blob/master/scipy/stats/kde.py</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">bw_method</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`dataset` input should have multiple elements.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">isString</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bw_method</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bw_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">isString</span> <span class="ow">and</span> <span class="n">bw_method</span> <span class="o">==</span> <span class="s1">&#39;scott&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">covariance_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scotts_factor</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">isString</span> <span class="ow">and</span> <span class="n">bw_method</span> <span class="o">==</span> <span class="s1">&#39;silverman&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">covariance_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">silverman_factor</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">bw_method</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">isString</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bw_method</span> <span class="o">=</span> <span class="s1">&#39;use constant&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">covariance_factor</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">bw_method</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">bw_method</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bw_method</span> <span class="o">=</span> <span class="n">bw_method</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">covariance_factor</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bw_method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`bw_method` should be &#39;scott&#39;, &#39;silverman&#39;, a &quot;</span>
                             <span class="s2">&quot;scalar or a callable&quot;</span><span class="p">)</span>

        <span class="c1"># Computes the covariance matrix for each Gaussian kernel using</span>
        <span class="c1"># covariance_factor().</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance_factor</span><span class="p">()</span>
        <span class="c1"># Cache covariance and inverse covariance of the data</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_data_inv_cov&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">,</span>
                    <span class="n">rowvar</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_inv_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_covariance</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_covariance</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inv_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_inv_cov</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span>
                <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dp</span>

<div class="viewcode-block" id="GaussianKDE.scotts_factor"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.GaussianKDE.scotts_factor">[docs]</a>    <span class="k">def</span> <span class="nf">scotts_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dp</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span></div>

<div class="viewcode-block" id="GaussianKDE.silverman_factor"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.GaussianKDE.silverman_factor">[docs]</a>    <span class="k">def</span> <span class="nf">silverman_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_dp</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">+</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span></div>

    <span class="c1">#  Default method to calculate bandwidth, can be overwritten by subclass</span>
    <span class="n">covariance_factor</span> <span class="o">=</span> <span class="n">scotts_factor</span>

<div class="viewcode-block" id="GaussianKDE.evaluate"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.GaussianKDE.evaluate">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the estimated pdf on a set of points.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        points : (# of dimensions, # of points)-array</span>
<span class="sd">            Alternatively, a (# of dimensions,) vector can be passed in and</span>
<span class="sd">            treated as a single point.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        values : (# of points,)-array</span>
<span class="sd">            The values at each point.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError : if the dimensionality of the input points is different</span>
<span class="sd">                     than the dimensionality of the KDE.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="n">dim</span><span class="p">,</span> <span class="n">num_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;points have dimension </span><span class="si">{}</span><span class="s2">, dataset has dimension &quot;</span>
                             <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_m</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">num_m</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dp</span><span class="p">:</span>
            <span class="c1"># there are more points than data, so loop over data</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dp</span><span class="p">):</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span>
                <span class="n">tdiff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inv_cov</span><span class="p">,</span> <span class="n">diff</span><span class="p">)</span>
                <span class="n">energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">diff</span> <span class="o">*</span> <span class="n">tdiff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">energy</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># loop over points</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_m</span><span class="p">):</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">-</span> <span class="n">points</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                <span class="n">tdiff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inv_cov</span><span class="p">,</span> <span class="n">diff</span><span class="p">)</span>
                <span class="n">energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">diff</span> <span class="o">*</span> <span class="n">tdiff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">energy</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_factor</span>

        <span class="k">return</span> <span class="n">result</span></div>

    <span class="fm">__call__</span> <span class="o">=</span> <span class="n">evaluate</span></div>


<span class="c1">##################################################</span>
<span class="c1"># Code related to things in and around polygons</span>
<span class="c1">##################################################</span>
<div class="viewcode-block" id="inside_poly"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.inside_poly">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">inside_poly</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">verts</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    *points* is a sequence of *x*, *y* points.</span>
<span class="sd">    *verts* is a sequence of *x*, *y* vertices of a polygon.</span>

<span class="sd">    Return value is a sequence of indices into points for the points</span>
<span class="sd">    that are inside the polygon.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Make a closed polygon path</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span>

    <span class="c1"># Check to see which points are contained within the Path</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="k">if</span> <span class="n">poly</span><span class="o">.</span><span class="n">contains_point</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span></div>


<div class="viewcode-block" id="poly_below"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.poly_below">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">poly_below</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a sequence of *xs* and *ys*, return the vertices of a</span>
<span class="sd">    polygon that has a horizontal base at *xmin* and an upper bound at</span>
<span class="sd">    the *ys*.  *xmin* is a scalar.</span>

<span class="sd">    Intended for use with :meth:`matplotlib.axes.Axes.fill`, e.g.,::</span>

<span class="sd">      xv, yv = poly_below(0, x, y)</span>
<span class="sd">      ax.fill(xv, yv)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">)</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="p">[</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">]):</span>
        <span class="n">numpy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">numpy</span> <span class="o">=</span> <span class="n">np</span>

    <span class="n">xs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
    <span class="n">ys</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
    <span class="n">Ny</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">Nx</span> <span class="o">!=</span> <span class="n">Ny</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;xs&#39; and &#39;ys&#39; must have the same length&quot;</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">xmin</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Nx</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Nx</span><span class="p">)</span>
    <span class="n">x</span><span class="p">[:</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="n">xs</span>
    <span class="n">y</span><span class="p">[:</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="n">ys</span>
    <span class="n">y</span><span class="p">[</span><span class="n">Nx</span><span class="p">:]</span> <span class="o">=</span> <span class="n">ys</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span></div>


<div class="viewcode-block" id="poly_between"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.poly_between">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">poly_between</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ylower</span><span class="p">,</span> <span class="n">yupper</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a sequence of *x*, *ylower* and *yupper*, return the polygon</span>
<span class="sd">    that fills the regions between them.  *ylower* or *yupper* can be</span>
<span class="sd">    scalar or iterable.  If they are iterable, they must be equal in</span>
<span class="sd">    length to *x*.</span>

<span class="sd">    Return value is *x*, *y* arrays for use with</span>
<span class="sd">    :meth:`matplotlib.axes.Axes.fill`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">)</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ylower</span><span class="p">,</span> <span class="n">yupper</span><span class="p">,</span> <span class="n">x</span><span class="p">]):</span>
        <span class="n">numpy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">numpy</span> <span class="o">=</span> <span class="n">np</span>

    <span class="n">Nx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cbook</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">ylower</span><span class="p">):</span>
        <span class="n">ylower</span> <span class="o">=</span> <span class="n">ylower</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">Nx</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">cbook</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">yupper</span><span class="p">):</span>
        <span class="n">yupper</span> <span class="o">=</span> <span class="n">yupper</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">Nx</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">yupper</span><span class="p">,</span> <span class="n">ylower</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span></div>


<div class="viewcode-block" id="is_closed_polygon"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.is_closed_polygon">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s1">&#39;2.2&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">is_closed_polygon</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tests whether first and last object in a sequence are the same.  These are</span>
<span class="sd">    presumably coordinates on a polygonal curve, in which case this function</span>
<span class="sd">    tests if that curve is closed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">X</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>


<div class="viewcode-block" id="contiguous_regions"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.contiguous_regions">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s1">&#39;Moved to matplotlib.cbook&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">contiguous_regions</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return a list of (ind0, ind1) such that mask[ind0:ind1].all() is</span>
<span class="sd">    True and we cover all such regions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">cbook</span><span class="o">.</span><span class="n">contiguous_regions</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span></div>


<div class="viewcode-block" id="cross_from_below"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.cross_from_below">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">cross_from_below</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return the indices into *x* where *x* crosses some threshold from</span>
<span class="sd">    below, e.g., the i&#39;s where::</span>

<span class="sd">      x[i-1]&lt;threshold and x[i]&gt;=threshold</span>

<span class="sd">    Example code::</span>

<span class="sd">        import matplotlib.pyplot as plt</span>

<span class="sd">        t = np.arange(0.0, 2.0, 0.1)</span>
<span class="sd">        s = np.sin(2*np.pi*t)</span>

<span class="sd">        fig = plt.figure()</span>
<span class="sd">        ax = fig.add_subplot(111)</span>
<span class="sd">        ax.plot(t, s, &#39;-o&#39;)</span>
<span class="sd">        ax.axhline(0.5)</span>
<span class="sd">        ax.axhline(-0.5)</span>

<span class="sd">        ind = cross_from_below(s, 0.5)</span>
<span class="sd">        ax.vlines(t[ind], -1, 1)</span>

<span class="sd">        ind = cross_from_above(s, -0.5)</span>
<span class="sd">        ax.vlines(t[ind], -1, 1)</span>

<span class="sd">        plt.show()</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`cross_from_above` and :func:`contiguous_regions`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">((</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ind</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ind</span></div>


<div class="viewcode-block" id="cross_from_above"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.cross_from_above">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">cross_from_above</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return the indices into *x* where *x* crosses some threshold from</span>
<span class="sd">    below, e.g., the i&#39;s where::</span>

<span class="sd">      x[i-1]&gt;threshold and x[i]&lt;=threshold</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`cross_from_below` and :func:`contiguous_regions`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">((</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ind</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ind</span></div>


<span class="c1">##################################################</span>
<span class="c1"># Vector and path length geometry calculations</span>
<span class="c1">##################################################</span>
<div class="viewcode-block" id="vector_lengths"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.vector_lengths">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s1">&#39;2.2&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">vector_lengths</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">P</span><span class="o">=</span><span class="mf">2.</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the length of a set of vectors in *n* dimensions.  This is</span>
<span class="sd">    like the :func:`numpy.norm` function for vectors, but has the ability to</span>
<span class="sd">    work over a particular axis of the supplied array or matrix.</span>

<span class="sd">    Computes ``(sum((x_i)^P))^(1/P)`` for each ``{x_i}`` being the</span>
<span class="sd">    elements of *X* along the given axis.  If *axis* is *None*,</span>
<span class="sd">    compute over all elements of *X*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">X</span><span class="o">**</span><span class="p">(</span><span class="n">P</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">P</span><span class="p">)</span></div>


<div class="viewcode-block" id="distances_along_curve"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.distances_along_curve">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s1">&#39;2.2&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">distances_along_curve</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the distance between a set of successive points in *N* dimensions.</span>

<span class="sd">    Where *X* is an *M* x *N* array or matrix.  The distances between</span>
<span class="sd">    successive rows is computed.  Distance is the standard Euclidean</span>
<span class="sd">    distance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">vector_lengths</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="path_length"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.path_length">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s1">&#39;2.2&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">path_length</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the distance travelled along a polygonal curve in *N* dimensions.</span>

<span class="sd">    Where *X* is an *M* x *N* array or matrix.  Returns an array of</span>
<span class="sd">    length *M* consisting of the distance along the curve at each point</span>
<span class="sd">    (i.e., the rows of *X*).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">distances_along_curve</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">X</span><span class="p">)))</span></div>


<div class="viewcode-block" id="quad2cubic"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.quad2cubic">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s1">&#39;2.2&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">quad2cubic</span><span class="p">(</span><span class="n">q0x</span><span class="p">,</span> <span class="n">q0y</span><span class="p">,</span> <span class="n">q1x</span><span class="p">,</span> <span class="n">q1y</span><span class="p">,</span> <span class="n">q2x</span><span class="p">,</span> <span class="n">q2y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a quadratic Bezier curve to a cubic approximation.</span>

<span class="sd">    The inputs are the *x* and *y* coordinates of the three control</span>
<span class="sd">    points of a quadratic curve, and the output is a tuple of *x* and</span>
<span class="sd">    *y* coordinates of the four control points of the cubic curve.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: Candidate for deprecation -- no longer used internally</span>

    <span class="c1"># c0x, c0y = q0x, q0y</span>
    <span class="n">c1x</span><span class="p">,</span> <span class="n">c1y</span> <span class="o">=</span> <span class="n">q0x</span> <span class="o">+</span> <span class="mf">2.</span><span class="o">/</span><span class="mf">3.</span> <span class="o">*</span> <span class="p">(</span><span class="n">q1x</span> <span class="o">-</span> <span class="n">q0x</span><span class="p">),</span> <span class="n">q0y</span> <span class="o">+</span> <span class="mf">2.</span><span class="o">/</span><span class="mf">3.</span> <span class="o">*</span> <span class="p">(</span><span class="n">q1y</span> <span class="o">-</span> <span class="n">q0y</span><span class="p">)</span>
    <span class="n">c2x</span><span class="p">,</span> <span class="n">c2y</span> <span class="o">=</span> <span class="n">c1x</span> <span class="o">+</span> <span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span> <span class="o">*</span> <span class="p">(</span><span class="n">q2x</span> <span class="o">-</span> <span class="n">q0x</span><span class="p">),</span> <span class="n">c1y</span> <span class="o">+</span> <span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span> <span class="o">*</span> <span class="p">(</span><span class="n">q2y</span> <span class="o">-</span> <span class="n">q0y</span><span class="p">)</span>
    <span class="c1"># c3x, c3y = q2x, q2y</span>
    <span class="k">return</span> <span class="n">q0x</span><span class="p">,</span> <span class="n">q0y</span><span class="p">,</span> <span class="n">c1x</span><span class="p">,</span> <span class="n">c1y</span><span class="p">,</span> <span class="n">c2x</span><span class="p">,</span> <span class="n">c2y</span><span class="p">,</span> <span class="n">q2x</span><span class="p">,</span> <span class="n">q2y</span></div>


<div class="viewcode-block" id="offset_line"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.offset_line">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;2.2&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">offset_line</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">yerr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Offsets an array *y* by +/- an error and returns a tuple</span>
<span class="sd">    (y - err, y + err).</span>

<span class="sd">    The error term can be:</span>

<span class="sd">    * A scalar. In this case, the returned tuple is obvious.</span>
<span class="sd">    * A vector of the same length as *y*. The quantities y +/- err are computed</span>
<span class="sd">      component-wise.</span>
<span class="sd">    * A tuple of length 2. In this case, yerr[0] is the error below *y* and</span>
<span class="sd">      yerr[1] is error above *y*. For example::</span>

<span class="sd">        from pylab import *</span>
<span class="sd">        x = linspace(0, 2*pi, num=100, endpoint=True)</span>
<span class="sd">        y = sin(x)</span>
<span class="sd">        y_minus, y_plus = mlab.offset_line(y, 0.1)</span>
<span class="sd">        plot(x, y)</span>
<span class="sd">        fill_between(x, ym, y2=yp)</span>
<span class="sd">        show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cbook</span><span class="o">.</span><span class="n">is_numlike</span><span class="p">(</span><span class="n">yerr</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">cbook</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">yerr</span><span class="p">)</span> <span class="ow">and</span>
                                  <span class="nb">len</span><span class="p">(</span><span class="n">yerr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)):</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">yerr</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">yerr</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">yerr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">yerr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span> <span class="o">+</span> <span class="n">yerr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;yerr must be scalar, 1xN or 2xN&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span></div>
</pre></div>

          </div>
        </div>
      </div>

      <div class="clearer"></div>
    </div>
    <div class="footer">
        &copy; Copyright 2002 - 2012 John Hunter, Darren Dale, Eric Firing, Michael Droettboom and the Matplotlib development team; 2012 - 2018 The Matplotlib development team.
        <br />
      Last updated on Jun 28, 2018.
	Created using
	<ahref="http://sphinx-doc.org/">Sphinx</a> 1.7.5.
	Doc version v2.2.2-101-g15e1eadd0.
    </div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-55954603-1', 'auto');
  ga('send', 'pageview');

</script>
</body>
<footer>
  <!--Flipcause Integration v3.0// Flipcause Integration Instructions:
Install the following code block once in the website Header (after <head> tag) -->

<style>

.fc-black_overlay{
display:none; position: fixed; z-index:1000001; top: 0%;left: 0%;width: 100%;height: 100%;
background-color: black; filter: alpha(opacity=50); cursor:pointer; opacity:0.5;
}

.fc-white_content {
opacity:1; display:none; margin-top: -320px; margin-left: -485px; width:970px; height:640px;
position:fixed; top:50%; left:50%; border: none;z-index:1000002;overflow: auto;
}

.fc-main-box{
opacity:1; display:none; margin:15px auto 0 auto; width:930px; position:relative; z-index:1000003;
}

.fc-widget_close{
opacity:1; content:url(http://i1338.photobucket.com/albums/o691/WeCause/X_zpse4a7e538.png);
position:absolute; z-index=1000004; right:-16px; top:-16px; display:block; cursor:pointer;
}

.floating_button{
display: block; margin-top: 0px; margin-left: 0px; width:auto ; height: auto;
position:fixed; z-index:999999; overflow: auto;
}

@keyframes backfadesin {
   from { opacity:0; }
   to {opacity:.5;}
}

@-moz-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}

@-webkit-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}

@-o-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}


@-ms-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}

@keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; transform: translateY(20px);}
   100% {opacity: 1; transform: translateY(0);}
}

@-moz-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -moz-transform: translateY(20px);}
   100% {opacity: 1; -moz-transform: translateY(0);}
}

@-webkit-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -webkit-transform: translateY(20px);}
   100% {opacity: 1; -webkit-transform: translateY(0);}
}

@-o-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -o-transform: translateY(20px);}
   100% {opacity: 1; -o-transform: translateY(0);}
}

@-ms-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -ms-transform: translateY(20px);}
   100% {opacity: 1; -ms-transform: translateY(0);}
}

</style>

<div id="fc-fade" class="fc-black_overlay" onclick="close_window()"></div>
<div id="fc-light" class="fc-white_content">
<div id="fc-main" class="fc-main-box">
<div id="fc-close" class="fc-widget_close" onclick="close_window()">
</div><iframe id="fc-myFrame" iframe height="580" width="925" style="border: 0;
border-radius:5px 5px 5px 5px; box-shadow:0 0 8px rgba(0, 0, 0, 0.5);" scrolling="no" src=""></iframe></div>
</div>

<!--END Flipcause Main Integration Code-->
</footer>
</html>