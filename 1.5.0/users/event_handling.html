<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Event handling and picking &mdash; Matplotlib 1.5.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/mpl.css"
type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css"
type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.5.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Matplotlib 1.5.0 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="top" title="Matplotlib 1.5.0 documentation" href="../index.html" />
    <link rel="up" title="Advanced Guide" href="developer.html" />
    <link rel="next" title="Transformations Tutorial" href="transforms_tutorial.html" />
    <link rel="prev" title="Tight Layout guide" href="tight_layout_guide.html" /> 
<link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">

    <link rel="canonical" href="https://matplotlib.org/stable/users/event_handling.html" />
    <script data-domain="matplotlib.org" defer="defer" src="https://views.scientific-python.org/js/script.js"></script>
  </head>
  <body>
<div id="unreleased-message"> You are reading an old version of the documentation (v1.5.0).  For the latest version see <a href="https://matplotlib.org/stable/users/event_handling.html">https://matplotlib.org/stable/users/event_handling.html</a></div>
    <div class="alert" style="background-color: #FEA46C; padding: 10px 0;
">
<h3>We're updating the default styles for Matplotlib 2.0</h3>

<p>Learn what to expect in the <a href="/style_changes.html" style="font-weight: bold;
color: #11557C;">new updates</a></p>

</div>



<link rel="shortcut icon" href="/_static/favicon.ico">

<!-- The "Fork me on github" ribbon -->
<img style="float: right; margin-bottom: -40px; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png" usemap="#ribbonmap"/>
<map name="ribbonmap">
    <area shape="poly" coords="15,0,148,-1,148,135" href="https://github.com/matplotlib/matplotlib" title="Fork me on GitHub" />
</map>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../index.html"><img src="../_static/logo2.png" border="0" alt="matplotlib"/></a>
</div>




    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="transforms_tutorial.html" title="Transformations Tutorial"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tight_layout_guide.html" title="Tight Layout guide"
             accesskey="P">previous</a> |</li>

        <li><a href="../index.html">home</a>|&nbsp;</li>
        <li><a href="../examples/index.html">examples</a>|&nbsp;</li>
        <li><a href="../gallery.html">gallery</a>|&nbsp;</li>
        <li><a href="../api/pyplot_summary.html">pyplot</a>|&nbsp;</li>
        <li><a href="../contents.html">docs</a> &raquo;</li>
          <li><a href="index.html" >User&#8217;s Guide</a> &raquo;</li>
          <li><a href="developer.html" accesskey="U">Advanced Guide</a> &raquo;</li> 
      </ul>
    </div>

  
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Event handling and picking</a><ul>
<li><a class="reference internal" href="#event-connections">Event connections</a></li>
<li><a class="reference internal" href="#event-attributes">Event attributes</a><ul>
<li><a class="reference internal" href="#draggable-rectangle-exercise">Draggable rectangle exercise</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mouse-enter-and-leave">Mouse enter and leave</a></li>
<li><a class="reference internal" href="#object-picking">Object picking</a><ul>
<li><a class="reference internal" href="#simple-picking-example">Simple picking example</a></li>
<li><a class="reference internal" href="#picking-exercise">Picking exercise</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="tight_layout_guide.html"
                        title="previous chapter">Tight Layout guide</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="transforms_tutorial.html"
                        title="next chapter">Transformations Tutorial</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/users/event_handling.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="event-handling-and-picking">
<span id="event-handling-tutorial"></span><h1>Event handling and picking<a class="headerlink" href="#event-handling-and-picking" title="Permalink to this headline">¶</a></h1>
<p>matplotlib works with a number of user interface toolkits (wxpython,
tkinter, qt4, gtk, and macosx) and in order to support features like
interactive panning and zooming of figures, it is helpful to the
developers to have an API for interacting with the figure via key
presses and mouse movements that is &#8220;GUI neutral&#8221; so we don&#8217;t have to
repeat a lot of code across the different user interfaces.  Although
the event handling API is GUI neutral, it is based on the GTK model,
which was the first user interface matplotlib supported.  The events
that are triggered are also a bit richer vis-a-vis matplotlib than
standard GUI events, including information like which
<a class="reference internal" href="../api/axes_api.html#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code class="xref py py-class docutils literal"><span class="pre">matplotlib.axes.Axes</span></code></a> the event occurred in.  The events also
understand the matplotlib coordinate system, and report event
locations in both pixel and data coordinates.</p>
<div class="section" id="event-connections">
<span id="id1"></span><h2>Event connections<a class="headerlink" href="#event-connections" title="Permalink to this headline">¶</a></h2>
<p>To receive events, you need to write a callback function and then
connect your function to the event manager, which is part of the
<a class="reference internal" href="../api/backend_bases_api.html#matplotlib.backend_bases.FigureCanvasBase" title="matplotlib.backend_bases.FigureCanvasBase"><code class="xref py py-class docutils literal"><span class="pre">FigureCanvasBase</span></code></a>.  Here is a simple
example that prints the location of the mouse click and which button
was pressed:</p>
<div class="highlight-python"><div class="highlight"><pre>fig = plt.figure()
ax = fig.add_subplot(111)
ax.plot(np.random.rand(10))

def onclick(event):
    print &#39;button=%d, x=%d, y=%d, xdata=%f, ydata=%f&#39;%(
        event.button, event.x, event.y, event.xdata, event.ydata)

cid = fig.canvas.mpl_connect(&#39;button_press_event&#39;, onclick)
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">FigureCanvas</span></code> method
<a class="reference internal" href="../api/backend_bases_api.html#matplotlib.backend_bases.FigureCanvasBase.mpl_connect" title="matplotlib.backend_bases.FigureCanvasBase.mpl_connect"><code class="xref py py-meth docutils literal"><span class="pre">mpl_connect()</span></code></a> returns
a connection id which is simply an integer.  When you want to
disconnect the callback, just call:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_disconnect</span><span class="p">(</span><span class="n">cid</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The canvas retains only weak references to the callbacks.  Therefore
if a callback is a method of a class instance, you need to retain
a reference to that instance.  Otherwise the instance will be
garbage-collected and the callback will vanish.</p>
</div>
<p>Here are the events that you can connect to, the class instances that
are sent back to you when the event occurs, and the event descriptions</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Event name</th>
<th class="head">Class and description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&#8216;button_press_event&#8217;</td>
<td><a class="reference internal" href="../api/backend_bases_api.html#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><code class="xref py py-class docutils literal"><span class="pre">MouseEvent</span></code></a>     - mouse button is pressed</td>
</tr>
<tr class="row-odd"><td>&#8216;button_release_event&#8217;</td>
<td><a class="reference internal" href="../api/backend_bases_api.html#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><code class="xref py py-class docutils literal"><span class="pre">MouseEvent</span></code></a>     - mouse button is released</td>
</tr>
<tr class="row-even"><td>&#8216;draw_event&#8217;</td>
<td><a class="reference internal" href="../api/backend_bases_api.html#matplotlib.backend_bases.DrawEvent" title="matplotlib.backend_bases.DrawEvent"><code class="xref py py-class docutils literal"><span class="pre">DrawEvent</span></code></a>      - canvas draw</td>
</tr>
<tr class="row-odd"><td>&#8216;key_press_event&#8217;</td>
<td><a class="reference internal" href="../api/backend_bases_api.html#matplotlib.backend_bases.KeyEvent" title="matplotlib.backend_bases.KeyEvent"><code class="xref py py-class docutils literal"><span class="pre">KeyEvent</span></code></a>       - key is pressed</td>
</tr>
<tr class="row-even"><td>&#8216;key_release_event&#8217;</td>
<td><a class="reference internal" href="../api/backend_bases_api.html#matplotlib.backend_bases.KeyEvent" title="matplotlib.backend_bases.KeyEvent"><code class="xref py py-class docutils literal"><span class="pre">KeyEvent</span></code></a>       - key is released</td>
</tr>
<tr class="row-odd"><td>&#8216;motion_notify_event&#8217;</td>
<td><a class="reference internal" href="../api/backend_bases_api.html#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><code class="xref py py-class docutils literal"><span class="pre">MouseEvent</span></code></a>     - mouse motion</td>
</tr>
<tr class="row-even"><td>&#8216;pick_event&#8217;</td>
<td><a class="reference internal" href="../api/backend_bases_api.html#matplotlib.backend_bases.PickEvent" title="matplotlib.backend_bases.PickEvent"><code class="xref py py-class docutils literal"><span class="pre">PickEvent</span></code></a>      - an object in the canvas is selected</td>
</tr>
<tr class="row-odd"><td>&#8216;resize_event&#8217;</td>
<td><a class="reference internal" href="../api/backend_bases_api.html#matplotlib.backend_bases.ResizeEvent" title="matplotlib.backend_bases.ResizeEvent"><code class="xref py py-class docutils literal"><span class="pre">ResizeEvent</span></code></a>    - figure canvas is resized</td>
</tr>
<tr class="row-even"><td>&#8216;scroll_event&#8217;</td>
<td><a class="reference internal" href="../api/backend_bases_api.html#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><code class="xref py py-class docutils literal"><span class="pre">MouseEvent</span></code></a>     - mouse scroll wheel is rolled</td>
</tr>
<tr class="row-odd"><td>&#8216;figure_enter_event&#8217;</td>
<td><a class="reference internal" href="../api/backend_bases_api.html#matplotlib.backend_bases.LocationEvent" title="matplotlib.backend_bases.LocationEvent"><code class="xref py py-class docutils literal"><span class="pre">LocationEvent</span></code></a>  - mouse enters a new figure</td>
</tr>
<tr class="row-even"><td>&#8216;figure_leave_event&#8217;</td>
<td><a class="reference internal" href="../api/backend_bases_api.html#matplotlib.backend_bases.LocationEvent" title="matplotlib.backend_bases.LocationEvent"><code class="xref py py-class docutils literal"><span class="pre">LocationEvent</span></code></a>  - mouse leaves a figure</td>
</tr>
<tr class="row-odd"><td>&#8216;axes_enter_event&#8217;</td>
<td><a class="reference internal" href="../api/backend_bases_api.html#matplotlib.backend_bases.LocationEvent" title="matplotlib.backend_bases.LocationEvent"><code class="xref py py-class docutils literal"><span class="pre">LocationEvent</span></code></a>  - mouse enters a new axes</td>
</tr>
<tr class="row-even"><td>&#8216;axes_leave_event&#8217;</td>
<td><a class="reference internal" href="../api/backend_bases_api.html#matplotlib.backend_bases.LocationEvent" title="matplotlib.backend_bases.LocationEvent"><code class="xref py py-class docutils literal"><span class="pre">LocationEvent</span></code></a>  - mouse leaves an axes</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="event-attributes">
<span id="id2"></span><h2>Event attributes<a class="headerlink" href="#event-attributes" title="Permalink to this headline">¶</a></h2>
<p>All matplotlib events inherit from the base class
<a class="reference internal" href="../api/backend_bases_api.html#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><code class="xref py py-class docutils literal"><span class="pre">matplotlib.backend_bases.Event</span></code></a>, which store the attributes:</p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal"><span class="pre">name</span></code></dt>
<dd>the event name</dd>
<dt><code class="docutils literal"><span class="pre">canvas</span></code></dt>
<dd>the FigureCanvas instance generating the event</dd>
<dt><code class="docutils literal"><span class="pre">guiEvent</span></code></dt>
<dd>the GUI event that triggered the matplotlib event</dd>
</dl>
</div></blockquote>
<p>The most common events that are the bread and butter of event handling
are key press/release events and mouse press/release and movement
events.  The <a class="reference internal" href="../api/backend_bases_api.html#matplotlib.backend_bases.KeyEvent" title="matplotlib.backend_bases.KeyEvent"><code class="xref py py-class docutils literal"><span class="pre">KeyEvent</span></code></a> and
<a class="reference internal" href="../api/backend_bases_api.html#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><code class="xref py py-class docutils literal"><span class="pre">MouseEvent</span></code></a> classes that handle
these events are both derived from the LocationEvent, which has the
following attributes</p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal"><span class="pre">x</span></code></dt>
<dd>x position - pixels from left of canvas</dd>
<dt><code class="docutils literal"><span class="pre">y</span></code></dt>
<dd>y position - pixels from bottom of canvas</dd>
<dt><code class="docutils literal"><span class="pre">inaxes</span></code></dt>
<dd>the <a class="reference internal" href="../api/axes_api.html#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code class="xref py py-class docutils literal"><span class="pre">Axes</span></code></a> instance if mouse is over axes</dd>
<dt><code class="docutils literal"><span class="pre">xdata</span></code></dt>
<dd>x coord of mouse in data coords</dd>
<dt><code class="docutils literal"><span class="pre">ydata</span></code></dt>
<dd>y coord of mouse in data coords</dd>
</dl>
</div></blockquote>
<p>Let&#8217;s look a simple example of a canvas, where a simple line segment
is created every time a mouse is pressed:</p>
<div class="highlight-python"><div class="highlight"><pre>from matplotlib import pyplot as plt

class LineBuilder:
    def __init__(self, line):
        self.line = line
        self.xs = list(line.get_xdata())
        self.ys = list(line.get_ydata())
        self.cid = line.figure.canvas.mpl_connect(&#39;button_press_event&#39;, self)

    def __call__(self, event):
        print &#39;click&#39;, event
        if event.inaxes!=self.line.axes: return
        self.xs.append(event.xdata)
        self.ys.append(event.ydata)
        self.line.set_data(self.xs, self.ys)
        self.line.figure.canvas.draw()

fig = plt.figure()
ax = fig.add_subplot(111)
ax.set_title(&#39;click to build line segments&#39;)
line, = ax.plot([0], [0])  # empty line
linebuilder = LineBuilder(line)

plt.show()
</pre></div>
</div>
<p>The <a class="reference internal" href="../api/backend_bases_api.html#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><code class="xref py py-class docutils literal"><span class="pre">MouseEvent</span></code></a> that we just used is a
<a class="reference internal" href="../api/backend_bases_api.html#matplotlib.backend_bases.LocationEvent" title="matplotlib.backend_bases.LocationEvent"><code class="xref py py-class docutils literal"><span class="pre">LocationEvent</span></code></a>, so we have access to
the data and pixel coordinates in event.x and event.xdata.  In
addition to the <code class="docutils literal"><span class="pre">LocationEvent</span></code> attributes, it has</p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal"><span class="pre">button</span></code></dt>
<dd>button pressed None, 1, 2, 3, &#8216;up&#8217;, &#8216;down&#8217; (up and down are used for scroll events)</dd>
<dt><code class="docutils literal"><span class="pre">key</span></code></dt>
<dd>the key pressed: None, any character, &#8216;shift&#8217;, &#8216;win&#8217;, or &#8216;control&#8217;</dd>
</dl>
</div></blockquote>
<div class="section" id="draggable-rectangle-exercise">
<h3>Draggable rectangle exercise<a class="headerlink" href="#draggable-rectangle-exercise" title="Permalink to this headline">¶</a></h3>
<p>Write draggable rectangle class that is initialized with a
<a class="reference internal" href="../api/patches_api.html#matplotlib.patches.Rectangle" title="matplotlib.patches.Rectangle"><code class="xref py py-class docutils literal"><span class="pre">Rectangle</span></code></a> instance but will move its x,y
location when dragged.  Hint: you will need to store the original
<code class="docutils literal"><span class="pre">xy</span></code> location of the rectangle which is stored as rect.xy and
connect to the press, motion and release mouse events.  When the mouse
is pressed, check to see if the click occurs over your rectangle (see
<a class="reference internal" href="../api/patches_api.html#matplotlib.patches.Rectangle.contains" title="matplotlib.patches.Rectangle.contains"><code class="xref py py-meth docutils literal"><span class="pre">matplotlib.patches.Rectangle.contains()</span></code></a>) and if it does, store
the rectangle xy and the location of the mouse click in data coords.
In the motion event callback, compute the deltax and deltay of the
mouse movement, and add those deltas to the origin of the rectangle
you stored.  The redraw the figure.  On the button release event, just
reset all the button press data you stored as None.</p>
<p>Here is the solution:</p>
<div class="highlight-python"><div class="highlight"><pre>import numpy as np
import matplotlib.pyplot as plt

class DraggableRectangle:
    def __init__(self, rect):
        self.rect = rect
        self.press = None

    def connect(self):
        &#39;connect to all the events we need&#39;
        self.cidpress = self.rect.figure.canvas.mpl_connect(
            &#39;button_press_event&#39;, self.on_press)
        self.cidrelease = self.rect.figure.canvas.mpl_connect(
            &#39;button_release_event&#39;, self.on_release)
        self.cidmotion = self.rect.figure.canvas.mpl_connect(
            &#39;motion_notify_event&#39;, self.on_motion)

    def on_press(self, event):
        &#39;on button press we will see if the mouse is over us and store some data&#39;
        if event.inaxes != self.rect.axes: return

        contains, attrd = self.rect.contains(event)
        if not contains: return
        print &#39;event contains&#39;, self.rect.xy
        x0, y0 = self.rect.xy
        self.press = x0, y0, event.xdata, event.ydata

    def on_motion(self, event):
        &#39;on motion we will move the rect if the mouse is over us&#39;
        if self.press is None: return
        if event.inaxes != self.rect.axes: return
        x0, y0, xpress, ypress = self.press
        dx = event.xdata - xpress
        dy = event.ydata - ypress
        #print &#39;x0=%f, xpress=%f, event.xdata=%f, dx=%f, x0+dx=%f&#39;%(x0, xpress, event.xdata, dx, x0+dx)
        self.rect.set_x(x0+dx)
        self.rect.set_y(y0+dy)

        self.rect.figure.canvas.draw()


    def on_release(self, event):
        &#39;on release we reset the press data&#39;
        self.press = None
        self.rect.figure.canvas.draw()

    def disconnect(self):
        &#39;disconnect all the stored connection ids&#39;
        self.rect.figure.canvas.mpl_disconnect(self.cidpress)
        self.rect.figure.canvas.mpl_disconnect(self.cidrelease)
        self.rect.figure.canvas.mpl_disconnect(self.cidmotion)

fig = plt.figure()
ax = fig.add_subplot(111)
rects = ax.bar(range(10), 20*np.random.rand(10))
drs = []
for rect in rects:
    dr = DraggableRectangle(rect)
    dr.connect()
    drs.append(dr)

plt.show()
</pre></div>
</div>
<p><strong>Extra credit</strong>: use the animation blit techniques discussed in the
<a class="reference external" href="http://www.scipy.org/Cookbook/Matplotlib/Animations">animations recipe</a> to make the
animated drawing faster and smoother.</p>
<p>Extra credit solution:</p>
<div class="highlight-python"><div class="highlight"><pre># draggable rectangle with the animation blit techniques; see
# http://www.scipy.org/Cookbook/Matplotlib/Animations
import numpy as np
import matplotlib.pyplot as plt

class DraggableRectangle:
    lock = None  # only one can be animated at a time
    def __init__(self, rect):
        self.rect = rect
        self.press = None
        self.background = None

    def connect(self):
        &#39;connect to all the events we need&#39;
        self.cidpress = self.rect.figure.canvas.mpl_connect(
            &#39;button_press_event&#39;, self.on_press)
        self.cidrelease = self.rect.figure.canvas.mpl_connect(
            &#39;button_release_event&#39;, self.on_release)
        self.cidmotion = self.rect.figure.canvas.mpl_connect(
            &#39;motion_notify_event&#39;, self.on_motion)

    def on_press(self, event):
        &#39;on button press we will see if the mouse is over us and store some data&#39;
        if event.inaxes != self.rect.axes: return
        if DraggableRectangle.lock is not None: return
        contains, attrd = self.rect.contains(event)
        if not contains: return
        print &#39;event contains&#39;, self.rect.xy
        x0, y0 = self.rect.xy
        self.press = x0, y0, event.xdata, event.ydata
        DraggableRectangle.lock = self

        # draw everything but the selected rectangle and store the pixel buffer
        canvas = self.rect.figure.canvas
        axes = self.rect.axes
        self.rect.set_animated(True)
        canvas.draw()
        self.background = canvas.copy_from_bbox(self.rect.axes.bbox)

        # now redraw just the rectangle
        axes.draw_artist(self.rect)

        # and blit just the redrawn area
        canvas.blit(axes.bbox)

    def on_motion(self, event):
        &#39;on motion we will move the rect if the mouse is over us&#39;
        if DraggableRectangle.lock is not self:
            return
        if event.inaxes != self.rect.axes: return
        x0, y0, xpress, ypress = self.press
        dx = event.xdata - xpress
        dy = event.ydata - ypress
        self.rect.set_x(x0+dx)
        self.rect.set_y(y0+dy)

        canvas = self.rect.figure.canvas
        axes = self.rect.axes
        # restore the background region
        canvas.restore_region(self.background)

        # redraw just the current rectangle
        axes.draw_artist(self.rect)

        # blit just the redrawn area
        canvas.blit(axes.bbox)

    def on_release(self, event):
        &#39;on release we reset the press data&#39;
        if DraggableRectangle.lock is not self:
            return

        self.press = None
        DraggableRectangle.lock = None

        # turn off the rect animation property and reset the background
        self.rect.set_animated(False)
        self.background = None

        # redraw the full figure
        self.rect.figure.canvas.draw()

    def disconnect(self):
        &#39;disconnect all the stored connection ids&#39;
        self.rect.figure.canvas.mpl_disconnect(self.cidpress)
        self.rect.figure.canvas.mpl_disconnect(self.cidrelease)
        self.rect.figure.canvas.mpl_disconnect(self.cidmotion)

fig = plt.figure()
ax = fig.add_subplot(111)
rects = ax.bar(range(10), 20*np.random.rand(10))
drs = []
for rect in rects:
    dr = DraggableRectangle(rect)
    dr.connect()
    drs.append(dr)

plt.show()
</pre></div>
</div>
</div>
</div>
<div class="section" id="mouse-enter-and-leave">
<span id="enter-leave-events"></span><h2>Mouse enter and leave<a class="headerlink" href="#mouse-enter-and-leave" title="Permalink to this headline">¶</a></h2>
<p>If you want to be notified when the mouse enters or leaves a figure or
axes, you can connect to the figure/axes enter/leave events.  Here is
a simple example that changes the colors of the axes and figure
background that the mouse is over:</p>
<div class="highlight-python"><div class="highlight"><pre>&quot;&quot;&quot;
Illustrate the figure and axes enter and leave events by changing the
frame colors on enter and leave
&quot;&quot;&quot;
import matplotlib.pyplot as plt

def enter_axes(event):
    print &#39;enter_axes&#39;, event.inaxes
    event.inaxes.patch.set_facecolor(&#39;yellow&#39;)
    event.canvas.draw()

def leave_axes(event):
    print &#39;leave_axes&#39;, event.inaxes
    event.inaxes.patch.set_facecolor(&#39;white&#39;)
    event.canvas.draw()

def enter_figure(event):
    print &#39;enter_figure&#39;, event.canvas.figure
    event.canvas.figure.patch.set_facecolor(&#39;red&#39;)
    event.canvas.draw()

def leave_figure(event):
    print &#39;leave_figure&#39;, event.canvas.figure
    event.canvas.figure.patch.set_facecolor(&#39;grey&#39;)
    event.canvas.draw()

fig1 = plt.figure()
fig1.suptitle(&#39;mouse hover over figure or axes to trigger events&#39;)
ax1 = fig1.add_subplot(211)
ax2 = fig1.add_subplot(212)

fig1.canvas.mpl_connect(&#39;figure_enter_event&#39;, enter_figure)
fig1.canvas.mpl_connect(&#39;figure_leave_event&#39;, leave_figure)
fig1.canvas.mpl_connect(&#39;axes_enter_event&#39;, enter_axes)
fig1.canvas.mpl_connect(&#39;axes_leave_event&#39;, leave_axes)

fig2 = plt.figure()
fig2.suptitle(&#39;mouse hover over figure or axes to trigger events&#39;)
ax1 = fig2.add_subplot(211)
ax2 = fig2.add_subplot(212)

fig2.canvas.mpl_connect(&#39;figure_enter_event&#39;, enter_figure)
fig2.canvas.mpl_connect(&#39;figure_leave_event&#39;, leave_figure)
fig2.canvas.mpl_connect(&#39;axes_enter_event&#39;, enter_axes)
fig2.canvas.mpl_connect(&#39;axes_leave_event&#39;, leave_axes)

plt.show()
</pre></div>
</div>
</div>
<div class="section" id="object-picking">
<span id="id3"></span><h2>Object picking<a class="headerlink" href="#object-picking" title="Permalink to this headline">¶</a></h2>
<p>You can enable picking by setting the <code class="docutils literal"><span class="pre">picker</span></code> property of an
<a class="reference internal" href="../api/artist_api.html#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code class="xref py py-class docutils literal"><span class="pre">Artist</span></code></a> (e.g., a matplotlib
<a class="reference internal" href="../api/lines_api.html#matplotlib.lines.Line2D" title="matplotlib.lines.Line2D"><code class="xref py py-class docutils literal"><span class="pre">Line2D</span></code></a>, <a class="reference internal" href="../api/text_api.html#matplotlib.text.Text" title="matplotlib.text.Text"><code class="xref py py-class docutils literal"><span class="pre">Text</span></code></a>,
<a class="reference internal" href="../api/patches_api.html#matplotlib.patches.Patch" title="matplotlib.patches.Patch"><code class="xref py py-class docutils literal"><span class="pre">Patch</span></code></a>, <a class="reference internal" href="../api/patches_api.html#matplotlib.patches.Polygon" title="matplotlib.patches.Polygon"><code class="xref py py-class docutils literal"><span class="pre">Polygon</span></code></a>,
<code class="xref py py-class docutils literal"><span class="pre">AxesImage</span></code>, etc...)</p>
<p>There are a variety of meanings of the <code class="docutils literal"><span class="pre">picker</span></code> property:</p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal"><span class="pre">None</span></code></dt>
<dd>picking is disabled for this artist (default)</dd>
<dt><code class="docutils literal"><span class="pre">boolean</span></code></dt>
<dd>if True then picking will be enabled and the artist will fire a
pick event if the mouse event is over the artist</dd>
<dt><code class="docutils literal"><span class="pre">float</span></code></dt>
<dd>if picker is a number it is interpreted as an epsilon tolerance in
points and the artist will fire off an event if its data is
within epsilon of the mouse event.  For some artists like lines
and patch collections, the artist may provide additional data to
the pick event that is generated, e.g., the indices of the data
within epsilon of the pick event.</dd>
<dt><code class="docutils literal"><span class="pre">function</span></code></dt>
<dd>if picker is callable, it is a user supplied function which
determines whether the artist is hit by the mouse event.  The
signature is <code class="docutils literal"><span class="pre">hit,</span> <span class="pre">props</span> <span class="pre">=</span> <span class="pre">picker(artist,</span> <span class="pre">mouseevent)</span></code> to
determine the hit test.  If the mouse event is over the artist,
return <code class="docutils literal"><span class="pre">hit=True</span></code> and props is a dictionary of properties you
want added to the <a class="reference internal" href="../api/backend_bases_api.html#matplotlib.backend_bases.PickEvent" title="matplotlib.backend_bases.PickEvent"><code class="xref py py-class docutils literal"><span class="pre">PickEvent</span></code></a>
attributes</dd>
</dl>
</div></blockquote>
<p>After you have enabled an artist for picking by setting the <code class="docutils literal"><span class="pre">picker</span></code>
property, you need to connect to the figure canvas pick_event to get
pick callbacks on mouse press events.  e.g.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">pick_handler</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="n">mouseevent</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">mouseevent</span>
    <span class="n">artist</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">artist</span>
    <span class="c"># now do something with this...</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../api/backend_bases_api.html#matplotlib.backend_bases.PickEvent" title="matplotlib.backend_bases.PickEvent"><code class="xref py py-class docutils literal"><span class="pre">PickEvent</span></code></a> which is passed to
your callback is always fired with two attributes:</p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal"><span class="pre">mouseevent</span></code> the mouse event that generate the pick event.  The</dt>
<dd>mouse event in turn has attributes like <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> (the
coords in display space, e.g., pixels from left, bottom) and xdata,
ydata (the coords in data space).  Additionally, you can get
information about which buttons were pressed, which keys were
pressed, which <a class="reference internal" href="../api/axes_api.html#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><code class="xref py py-class docutils literal"><span class="pre">Axes</span></code></a> the mouse is over,
etc.  See <a class="reference internal" href="../api/backend_bases_api.html#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><code class="xref py py-class docutils literal"><span class="pre">matplotlib.backend_bases.MouseEvent</span></code></a> for
details.</dd>
<dt><code class="docutils literal"><span class="pre">artist</span></code></dt>
<dd>the <a class="reference internal" href="../api/artist_api.html#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><code class="xref py py-class docutils literal"><span class="pre">Artist</span></code></a> that generated the pick
event.</dd>
</dl>
</div></blockquote>
<p>Additionally, certain artists like <a class="reference internal" href="../api/lines_api.html#matplotlib.lines.Line2D" title="matplotlib.lines.Line2D"><code class="xref py py-class docutils literal"><span class="pre">Line2D</span></code></a>
and <a class="reference internal" href="../api/collections_api.html#matplotlib.collections.PatchCollection" title="matplotlib.collections.PatchCollection"><code class="xref py py-class docutils literal"><span class="pre">PatchCollection</span></code></a> may attach
additional meta data like the indices into the data that meet the
picker criteria (e.g., all the points in the line that are within the
specified epsilon tolerance)</p>
<div class="section" id="simple-picking-example">
<h3>Simple picking example<a class="headerlink" href="#simple-picking-example" title="Permalink to this headline">¶</a></h3>
<p>In the example below, we set the line picker property to a scalar, so
it represents a tolerance in points (72 points per inch).  The onpick
callback function will be called when the pick event it within the
tolerance distance from the line, and has the indices of the data
vertices that are within the pick distance tolerance.  Our onpick
callback function simply prints the data that are under the pick
location.  Different matplotlib Artists can attach different data to
the PickEvent.  For example, <code class="docutils literal"><span class="pre">Line2D</span></code> attaches the ind property,
which are the indices into the line data under the pick point.  See
<code class="xref py py-meth docutils literal"><span class="pre">pick()</span></code> for details on the <code class="docutils literal"><span class="pre">PickEvent</span></code>
properties of the line.  Here is the code:</p>
<div class="highlight-python"><div class="highlight"><pre>import numpy as np
import matplotlib.pyplot as plt

fig = plt.figure()
ax = fig.add_subplot(111)
ax.set_title(&#39;click on points&#39;)

line, = ax.plot(np.random.rand(100), &#39;o&#39;, picker=5)  # 5 points tolerance

def onpick(event):
    thisline = event.artist
    xdata = thisline.get_xdata()
    ydata = thisline.get_ydata()
    ind = event.ind
    print &#39;onpick points:&#39;, zip(xdata[ind], ydata[ind])

fig.canvas.mpl_connect(&#39;pick_event&#39;, onpick)

plt.show()
</pre></div>
</div>
</div>
<div class="section" id="picking-exercise">
<h3>Picking exercise<a class="headerlink" href="#picking-exercise" title="Permalink to this headline">¶</a></h3>
<p>Create a data set of 100 arrays of 1000 Gaussian random numbers and
compute the sample mean and standard deviation of each of them (hint:
numpy arrays have a mean and std method) and make a xy marker plot of
the 100 means vs the 100 standard deviations.  Connect the line
created by the plot command to the pick event, and plot the original
time series of the data that generated the clicked on points.  If more
than one point is within the tolerance of the clicked on point, you
can use multiple subplots to plot the multiple time series.</p>
<p>Exercise solution:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">compute the mean and stddev of 100 data sets and plot mean vs stddev.</span>
<span class="sd">When you click on one of the mu, sigma points, plot the raw data from</span>
<span class="sd">the dataset that generated the mean and stddev</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">&#39;click on point to plot time series&#39;</span><span class="p">)</span>
<span class="n">line</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="s">&#39;o&#39;</span><span class="p">,</span> <span class="n">picker</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>  <span class="c"># 5 points tolerance</span>


<span class="k">def</span> <span class="nf">onpick</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">event</span><span class="o">.</span><span class="n">artist</span><span class="o">!=</span><span class="n">line</span><span class="p">:</span> <span class="k">return</span> <span class="bp">True</span>

    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">ind</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">N</span><span class="p">:</span> <span class="k">return</span> <span class="bp">True</span>


    <span class="n">figi</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">subplotnum</span><span class="p">,</span> <span class="n">dataind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">ind</span><span class="p">):</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">figi</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">subplotnum</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">dataind</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="s">&#39;mu=</span><span class="si">%1.3f</span><span class="se">\n</span><span class="s">sigma=</span><span class="si">%1.3f</span><span class="s">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="n">dataind</span><span class="p">],</span> <span class="n">ys</span><span class="p">[</span><span class="n">dataind</span><span class="p">]),</span>
                <span class="n">transform</span><span class="o">=</span><span class="n">ax</span><span class="o">.</span><span class="n">transAxes</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s">&#39;top&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
    <span class="n">figi</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">return</span> <span class="bp">True</span>

<span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s">&#39;pick_event&#39;</span><span class="p">,</span> <span class="n">onpick</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>

      <div class="clearer"></div>
    </div>
    <div class="footer">
        &copy; Copyright 2002 - 2012 John Hunter, Darren Dale, Eric Firing, Michael Droettboom and the matplotlib development team; 2012 - 2014 The matplotlib development team.
      Last updated on Oct 29, 2015.
      Created using <a
href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>

</body>
</html>