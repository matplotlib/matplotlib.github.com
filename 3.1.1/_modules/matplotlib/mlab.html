<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>matplotlib.mlab &mdash; Matplotlib 3.1.2 documentation</title>
    
    <link rel="stylesheet" href="../../_static/mpl.css?v3.1.1-79-g90d53b526"
type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css"
type="text/css" />
    <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/gallery.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script type="text/javascript" src="../../_static/clipboard.min.js"></script>
        <script type="text/javascript" src="../../_static/copybutton.js"></script>
        <script type="text/javascript">var copybuttonSkipText = '>>> ';</script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Matplotlib 3.1.2 documentation"
          href="../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html"
/>
    <link rel="search" title="Search" href="../../search.html"
/>
    <link rel="top" title="Matplotlib 3.1.2 documentation" href="../../index.html" />
    <link rel="up" title="matplotlib" href="../matplotlib.html" />
    <link rel="canonical" href="https://matplotlib.org/3.4.3/_modules/matplotlib/mlab.html" />



  </head>
  <body>
<div id="unreleased-message"> You are reading an old version of the documentation (v3.1.1).  For the latest version see <a href="/stable/">https://matplotlib.org/stable/</a> </div>



<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px; position: relative;">
<a href="../../index.html">
    <div style="float: left; position: absolute; width: 496px; bottom: 0; padding-bottom: 24px"><span style="float: right; color: #789; background: white">Version 3.1.2</span></div>
    <img src="../../_static/logo2_compressed.svg" height="125px" border="0" alt="matplotlib"/></a>

<!-- The "Fork me on github" ribbon -->
<div id="forkongithub"><a href="https://github.com/matplotlib/matplotlib">Fork me on GitHub</a></div>
</div>


<nav class="main-nav">
  <ul>
    <li><a href="../../users/installing.html">Installation</a></li>
    <li><a href="../../contents.html">Documentation</a></li>
    <li><a href="../../gallery/index.html">Examples</a></li>
    <li><a href="../../tutorials/index.html">Tutorials</a></li>
    <li><a href="../../devel/index.html">Contributing</a></li>
  </ul>
</nav>




    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>

        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../contents.html">contents</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li>
          <li><a href="../matplotlib.html" accesskey="U">matplotlib</a> &raquo;</li> 
      </ul>
    </div>

  
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../contents.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  <li><a href="../matplotlib.html">matplotlib</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
        </div>
      </div>
    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for matplotlib.mlab</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Numerical python functions written for compatibility with MATLAB</span>
<span class="sd">commands with the same names. Most numerical python functions can be found in</span>
<span class="sd">the `numpy` and `scipy` libraries. What remains here is code for performing</span>
<span class="sd">spectral computations.</span>

<span class="sd">Spectral functions</span>
<span class="sd">-------------------</span>

<span class="sd">`cohere`</span>
<span class="sd">    Coherence (normalized cross spectral density)</span>

<span class="sd">`csd`</span>
<span class="sd">    Cross spectral density using Welch&#39;s average periodogram</span>

<span class="sd">`detrend`</span>
<span class="sd">    Remove the mean or best fit line from an array</span>

<span class="sd">`psd`</span>
<span class="sd">    Power spectral density using Welch&#39;s average periodogram</span>

<span class="sd">`specgram`</span>
<span class="sd">    Spectrogram (spectrum over segments of time)</span>

<span class="sd">`complex_spectrum`</span>
<span class="sd">    Return the complex-valued frequency spectrum of a signal</span>

<span class="sd">`magnitude_spectrum`</span>
<span class="sd">    Return the magnitude of the frequency spectrum of a signal</span>

<span class="sd">`angle_spectrum`</span>
<span class="sd">    Return the angle (wrapped phase) of the frequency spectrum of a signal</span>

<span class="sd">`phase_spectrum`</span>
<span class="sd">    Return the phase (unwrapped angle) of the frequency spectrum of a signal</span>

<span class="sd">`detrend_mean`</span>
<span class="sd">    Remove the mean from a line.</span>

<span class="sd">`detrend_linear`</span>
<span class="sd">    Remove the best fit line from a line.</span>

<span class="sd">`detrend_none`</span>
<span class="sd">    Return the original line.</span>

<span class="sd">`stride_windows`</span>
<span class="sd">    Get all windows in an array in a memory-efficient manner</span>

<span class="sd">`stride_repeat`</span>
<span class="sd">    Repeat an array in a memory-efficient manner</span>

<span class="sd">`apply_window`</span>
<span class="sd">    Apply a window along a given axis</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">import</span> <span class="nn">inspect</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">matplotlib.cbook</span> <span class="k">as</span> <span class="nn">cbook</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">docstring</span>


<div class="viewcode-block" id="window_hanning"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.window_hanning">[docs]</a><span class="k">def</span> <span class="nf">window_hanning</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return x times the hanning window of len(x).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    window_none : Another window algorithm.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">*</span><span class="n">x</span></div>


<div class="viewcode-block" id="window_none"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.window_none">[docs]</a><span class="k">def</span> <span class="nf">window_none</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    No window function; simply return x.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    window_hanning : Another window algorithm.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="apply_window"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.apply_window">[docs]</a><span class="k">def</span> <span class="nf">apply_window</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_window</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Apply the given window to the given 1D or 2D array along the given axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1D or 2D array or sequence</span>
<span class="sd">        Array or sequence containing the data.</span>

<span class="sd">    window : function or array.</span>
<span class="sd">        Either a function to generate a window or an array with length</span>
<span class="sd">        *x*.shape[*axis*]</span>

<span class="sd">    axis : integer</span>
<span class="sd">        The axis over which to do the repetition.</span>
<span class="sd">        Must be 0 or 1.  The default is 0</span>

<span class="sd">    return_window : bool</span>
<span class="sd">        If true, also return the 1D values of the window that was applied</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;only 1D or 2D arrays can be used&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;axis(=</span><span class="si">%s</span><span class="s1">) out of bounds&#39;</span> <span class="o">%</span> <span class="n">axis</span><span class="p">)</span>

    <span class="n">xshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">xshapetarg</span> <span class="o">=</span> <span class="n">xshape</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">window</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="o">!=</span> <span class="n">xshapetarg</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The len(window) must be the same as the shape &#39;</span>
                             <span class="s1">&#39;of x for the chosen axis&#39;</span><span class="p">)</span>
        <span class="n">windowVals</span> <span class="o">=</span> <span class="n">window</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">windowVals</span> <span class="o">=</span> <span class="n">window</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">xshapetarg</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_window</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">windowVals</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">windowVals</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">windowVals</span> <span class="o">*</span> <span class="n">x</span>

    <span class="n">xshapeother</span> <span class="o">=</span> <span class="n">xshape</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="n">otheraxis</span> <span class="o">=</span> <span class="p">(</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span>

    <span class="n">windowValsRep</span> <span class="o">=</span> <span class="n">stride_repeat</span><span class="p">(</span><span class="n">windowVals</span><span class="p">,</span> <span class="n">xshapeother</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">otheraxis</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">return_window</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">windowValsRep</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">windowVals</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">windowValsRep</span> <span class="o">*</span> <span class="n">x</span></div>


<div class="viewcode-block" id="detrend"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.detrend">[docs]</a><span class="k">def</span> <span class="nf">detrend</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return x with its trend removed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array or sequence</span>
<span class="sd">        Array or sequence containing the data.</span>

<span class="sd">    key : [ &#39;default&#39; | &#39;constant&#39; | &#39;mean&#39; | &#39;linear&#39; | &#39;none&#39;] or function</span>
<span class="sd">        Specifies the detrend algorithm to use. &#39;default&#39; is &#39;mean&#39;, which is</span>
<span class="sd">        the same as `detrend_mean`. &#39;constant&#39; is the same. &#39;linear&#39; is</span>
<span class="sd">        the same as `detrend_linear`. &#39;none&#39; is the same as</span>
<span class="sd">        `detrend_none`. The default is &#39;mean&#39;. See the corresponding</span>
<span class="sd">        functions for more details regarding the algorithms. Can also be a</span>
<span class="sd">        function that carries out the detrend operation.</span>

<span class="sd">    axis : integer</span>
<span class="sd">        The axis along which to do the detrending.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    detrend_mean : Implementation of the &#39;mean&#39; algorithm.</span>
<span class="sd">    detrend_linear : Implementation of the &#39;linear&#39; algorithm.</span>
<span class="sd">    detrend_none : Implementation of the &#39;none&#39; algorithm.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;default&#39;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">detrend</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">detrend_mean</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">detrend</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">detrend_linear</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">detrend</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">detrend_none</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown value for key </span><span class="si">%s</span><span class="s2">, must be one of: &quot;</span>
                         <span class="s2">&quot;&#39;default&#39;, &#39;constant&#39;, &#39;mean&#39;, &quot;</span>
                         <span class="s2">&quot;&#39;linear&#39;, or a function&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown value for key </span><span class="si">%s</span><span class="s2">, must be one of: &quot;</span>
                         <span class="s2">&quot;&#39;default&#39;, &#39;constant&#39;, &#39;mean&#39;, &quot;</span>
                         <span class="s2">&quot;&#39;linear&#39;, or a function&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">axis</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;axis(=</span><span class="si">%s</span><span class="s1">) out of bounds&#39;</span> <span class="o">%</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">axis</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">key</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># try to use the &#39;axis&#39; argument if the function supports it,</span>
    <span class="c1"># otherwise use apply_along_axis to do it</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">key</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">arr</span><span class="o">=</span><span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="demean"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.demean">[docs]</a><span class="nd">@cbook</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;3.1&quot;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s2">&quot;detrend_mean&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">demean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return x minus its mean along the specified axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array or sequence</span>
<span class="sd">        Array or sequence containing the data</span>
<span class="sd">        Can have any dimensionality</span>

<span class="sd">    axis : integer</span>
<span class="sd">        The axis along which to take the mean.  See numpy.mean for a</span>
<span class="sd">        description of this argument.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    detrend_mean : Same as `demean` except for the default *axis*.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">detrend_mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>


<div class="viewcode-block" id="detrend_mean"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.detrend_mean">[docs]</a><span class="k">def</span> <span class="nf">detrend_mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return x minus the mean(x).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array or sequence</span>
<span class="sd">        Array or sequence containing the data</span>
<span class="sd">        Can have any dimensionality</span>

<span class="sd">    axis : integer</span>
<span class="sd">        The axis along which to take the mean.  See numpy.mean for a</span>
<span class="sd">        description of this argument.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    detrend_linear : Another detrend algorithm.</span>
<span class="sd">    detrend_none : Another detrend algorithm.</span>
<span class="sd">    detrend : A wrapper around all the detrend algorithms.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">axis</span><span class="o">+</span><span class="mi">1</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;axis(=</span><span class="si">%s</span><span class="s1">) out of bounds&#39;</span> <span class="o">%</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="detrend_none"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.detrend_none">[docs]</a><span class="k">def</span> <span class="nf">detrend_none</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return x: no detrending.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : any object</span>
<span class="sd">        An object containing the data</span>

<span class="sd">    axis : integer</span>
<span class="sd">        This parameter is ignored.</span>
<span class="sd">        It is included for compatibility with detrend_mean</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    detrend_mean : Another detrend algorithm.</span>
<span class="sd">    detrend_linear : Another detrend algorithm.</span>
<span class="sd">    detrend : A wrapper around all the detrend algorithms.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="detrend_linear"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.detrend_linear">[docs]</a><span class="k">def</span> <span class="nf">detrend_linear</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return x minus best fit line; &#39;linear&#39; detrending.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : 0-D or 1-D array or sequence</span>
<span class="sd">        Array or sequence containing the data</span>

<span class="sd">    axis : integer</span>
<span class="sd">        The axis along which to take the mean.  See numpy.mean for a</span>
<span class="sd">        description of this argument.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    detrend_mean : Another detrend algorithm.</span>
<span class="sd">    detrend_none : Another detrend algorithm.</span>
<span class="sd">    detrend : A wrapper around all the detrend algorithms.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># This is faster than an algorithm based on linalg.lstsq.</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;y cannot have ndim &gt; 1&#39;</span><span class="p">)</span>

    <span class="c1"># short-circuit 0-D array.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">y</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">-</span> <span class="n">b</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span></div>


<div class="viewcode-block" id="stride_windows"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.stride_windows">[docs]</a><span class="k">def</span> <span class="nf">stride_windows</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Get all windows of x with length n as a single array,</span>
<span class="sd">    using strides to avoid data duplication.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        It is not safe to write to the output array.  Multiple</span>
<span class="sd">        elements may point to the same piece of memory,</span>
<span class="sd">        so modifying one value may change others.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1D array or sequence</span>
<span class="sd">        Array or sequence containing the data.</span>

<span class="sd">    n : integer</span>
<span class="sd">        The number of data points in each window.</span>

<span class="sd">    noverlap : integer</span>
<span class="sd">        The overlap between adjacent windows.</span>
<span class="sd">        Default is 0 (no overlap)</span>

<span class="sd">    axis : integer</span>
<span class="sd">        The axis along which the windows will run.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    `stackoverflow: Rolling window for 1D arrays in Numpy?</span>
<span class="sd">    &lt;http://stackoverflow.com/a/6811241&gt;`_</span>
<span class="sd">    `stackoverflow: Using strides for an efficient moving average filter</span>
<span class="sd">    &lt;http://stackoverflow.com/a/4947453&gt;`_</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">noverlap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">noverlap</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">noverlap</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;noverlap must be less than n&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;n cannot be less than 1&#39;</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;only 1-dimensional arrays can be used&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">noverlap</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;n cannot be greater than the length of x&#39;</span><span class="p">)</span>

    <span class="c1"># np.lib.stride_tricks.as_strided easily leads to memory corruption for</span>
    <span class="c1"># non integer shape and strides, i.e. noverlap or n. See #3845.</span>
    <span class="n">noverlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">noverlap</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="n">step</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">noverlap</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">noverlap</span><span class="p">)</span><span class="o">//</span><span class="n">step</span><span class="p">)</span>
        <span class="n">strides</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">step</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">noverlap</span><span class="p">)</span><span class="o">//</span><span class="n">step</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">strides</span> <span class="o">=</span> <span class="p">(</span><span class="n">step</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">as_strided</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">)</span></div>


<div class="viewcode-block" id="stride_repeat"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.stride_repeat">[docs]</a><span class="k">def</span> <span class="nf">stride_repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Repeat the values in an array in a memory-efficient manner.  Array x is</span>
<span class="sd">    stacked vertically n times.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        It is not safe to write to the output array.  Multiple</span>
<span class="sd">        elements may point to the same piece of memory, so</span>
<span class="sd">        modifying one value may change others.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1D array or sequence</span>
<span class="sd">        Array or sequence containing the data.</span>

<span class="sd">    n : integer</span>
<span class="sd">        The number of time to repeat the array.</span>

<span class="sd">    axis : integer</span>
<span class="sd">        The axis along which the data will run.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    `stackoverflow: Repeat NumPy array without replicating data?</span>
<span class="sd">    &lt;http://stackoverflow.com/a/5568169&gt;`_</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;axis must be 0 or 1&#39;</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;only 1-dimensional arrays can be used&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;n cannot be less than 1&#39;</span><span class="p">)</span>

    <span class="c1"># np.lib.stride_tricks.as_strided easily leads to memory corruption for</span>
    <span class="c1"># non integer shape and strides, i.e. n. See #3845.</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">strides</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">strides</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">strides</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">as_strided</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_spectral_helper</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">detrend_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This is a helper function that implements the commonality between the</span>
<span class="sd">    psd, csd, spectrogram and complex, magnitude, angle, and phase spectrums.</span>
<span class="sd">    It is *NOT* meant to be used outside of mlab and may change at any time.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># if y is None use x for y</span>
        <span class="n">same_data</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># The checks for if y is x are so that we can use the same function to</span>
        <span class="c1"># implement the core of psd(), csd(), and spectrogram() without doing</span>
        <span class="c1"># extra calculations.  We return the unaveraged Pxy, freqs, and t.</span>
        <span class="n">same_data</span> <span class="o">=</span> <span class="n">y</span> <span class="ow">is</span> <span class="n">x</span>

    <span class="k">if</span> <span class="n">Fs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Fs</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="n">noverlap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">noverlap</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">detrend_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">detrend_func</span> <span class="o">=</span> <span class="n">detrend_none</span>
    <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">window_hanning</span>

    <span class="c1"># if NFFT is set to None use the whole signal</span>
    <span class="k">if</span> <span class="n">NFFT</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">NFFT</span> <span class="o">=</span> <span class="mi">256</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;psd&#39;</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;psd&#39;</span><span class="p">,</span> <span class="s1">&#39;complex&#39;</span><span class="p">,</span> <span class="s1">&#39;magnitude&#39;</span><span class="p">,</span> <span class="s1">&#39;angle&#39;</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown value for mode </span><span class="si">%s</span><span class="s2">, must be one of: &quot;</span>
                         <span class="s2">&quot;&#39;default&#39;, &#39;psd&#39;, &#39;complex&#39;, &quot;</span>
                         <span class="s2">&quot;&#39;magnitude&#39;, &#39;angle&#39;, &#39;phase&#39;&quot;</span> <span class="o">%</span> <span class="n">mode</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">same_data</span> <span class="ow">and</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;psd&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x and y must be equal if mode is not &#39;psd&#39;&quot;</span><span class="p">)</span>

    <span class="c1"># Make sure we&#39;re dealing with a numpy array. If y and x were the same</span>
    <span class="c1"># object to start with, keep them that way</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">same_data</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sides</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">sides</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">sides</span> <span class="o">=</span> <span class="s1">&#39;twosided&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sides</span> <span class="o">=</span> <span class="s1">&#39;onesided&#39;</span>
    <span class="k">elif</span> <span class="n">sides</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;onesided&#39;</span><span class="p">,</span> <span class="s1">&#39;twosided&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown value for sides </span><span class="si">%s</span><span class="s2">, must be one of: &quot;</span>
                         <span class="s2">&quot;&#39;default&#39;, &#39;onesided&#39;, or &#39;twosided&#39;&quot;</span> <span class="o">%</span> <span class="n">sides</span><span class="p">)</span>

    <span class="c1"># zero pad x and y up to NFFT if they are shorter than NFFT</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">NFFT</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="p">)</span>
        <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">same_data</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">NFFT</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="p">)</span>
        <span class="n">y</span><span class="p">[</span><span class="n">n</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">pad_to</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pad_to</span> <span class="o">=</span> <span class="n">NFFT</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;psd&#39;</span><span class="p">:</span>
        <span class="n">scale_by_freq</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="n">scale_by_freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scale_by_freq</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># For real x, ignore the negative frequencies unless told otherwise</span>
    <span class="k">if</span> <span class="n">sides</span> <span class="o">==</span> <span class="s1">&#39;twosided&#39;</span><span class="p">:</span>
        <span class="n">numFreqs</span> <span class="o">=</span> <span class="n">pad_to</span>
        <span class="k">if</span> <span class="n">pad_to</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">freqcenter</span> <span class="o">=</span> <span class="p">(</span><span class="n">pad_to</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">freqcenter</span> <span class="o">=</span> <span class="n">pad_to</span><span class="o">//</span><span class="mi">2</span>
        <span class="n">scaling_factor</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="k">elif</span> <span class="n">sides</span> <span class="o">==</span> <span class="s1">&#39;onesided&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">pad_to</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">numFreqs</span> <span class="o">=</span> <span class="p">(</span><span class="n">pad_to</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">numFreqs</span> <span class="o">=</span> <span class="n">pad_to</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">scaling_factor</span> <span class="o">=</span> <span class="mf">2.</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">stride_windows</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="p">,</span> <span class="n">noverlap</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">detrend</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">detrend_func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">result</span><span class="p">,</span> <span class="n">windowVals</span> <span class="o">=</span> <span class="n">apply_window</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                      <span class="n">return_window</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:</span><span class="n">numFreqs</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="n">pad_to</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">Fs</span><span class="p">)[:</span><span class="n">numFreqs</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">same_data</span><span class="p">:</span>
        <span class="c1"># if same_data is False, mode must be &#39;psd&#39;</span>
        <span class="n">resultY</span> <span class="o">=</span> <span class="n">stride_windows</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="p">,</span> <span class="n">noverlap</span><span class="p">)</span>
        <span class="n">resultY</span> <span class="o">=</span> <span class="n">detrend</span><span class="p">(</span><span class="n">resultY</span><span class="p">,</span> <span class="n">detrend_func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">resultY</span> <span class="o">=</span> <span class="n">apply_window</span><span class="p">(</span><span class="n">resultY</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">resultY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">resultY</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:</span><span class="n">numFreqs</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">*</span> <span class="n">resultY</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;psd&#39;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">*</span> <span class="n">result</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;magnitude&#39;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">windowVals</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;angle&#39;</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;phase&#39;</span><span class="p">:</span>
        <span class="c1"># we unwrap the phase later to handle the onesided vs. twosided case</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;complex&#39;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">windowVals</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;psd&#39;</span><span class="p">:</span>

        <span class="c1"># Also include scaling factors for one-sided densities and dividing by</span>
        <span class="c1"># the sampling frequency, if desired. Scale everything, except the DC</span>
        <span class="c1"># component and the NFFT/2 component:</span>

        <span class="c1"># if we have a even number of frequencies, don&#39;t scale NFFT/2</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">NFFT</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">slc</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># if we have an odd number, just don&#39;t scale DC</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slc</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">result</span><span class="p">[</span><span class="n">slc</span><span class="p">]</span> <span class="o">*=</span> <span class="n">scaling_factor</span>

        <span class="c1"># MATLAB divides by the sampling frequency so that density function</span>
        <span class="c1"># has units of dB/Hz and can be integrated by the plotted frequency</span>
        <span class="c1"># values. Perform the same scaling here.</span>
        <span class="k">if</span> <span class="n">scale_by_freq</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">/=</span> <span class="n">Fs</span>
            <span class="c1"># Scale the spectrum by the norm of the window to compensate for</span>
            <span class="c1"># windowing loss; see Bendat &amp; Piersol Sec 11.5.2.</span>
            <span class="n">result</span> <span class="o">/=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">windowVals</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># In this case, preserve power in the segment, not amplitude</span>
            <span class="n">result</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">windowVals</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">**</span><span class="mi">2</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">NFFT</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">NFFT</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">NFFT</span> <span class="o">-</span> <span class="n">noverlap</span><span class="p">)</span><span class="o">/</span><span class="n">Fs</span>

    <span class="k">if</span> <span class="n">sides</span> <span class="o">==</span> <span class="s1">&#39;twosided&#39;</span><span class="p">:</span>
        <span class="c1"># center the frequency range at zero</span>
        <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">freqs</span><span class="p">[</span><span class="n">freqcenter</span><span class="p">:],</span> <span class="n">freqs</span><span class="p">[:</span><span class="n">freqcenter</span><span class="p">]))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">result</span><span class="p">[</span><span class="n">freqcenter</span><span class="p">:,</span> <span class="p">:],</span>
                                 <span class="n">result</span><span class="p">[:</span><span class="n">freqcenter</span><span class="p">,</span> <span class="p">:]),</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">pad_to</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># get the last value correctly, it is negative otherwise</span>
        <span class="n">freqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># we unwrap the phase here to handle the onesided vs. twosided case</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;phase&#39;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">t</span>


<span class="k">def</span> <span class="nf">_single_spectrum_helper</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This is a helper function that implements the commonality between the</span>
<span class="sd">    complex, magnitude, angle, and phase spectrums.</span>
<span class="sd">    It is *NOT* meant to be used outside of mlab and may change at any time.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;psd&#39;</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;_single_spectrum_helper does not work with </span><span class="si">%s</span><span class="s1"> mode&#39;</span>
                         <span class="o">%</span> <span class="n">mode</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">pad_to</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pad_to</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_spectral_helper</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span>
                                      <span class="n">detrend_func</span><span class="o">=</span><span class="n">detrend_none</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                      <span class="n">noverlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                                      <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span>
                                      <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;complex&#39;</span><span class="p">:</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">real</span>

    <span class="k">if</span> <span class="n">spec</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">spec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span>


<span class="c1"># Split out these keyword docs so that they can be used elsewhere</span>
<span class="n">docstring</span><span class="o">.</span><span class="n">interpd</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">Spectral</span><span class="o">=</span><span class="n">inspect</span><span class="o">.</span><span class="n">cleandoc</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Fs : scalar</span>
<span class="s2">        The sampling frequency (samples per time unit).  It is used</span>
<span class="s2">        to calculate the Fourier frequencies, freqs, in cycles per time</span>
<span class="s2">        unit. The default value is 2.</span>

<span class="s2">    window : callable or ndarray</span>
<span class="s2">        A function or a vector of length *NFFT*.  To create window vectors see</span>
<span class="s2">        `window_hanning`, `window_none`, `numpy.blackman`, `numpy.hamming`,</span>
<span class="s2">        `numpy.bartlett`, `scipy.signal`, `scipy.signal.get_window`, etc.  The</span>
<span class="s2">        default is `window_hanning`.  If a function is passed as the argument,</span>
<span class="s2">        it must take a data segment as an argument and return the windowed</span>
<span class="s2">        version of the segment.</span>

<span class="s2">    sides : {&#39;default&#39;, &#39;onesided&#39;, &#39;twosided&#39;}</span>
<span class="s2">        Specifies which sides of the spectrum to return.  Default gives the</span>
<span class="s2">        default behavior, which returns one-sided for real data and both</span>
<span class="s2">        for complex data.  &#39;onesided&#39; forces the return of a one-sided</span>
<span class="s2">        spectrum, while &#39;twosided&#39; forces two-sided.</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">))</span>


<span class="n">docstring</span><span class="o">.</span><span class="n">interpd</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">Single_Spectrum</span><span class="o">=</span><span class="n">inspect</span><span class="o">.</span><span class="n">cleandoc</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    pad_to : int</span>
<span class="s2">        The number of points to which the data segment is padded when</span>
<span class="s2">        performing the FFT.  While not increasing the actual resolution of</span>
<span class="s2">        the spectrum (the minimum distance between resolvable peaks),</span>
<span class="s2">        this can give more points in the plot, allowing for more</span>
<span class="s2">        detail. This corresponds to the *n* parameter in the call to fft().</span>
<span class="s2">        The default is None, which sets *pad_to* equal to the length of the</span>
<span class="s2">        input signal (i.e. no padding).</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">))</span>


<span class="n">docstring</span><span class="o">.</span><span class="n">interpd</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">PSD</span><span class="o">=</span><span class="n">inspect</span><span class="o">.</span><span class="n">cleandoc</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    pad_to : int</span>
<span class="s2">        The number of points to which the data segment is padded when</span>
<span class="s2">        performing the FFT.  This can be different from *NFFT*, which</span>
<span class="s2">        specifies the number of data points used.  While not increasing</span>
<span class="s2">        the actual resolution of the spectrum (the minimum distance between</span>
<span class="s2">        resolvable peaks), this can give more points in the plot,</span>
<span class="s2">        allowing for more detail. This corresponds to the *n* parameter</span>
<span class="s2">        in the call to fft(). The default is None, which sets *pad_to*</span>
<span class="s2">        equal to *NFFT*</span>

<span class="s2">    NFFT : int</span>
<span class="s2">        The number of data points used in each block for the FFT.</span>
<span class="s2">        A power 2 is most efficient.  The default value is 256.</span>
<span class="s2">        This should *NOT* be used to get zero padding, or the scaling of the</span>
<span class="s2">        result will be incorrect. Use *pad_to* for this instead.</span>

<span class="s2">    detrend : {&#39;none&#39;, &#39;mean&#39;, &#39;linear&#39;} or callable, default &#39;none&#39;</span>
<span class="s2">        The function applied to each segment before fft-ing, designed to</span>
<span class="s2">        remove the mean or linear trend.  Unlike in MATLAB, where the</span>
<span class="s2">        *detrend* parameter is a vector, in Matplotlib is it a function.</span>
<span class="s2">        The :mod:`~matplotlib.mlab` module defines `.detrend_none`,</span>
<span class="s2">        `.detrend_mean`, and `.detrend_linear`, but you can use a custom</span>
<span class="s2">        function as well.  You can also use a string to choose one of the</span>
<span class="s2">        functions: &#39;none&#39; calls `.detrend_none`. &#39;mean&#39; calls `.detrend_mean`.</span>
<span class="s2">        &#39;linear&#39; calls `.detrend_linear`.</span>

<span class="s2">    scale_by_freq : bool, optional</span>
<span class="s2">        Specifies whether the resulting density values should be scaled</span>
<span class="s2">        by the scaling frequency, which gives density in units of Hz^-1.</span>
<span class="s2">        This allows for integration over the returned frequency values.</span>
<span class="s2">        The default is True for MATLAB compatibility.</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">))</span>


<div class="viewcode-block" id="psd"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.psd">[docs]</a><span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
<span class="k">def</span> <span class="nf">psd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the power spectral density.</span>

<span class="sd">    The power spectral density :math:`P_{xx}` by Welch&#39;s average</span>
<span class="sd">    periodogram method.  The vector *x* is divided into *NFFT* length</span>
<span class="sd">    segments.  Each segment is detrended by function *detrend* and</span>
<span class="sd">    windowed by function *window*.  *noverlap* gives the length of</span>
<span class="sd">    the overlap between segments.  The :math:`|\mathrm{fft}(i)|^2`</span>
<span class="sd">    of each segment :math:`i` are averaged to compute :math:`P_{xx}`.</span>

<span class="sd">    If len(*x*) &lt; *NFFT*, it will be zero padded to *NFFT*.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1-D array or sequence</span>
<span class="sd">        Array or sequence containing the data</span>

<span class="sd">    %(Spectral)s</span>

<span class="sd">    %(PSD)s</span>

<span class="sd">    noverlap : integer</span>
<span class="sd">        The number of points of overlap between segments.</span>
<span class="sd">        The default value is 0 (no overlap).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Pxx : 1-D array</span>
<span class="sd">        The values for the power spectrum `P_{xx}` (real valued)</span>

<span class="sd">    freqs : 1-D array</span>
<span class="sd">        The frequencies corresponding to the elements in *Pxx*</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Bendat &amp; Piersol -- Random Data: Analysis and Measurement Procedures, John</span>
<span class="sd">    Wiley &amp; Sons (1986)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    specgram</span>
<span class="sd">        `specgram` differs in the default overlap; in not returning the mean of</span>
<span class="sd">        the segment periodograms; and in returning the times of the segments.</span>

<span class="sd">    magnitude_spectrum : returns the magnitude spectrum.</span>

<span class="sd">    csd : returns the spectral density between two signals.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Pxx</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">csd</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span>
                     <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                     <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="n">scale_by_freq</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Pxx</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">freqs</span></div>


<div class="viewcode-block" id="csd"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.csd">[docs]</a><span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
<span class="k">def</span> <span class="nf">csd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the cross-spectral density.</span>

<span class="sd">    The cross spectral density :math:`P_{xy}` by Welch&#39;s average</span>
<span class="sd">    periodogram method.  The vectors *x* and *y* are divided into</span>
<span class="sd">    *NFFT* length segments.  Each segment is detrended by function</span>
<span class="sd">    *detrend* and windowed by function *window*.  *noverlap* gives</span>
<span class="sd">    the length of the overlap between segments.  The product of</span>
<span class="sd">    the direct FFTs of *x* and *y* are averaged over each segment</span>
<span class="sd">    to compute :math:`P_{xy}`, with a scaling to correct for power</span>
<span class="sd">    loss due to windowing.</span>

<span class="sd">    If len(*x*) &lt; *NFFT* or len(*y*) &lt; *NFFT*, they will be zero</span>
<span class="sd">    padded to *NFFT*.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y : 1-D arrays or sequences</span>
<span class="sd">        Arrays or sequences containing the data</span>

<span class="sd">    %(Spectral)s</span>

<span class="sd">    %(PSD)s</span>

<span class="sd">    noverlap : integer</span>
<span class="sd">        The number of points of overlap between segments.</span>
<span class="sd">        The default value is 0 (no overlap).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Pxy : 1-D array</span>
<span class="sd">        The values for the cross spectrum `P_{xy}` before scaling (real valued)</span>

<span class="sd">    freqs : 1-D array</span>
<span class="sd">        The frequencies corresponding to the elements in *Pxy*</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    Bendat &amp; Piersol -- Random Data: Analysis and Measurement Procedures, John</span>
<span class="sd">    Wiley &amp; Sons (1986)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    psd : equivalent to setting ``y = x``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">NFFT</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">NFFT</span> <span class="o">=</span> <span class="mi">256</span>
    <span class="n">Pxy</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_spectral_helper</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span>
                                     <span class="n">detrend_func</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                     <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                                     <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="n">scale_by_freq</span><span class="p">,</span>
                                     <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;psd&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">Pxy</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">Pxy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">Pxy</span> <span class="o">=</span> <span class="n">Pxy</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Pxy</span> <span class="o">=</span> <span class="n">Pxy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">Pxy</span><span class="p">,</span> <span class="n">freqs</span></div>


<div class="viewcode-block" id="complex_spectrum"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.complex_spectrum">[docs]</a><span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
<span class="k">def</span> <span class="nf">complex_spectrum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the complex-valued frequency spectrum of *x*.  Data is padded to a</span>
<span class="sd">    length of *pad_to* and the windowing function *window* is applied to the</span>
<span class="sd">    signal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1-D array or sequence</span>
<span class="sd">        Array or sequence containing the data</span>

<span class="sd">    %(Spectral)s</span>

<span class="sd">    %(Single_Spectrum)s</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    spectrum : 1-D array</span>
<span class="sd">        The values for the complex spectrum (complex valued)</span>

<span class="sd">    freqs : 1-D array</span>
<span class="sd">        The frequencies corresponding to the elements in *spectrum*</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    magnitude_spectrum</span>
<span class="sd">        Returns the absolute value of this function.</span>
<span class="sd">    angle_spectrum</span>
<span class="sd">        Returns the angle of this function.</span>
<span class="sd">    phase_spectrum</span>
<span class="sd">        Returns the phase (unwrapped angle) of this function.</span>
<span class="sd">    specgram</span>
<span class="sd">        Can return the complex spectrum of segments within the signal.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_single_spectrum_helper</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                                   <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;complex&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="magnitude_spectrum"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.magnitude_spectrum">[docs]</a><span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
<span class="k">def</span> <span class="nf">magnitude_spectrum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the magnitude (absolute value) of the frequency spectrum of</span>
<span class="sd">    *x*.  Data is padded to a length of *pad_to* and the windowing function</span>
<span class="sd">    *window* is applied to the signal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1-D array or sequence</span>
<span class="sd">        Array or sequence containing the data</span>

<span class="sd">    %(Spectral)s</span>

<span class="sd">    %(Single_Spectrum)s</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    spectrum : 1-D array</span>
<span class="sd">        The values for the magnitude spectrum (real valued)</span>

<span class="sd">    freqs : 1-D array</span>
<span class="sd">        The frequencies corresponding to the elements in *spectrum*</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    psd</span>
<span class="sd">        Returns the power spectral density.</span>
<span class="sd">    complex_spectrum</span>
<span class="sd">        This function returns the absolute value of `complex_spectrum`.</span>
<span class="sd">    angle_spectrum</span>
<span class="sd">        Returns the angles of the corresponding frequencies.</span>
<span class="sd">    phase_spectrum</span>
<span class="sd">        Returns the phase (unwrapped angle) of the corresponding frequencies.</span>
<span class="sd">    specgram</span>
<span class="sd">        Can return the complex spectrum of segments within the signal.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_single_spectrum_helper</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                                   <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;magnitude&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="angle_spectrum"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.angle_spectrum">[docs]</a><span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
<span class="k">def</span> <span class="nf">angle_spectrum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the angle of the frequency spectrum (wrapped phase spectrum) of</span>
<span class="sd">    *x*.  Data is padded to a length of *pad_to* and the windowing function</span>
<span class="sd">    *window* is applied to the signal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1-D array or sequence</span>
<span class="sd">        Array or sequence containing the data</span>

<span class="sd">    %(Spectral)s</span>

<span class="sd">    %(Single_Spectrum)s</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    spectrum : 1-D array</span>
<span class="sd">        The values for the angle spectrum in radians (real valued)</span>

<span class="sd">    freqs : 1-D array</span>
<span class="sd">        The frequencies corresponding to the elements in *spectrum*</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    complex_spectrum</span>
<span class="sd">        This function returns the angle value of `complex_spectrum`.</span>
<span class="sd">    magnitude_spectrum</span>
<span class="sd">        Returns the magnitudes of the corresponding frequencies.</span>
<span class="sd">    phase_spectrum</span>
<span class="sd">        Returns the phase (unwrapped angle) of the corresponding frequencies.</span>
<span class="sd">    specgram</span>
<span class="sd">        Can return the complex spectrum of segments within the signal.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_single_spectrum_helper</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                                   <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;angle&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="phase_spectrum"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.phase_spectrum">[docs]</a><span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
<span class="k">def</span> <span class="nf">phase_spectrum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the phase of the frequency spectrum (unwrapped angle spectrum) of</span>
<span class="sd">    *x*.  Data is padded to a length of *pad_to* and the windowing function</span>
<span class="sd">    *window* is applied to the signal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1-D array or sequence</span>
<span class="sd">        Array or sequence containing the data</span>

<span class="sd">    %(Spectral)s</span>

<span class="sd">    %(Single_Spectrum)s</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    spectrum : 1-D array</span>
<span class="sd">        The values for the phase spectrum in radians (real valued)</span>

<span class="sd">    freqs : 1-D array</span>
<span class="sd">        The frequencies corresponding to the elements in *spectrum*</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    complex_spectrum</span>
<span class="sd">        This function returns the phase value of `complex_spectrum`.</span>
<span class="sd">    magnitude_spectrum</span>
<span class="sd">        Returns the magnitudes of the corresponding frequencies.</span>
<span class="sd">    angle_spectrum</span>
<span class="sd">        Returns the angle (wrapped phase) of the corresponding frequencies.</span>
<span class="sd">    specgram</span>
<span class="sd">        Can return the complex spectrum of segments within the signal.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_single_spectrum_helper</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                                   <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;phase&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="specgram"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.specgram">[docs]</a><span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
<span class="k">def</span> <span class="nf">specgram</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">noverlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute a spectrogram.</span>

<span class="sd">    Compute and plot a spectrogram of data in x.  Data are split into</span>
<span class="sd">    NFFT length segments and the spectrum of each section is</span>
<span class="sd">    computed.  The windowing function window is applied to each</span>
<span class="sd">    segment, and the amount of overlap of each segment is</span>
<span class="sd">    specified with noverlap.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        1-D array or sequence.</span>

<span class="sd">    %(Spectral)s</span>

<span class="sd">    %(PSD)s</span>

<span class="sd">    noverlap : int, optional</span>
<span class="sd">        The number of points of overlap between blocks.  The default</span>
<span class="sd">        value is 128.</span>
<span class="sd">    mode : str, optional</span>
<span class="sd">        What sort of spectrum to use, default is &#39;psd&#39;.</span>
<span class="sd">            &#39;psd&#39;</span>
<span class="sd">                Returns the power spectral density.</span>

<span class="sd">            &#39;complex&#39;</span>
<span class="sd">                Returns the complex-valued frequency spectrum.</span>

<span class="sd">            &#39;magnitude&#39;</span>
<span class="sd">                Returns the magnitude spectrum.</span>

<span class="sd">            &#39;angle&#39;</span>
<span class="sd">                Returns the phase spectrum without unwrapping.</span>

<span class="sd">            &#39;phase&#39;</span>
<span class="sd">                Returns the phase spectrum with unwrapping.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    spectrum : array_like</span>
<span class="sd">        2-D array, columns are the periodograms of successive segments.</span>

<span class="sd">    freqs : array_like</span>
<span class="sd">        1-D array, frequencies corresponding to the rows in *spectrum*.</span>

<span class="sd">    t : array_like</span>
<span class="sd">        1-D array, the times corresponding to midpoints of segments</span>
<span class="sd">        (i.e the columns in *spectrum*).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    psd : differs in the overlap and in the return values.</span>
<span class="sd">    complex_spectrum : similar, but with complex valued frequencies.</span>
<span class="sd">    magnitude_spectrum : similar single segment when mode is &#39;magnitude&#39;.</span>
<span class="sd">    angle_spectrum : similar to single segment when mode is &#39;angle&#39;.</span>
<span class="sd">    phase_spectrum : similar to single segment when mode is &#39;phase&#39;.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    detrend and scale_by_freq only apply when *mode* is set to &#39;psd&#39;.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">noverlap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">noverlap</span> <span class="o">=</span> <span class="mi">128</span>  <span class="c1"># default in _spectral_helper() is noverlap = 0</span>
    <span class="k">if</span> <span class="n">NFFT</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">NFFT</span> <span class="o">=</span> <span class="mi">256</span>  <span class="c1"># same default as in _spectral_helper()</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">NFFT</span><span class="p">:</span>
        <span class="n">cbook</span><span class="o">.</span><span class="n">_warn_external</span><span class="p">(</span><span class="s2">&quot;Only one segment is calculated since parameter &quot;</span>
                             <span class="s2">&quot;NFFT (=</span><span class="si">%d</span><span class="s2">) &gt;= signal length (=</span><span class="si">%d</span><span class="s2">).&quot;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">NFFT</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>

    <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">_spectral_helper</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span>
                                      <span class="n">detrend_func</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                      <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                                      <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span>
                                      <span class="n">scale_by_freq</span><span class="o">=</span><span class="n">scale_by_freq</span><span class="p">,</span>
                                      <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;complex&#39;</span><span class="p">:</span>
        <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">real</span>  <span class="c1"># Needed since helper implements generically</span>

    <span class="k">return</span> <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">t</span></div>


<span class="n">_coh_error</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Coherence is calculated by averaging over *NFFT*</span>
<span class="s2">length segments.  Your signal is too short for your choice of *NFFT*.</span>
<span class="s2">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="cohere"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.cohere">[docs]</a><span class="nd">@docstring</span><span class="o">.</span><span class="n">dedent_interpd</span>
<span class="k">def</span> <span class="nf">cohere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend_none</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window_hanning</span><span class="p">,</span>
           <span class="n">noverlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The coherence between *x* and *y*.  Coherence is the normalized</span>
<span class="sd">    cross spectral density:</span>

<span class="sd">    .. math::</span>

<span class="sd">        C_{xy} = \\frac{|P_{xy}|^2}{P_{xx}P_{yy}}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x, y</span>
<span class="sd">        Array or sequence containing the data</span>

<span class="sd">    %(Spectral)s</span>

<span class="sd">    %(PSD)s</span>

<span class="sd">    noverlap : integer</span>
<span class="sd">        The number of points of overlap between blocks.  The default value</span>
<span class="sd">        is 0 (no overlap).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    The return value is the tuple (*Cxy*, *f*), where *f* are the</span>
<span class="sd">    frequencies of the coherence vector. For cohere, scaling the</span>
<span class="sd">    individual densities by the sampling frequency has no effect,</span>
<span class="sd">    since the factors cancel out.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`psd`, :func:`csd` :</span>
<span class="sd">        For information about the methods used to compute :math:`P_{xy}`,</span>
<span class="sd">        :math:`P_{xx}` and :math:`P_{yy}`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">NFFT</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_coh_error</span><span class="p">)</span>
    <span class="n">Pxx</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">psd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="p">,</span> <span class="n">detrend</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="p">,</span> <span class="n">sides</span><span class="p">,</span>
                 <span class="n">scale_by_freq</span><span class="p">)</span>
    <span class="n">Pyy</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">psd</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="p">,</span> <span class="n">detrend</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="p">,</span> <span class="n">sides</span><span class="p">,</span>
                 <span class="n">scale_by_freq</span><span class="p">)</span>
    <span class="n">Pxy</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">csd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="p">,</span> <span class="n">detrend</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="p">,</span> <span class="n">sides</span><span class="p">,</span>
                 <span class="n">scale_by_freq</span><span class="p">)</span>
    <span class="n">Cxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Pxy</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="n">Pxx</span> <span class="o">*</span> <span class="n">Pyy</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Cxy</span><span class="p">,</span> <span class="n">f</span></div>


<span class="k">def</span> <span class="nf">_csv2rec</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">comments</span><span class="o">=</span><span class="s1">&#39;#&#39;</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">checkrows</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span>
             <span class="n">converterd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">missingd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">use_mrecords</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dayfirst</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">yearfirst</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load data from comma/space/tab delimited file in *fname* into a</span>
<span class="sd">    numpy record array and return the record array.</span>

<span class="sd">    If *names* is *None*, a header row is required to automatically</span>
<span class="sd">    assign the recarray names.  The headers will be lower cased,</span>
<span class="sd">    spaces will be converted to underscores, and illegal attribute</span>
<span class="sd">    name characters removed.  If *names* is not *None*, it is a</span>
<span class="sd">    sequence of names to use for the column names.  In this case, it</span>
<span class="sd">    is assumed there is no header row.</span>


<span class="sd">    - *fname*: can be a filename or a file handle.  Support for gzipped</span>
<span class="sd">      files is automatic, if the filename ends in &#39;.gz&#39;</span>

<span class="sd">    - *comments*: the character used to indicate the start of a comment</span>
<span class="sd">      in the file, or *None* to switch off the removal of comments</span>

<span class="sd">    - *skiprows*: is the number of rows from the top to skip</span>

<span class="sd">    - *checkrows*: is the number of rows to check to validate the column</span>
<span class="sd">      data type.  When set to zero all rows are validated.</span>

<span class="sd">    - *converterd*: if not *None*, is a dictionary mapping column number or</span>
<span class="sd">      munged column name to a converter function.</span>

<span class="sd">    - *names*: if not None, is a list of header names.  In this case, no</span>
<span class="sd">      header will be read from the file</span>

<span class="sd">    - *missingd* is a dictionary mapping munged column names to field values</span>
<span class="sd">      which signify that the field does not contain actual data and should</span>
<span class="sd">      be masked, e.g., &#39;0000-00-00&#39; or &#39;unused&#39;</span>

<span class="sd">    - *missing*: a string whose value signals a missing field regardless of</span>
<span class="sd">      the column it appears in</span>

<span class="sd">    - *use_mrecords*: if True, return an mrecords.fromrecords record array if</span>
<span class="sd">      any of the data are missing</span>

<span class="sd">    - *dayfirst*: default is False so that MM-DD-YY has precedence over</span>
<span class="sd">      DD-MM-YY.  See</span>
<span class="sd">      http://labix.org/python-dateutil#head-b95ce2094d189a89f80f5ae52a05b4ab7b41af47</span>
<span class="sd">      for further information.</span>

<span class="sd">    - *yearfirst*: default is False so that MM-DD-YY has precedence over</span>
<span class="sd">      YY-MM-DD. See</span>
<span class="sd">      http://labix.org/python-dateutil#head-b95ce2094d189a89f80f5ae52a05b4ab7b41af47</span>
<span class="sd">      for further information.</span>

<span class="sd">      If no rows are found, *None* is returned</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">converterd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">converterd</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">missingd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">missingd</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="kn">import</span> <span class="nn">dateutil.parser</span>
    <span class="kn">import</span> <span class="nn">datetime</span>

    <span class="n">fh</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">to_filehandle</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>

    <span class="n">delimiter</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">delimiter</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">FH</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For space-delimited files, we want different behavior than</span>
<span class="sd">        comma or tab.  Generally, we want multiple spaces to be</span>
<span class="sd">        treated as a single separator, whereas with comma and tab we</span>
<span class="sd">        want multiple commas to return multiple (empty) fields.  The</span>
<span class="sd">        join/strip trick below effects this.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fh</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fh</span> <span class="o">=</span> <span class="n">fh</span>

        <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fh</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">fix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>

        <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fh</span><span class="p">))</span>

        <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fh</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">delimiter</span> <span class="o">==</span> <span class="s1">&#39; &#39;</span><span class="p">:</span>
        <span class="n">fh</span> <span class="o">=</span> <span class="n">FH</span><span class="p">(</span><span class="n">fh</span><span class="p">)</span>

    <span class="n">reader</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">fh</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="n">delimiter</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">process_skiprows</span><span class="p">(</span><span class="n">reader</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">skiprows</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">reader</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">skiprows</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">break</span>

        <span class="k">return</span> <span class="n">fh</span><span class="p">,</span> <span class="n">reader</span>

    <span class="n">process_skiprows</span><span class="p">(</span><span class="n">reader</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ismissing</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="s2">&quot;Should the value val in column name be masked?&quot;</span>
        <span class="k">return</span> <span class="n">val</span> <span class="o">==</span> <span class="n">missing</span> <span class="ow">or</span> <span class="n">val</span> <span class="o">==</span> <span class="n">missingd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">or</span> <span class="n">val</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">with_default_value</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">default</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">newfunc</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ismissing</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">default</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newfunc</span>

    <span class="k">def</span> <span class="nf">mybool</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;True&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;False&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid bool&#39;</span><span class="p">)</span>

    <span class="n">dateparser</span> <span class="o">=</span> <span class="n">dateutil</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">parse</span>

    <span class="k">def</span> <span class="nf">mydateparser</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="c1"># try and return a datetime object</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">dateparser</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dayfirst</span><span class="o">=</span><span class="n">dayfirst</span><span class="p">,</span> <span class="n">yearfirst</span><span class="o">=</span><span class="n">yearfirst</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="n">mydateparser</span> <span class="o">=</span> <span class="n">with_default_value</span><span class="p">(</span><span class="n">mydateparser</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">myfloat</span> <span class="o">=</span> <span class="n">with_default_value</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">myint</span> <span class="o">=</span> <span class="n">with_default_value</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">mystr</span> <span class="o">=</span> <span class="n">with_default_value</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">mybool</span> <span class="o">=</span> <span class="n">with_default_value</span><span class="p">(</span><span class="n">mybool</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mydate</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="c1"># try and return a date object</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">dateparser</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dayfirst</span><span class="o">=</span><span class="n">dayfirst</span><span class="p">,</span> <span class="n">yearfirst</span><span class="o">=</span><span class="n">yearfirst</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">hour</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">d</span><span class="o">.</span><span class="n">minute</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">d</span><span class="o">.</span><span class="n">second</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;not a date&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">date</span><span class="p">()</span>
    <span class="n">mydate</span> <span class="o">=</span> <span class="n">with_default_value</span><span class="p">(</span><span class="n">mydate</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get_func</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="c1"># promote functions in this order</span>
        <span class="n">funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">mybool</span><span class="p">,</span> <span class="n">myint</span><span class="p">,</span> <span class="n">myfloat</span><span class="p">,</span> <span class="n">mydate</span><span class="p">,</span> <span class="n">mydateparser</span><span class="p">,</span> <span class="n">mystr</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">[</span><span class="n">funcs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">func</span><span class="p">):]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">func</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">return</span> <span class="n">func</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Could not find a working conversion function&#39;</span><span class="p">)</span>

    <span class="c1"># map column names that clash with builtins -- TODO - extend this list</span>
    <span class="n">itemd</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;return&#39;</span><span class="p">:</span> <span class="s1">&#39;return_&#39;</span><span class="p">,</span>
        <span class="s1">&#39;file&#39;</span><span class="p">:</span>   <span class="s1">&#39;file_&#39;</span><span class="p">,</span>
        <span class="s1">&#39;print&#39;</span><span class="p">:</span>  <span class="s1">&#39;print_&#39;</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">get_converters</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">comments</span><span class="p">):</span>

        <span class="n">converters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">reader</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="ow">and</span> <span class="n">comments</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                    <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">comments</span><span class="p">)):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">converters</span> <span class="o">=</span> <span class="p">[</span><span class="n">mybool</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">checkrows</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">checkrows</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">row</span><span class="p">)):</span>
                <span class="n">func</span> <span class="o">=</span> <span class="n">converterd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">func</span> <span class="o">=</span> <span class="n">converterd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">func</span> <span class="o">=</span> <span class="n">converters</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">strip</span><span class="p">()):</span>
                        <span class="n">func</span> <span class="o">=</span> <span class="n">get_func</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># how should we handle custom converters and defaults?</span>
                    <span class="n">func</span> <span class="o">=</span> <span class="n">with_default_value</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">converters</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span>
        <span class="k">return</span> <span class="n">converters</span>

    <span class="c1"># Get header and remove invalid characters</span>
    <span class="n">needheader</span> <span class="o">=</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">needheader</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">reader</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="ow">and</span> <span class="n">comments</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                    <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">comments</span><span class="p">)):</span>
                <span class="k">continue</span>
            <span class="n">headers</span> <span class="o">=</span> <span class="n">row</span>
            <span class="k">break</span>

        <span class="c1"># remove these chars</span>
        <span class="n">delete</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;~!@#$%^&amp;*()-=+~\|}[]{&#39;;: /?.&gt;,&lt;&quot;&quot;&quot;</span><span class="p">)</span>
        <span class="n">delete</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">)</span>

        <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">headers</span><span class="p">):</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span><span class="p">)</span>
            <span class="n">item</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">item</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">delete</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
                <span class="n">item</span> <span class="o">=</span> <span class="s1">&#39;column</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span>

            <span class="n">item</span> <span class="o">=</span> <span class="n">itemd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
            <span class="n">cnt</span> <span class="o">=</span> <span class="n">seen</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span> <span class="o">+</span> <span class="s1">&#39;_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">cnt</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="n">seen</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt</span><span class="o">+</span><span class="mi">1</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)]</span>

    <span class="c1"># get the converter functions by inspecting checkrows</span>
    <span class="n">converters</span> <span class="o">=</span> <span class="n">get_converters</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">comments</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">converters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Could not find any valid data in CSV file&#39;</span><span class="p">)</span>

    <span class="c1"># reset the reader and start over</span>
    <span class="n">fh</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">reader</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">fh</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="n">delimiter</span><span class="p">)</span>
    <span class="n">process_skiprows</span><span class="p">(</span><span class="n">reader</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">needheader</span><span class="p">:</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># skip past any comments and consume one line of column header</span>
            <span class="n">row</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">reader</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="ow">and</span> <span class="n">comments</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                    <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">comments</span><span class="p">)):</span>
                <span class="k">continue</span>
            <span class="k">break</span>

    <span class="c1"># iterate over the remaining rows and convert the data to date</span>
    <span class="c1"># objects, ints, or floats as appropriate</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">rowmasks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">reader</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">comments</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">comments</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="c1"># Ensure that the row returned always has the same nr of elements</span>
        <span class="n">row</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">converters</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)))</span>
        <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">func</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">func</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">converters</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">row</span><span class="p">)])</span>
        <span class="n">rowmasks</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ismissing</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">row</span><span class="p">)])</span>
    <span class="n">fh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">use_mrecords</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">rowmasks</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mrecords</span><span class="o">.</span><span class="n">fromrecords</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">rowmasks</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">fromrecords</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span>


<div class="viewcode-block" id="GaussianKDE"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.GaussianKDE">[docs]</a><span class="k">class</span> <span class="nc">GaussianKDE</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Representation of a kernel-density estimate using Gaussian kernels.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dataset : array_like</span>
<span class="sd">        Datapoints to estimate from. In case of univariate data this is a 1-D</span>
<span class="sd">        array, otherwise a 2-D array with shape (# of dims, # of data).</span>

<span class="sd">    bw_method : str, scalar or callable, optional</span>
<span class="sd">        The method used to calculate the estimator bandwidth.  This can be</span>
<span class="sd">        &#39;scott&#39;, &#39;silverman&#39;, a scalar constant or a callable.  If a</span>
<span class="sd">        scalar, this will be used directly as `kde.factor`.  If a</span>
<span class="sd">        callable, it should take a `GaussianKDE` instance as only</span>
<span class="sd">        parameter and return a scalar. If None (default), &#39;scott&#39; is used.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    dataset : ndarray</span>
<span class="sd">        The dataset with which `gaussian_kde` was initialized.</span>

<span class="sd">    dim : int</span>
<span class="sd">        Number of dimensions.</span>

<span class="sd">    num_dp : int</span>
<span class="sd">        Number of datapoints.</span>

<span class="sd">    factor : float</span>
<span class="sd">        The bandwidth factor, obtained from `kde.covariance_factor`, with which</span>
<span class="sd">        the covariance matrix is multiplied.</span>

<span class="sd">    covariance : ndarray</span>
<span class="sd">        The covariance matrix of `dataset`, scaled by the calculated bandwidth</span>
<span class="sd">        (`kde.factor`).</span>

<span class="sd">    inv_cov : ndarray</span>
<span class="sd">        The inverse of `covariance`.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    kde.evaluate(points) : ndarray</span>
<span class="sd">        Evaluate the estimated pdf on a provided set of points.</span>

<span class="sd">    kde(points) : ndarray</span>
<span class="sd">        Same as kde.evaluate(points)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># This implementation with minor modification was too good to pass up.</span>
    <span class="c1"># from scipy: https://github.com/scipy/scipy/blob/master/scipy/stats/kde.py</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">bw_method</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`dataset` input should have multiple elements.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">isString</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bw_method</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bw_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">isString</span> <span class="ow">and</span> <span class="n">bw_method</span> <span class="o">==</span> <span class="s1">&#39;scott&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">covariance_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scotts_factor</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">isString</span> <span class="ow">and</span> <span class="n">bw_method</span> <span class="o">==</span> <span class="s1">&#39;silverman&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">covariance_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">silverman_factor</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">bw_method</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">isString</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bw_method</span> <span class="o">=</span> <span class="s1">&#39;use constant&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">covariance_factor</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">bw_method</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">bw_method</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bw_method</span> <span class="o">=</span> <span class="n">bw_method</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">covariance_factor</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bw_method</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`bw_method` should be &#39;scott&#39;, &#39;silverman&#39;, a &quot;</span>
                             <span class="s2">&quot;scalar or a callable&quot;</span><span class="p">)</span>

        <span class="c1"># Computes the covariance matrix for each Gaussian kernel using</span>
        <span class="c1"># covariance_factor().</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance_factor</span><span class="p">()</span>
        <span class="c1"># Cache covariance and inverse covariance of the data</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_data_inv_cov&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_covariance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">,</span>
                    <span class="n">rowvar</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_inv_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_covariance</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_covariance</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inv_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_inv_cov</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span>
                <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">covariance</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dp</span>

<div class="viewcode-block" id="GaussianKDE.scotts_factor"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.GaussianKDE.scotts_factor">[docs]</a>    <span class="k">def</span> <span class="nf">scotts_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dp</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span></div>

<div class="viewcode-block" id="GaussianKDE.silverman_factor"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.GaussianKDE.silverman_factor">[docs]</a>    <span class="k">def</span> <span class="nf">silverman_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_dp</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">+</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">4.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span></div>

    <span class="c1">#  Default method to calculate bandwidth, can be overwritten by subclass</span>
    <span class="n">covariance_factor</span> <span class="o">=</span> <span class="n">scotts_factor</span>

<div class="viewcode-block" id="GaussianKDE.evaluate"><a class="viewcode-back" href="../../api/mlab_api.html#matplotlib.mlab.GaussianKDE.evaluate">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the estimated pdf on a set of points.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        points : (# of dimensions, # of points)-array</span>
<span class="sd">            Alternatively, a (# of dimensions,) vector can be passed in and</span>
<span class="sd">            treated as a single point.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        values : (# of points,)-array</span>
<span class="sd">            The values at each point.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError : if the dimensionality of the input points is different</span>
<span class="sd">                     than the dimensionality of the KDE.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="n">dim</span><span class="p">,</span> <span class="n">num_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;points have dimension </span><span class="si">{}</span><span class="s2">, dataset has dimension &quot;</span>
                             <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">))</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_m</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">num_m</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dp</span><span class="p">:</span>
            <span class="c1"># there are more points than data, so loop over data</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dp</span><span class="p">):</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span>
                <span class="n">tdiff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inv_cov</span><span class="p">,</span> <span class="n">diff</span><span class="p">)</span>
                <span class="n">energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">diff</span> <span class="o">*</span> <span class="n">tdiff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">energy</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># loop over points</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_m</span><span class="p">):</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span> <span class="o">-</span> <span class="n">points</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                <span class="n">tdiff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inv_cov</span><span class="p">,</span> <span class="n">diff</span><span class="p">)</span>
                <span class="n">energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">diff</span> <span class="o">*</span> <span class="n">tdiff</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">energy</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_factor</span>

        <span class="k">return</span> <span class="n">result</span></div>

    <span class="fm">__call__</span> <span class="o">=</span> <span class="n">evaluate</span></div>
</pre></div>

          </div>
        </div>
      </div>

      <div class="clearer"></div>
    </div>
    <div class="footer">
        &copy; Copyright 2002 - 2012 John Hunter, Darren Dale, Eric Firing, Michael Droettboom and the Matplotlib development team; 2012 - 2018 The Matplotlib development team.
        <br />
      Last updated on Jan 05, 2020.
	Created using
	<a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
	Doc version v3.1.1-79-g90d53b526.
    </div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-55954603-1', 'auto');
  ga('send', 'pageview');

</script>
</body>
<footer>
</footer>
</html>