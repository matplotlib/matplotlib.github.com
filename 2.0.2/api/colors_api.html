<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>colors — Matplotlib 2.0.2 documentation</title>
<link href="../_static/mpl.css" rel="stylesheet" type="text/css"/>
<link href="../_static/pygments.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
<script src="../_static/jquery.js" type="text/javascript"></script>
<script src="../_static/underscore.js" type="text/javascript"></script>
<script src="../_static/doctools.js" type="text/javascript"></script>
<link href="../_static/opensearch.xml" rel="search" title="Search within Matplotlib 2.0.2 documentation" type="application/opensearchdescription+xml"/>
<link href="../_static/favicon.ico" rel="shortcut icon"/>
<link href="../genindex.html" rel="index" title="Index"/>
<link href="../search.html" rel="search" title="Search"/>
<link href="../index.html" rel="top" title="Matplotlib 2.0.2 documentation"/>
<link href="index.html" rel="up" title="The Matplotlib API"/>
<link href="container_api.html" rel="next" title="container"/>
<link href="colorbar_api.html" rel="prev" title="colorbar"/>
<link href="https://matplotlib.org/api/colors_api.html" rel="canonical"/></head>
<body><div id="old-version-banner">
            You are reading documentation for a static version of Matplotlib.
            <a href="https://matplotlib.org/api/colors_api.html">This page may have been updated.</a>
</div>
<!-- The "Fork me on github" ribbon -->
<img src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png" style="float: right; margin-bottom: -40px; top: 0; right: 0; border: 0;" usemap="#ribbonmap"/>
<map name="ribbonmap">
<area coords="15,0,148,-1,148,135" href="https://github.com/matplotlib/matplotlib" shape="poly" title="Fork me on GitHub"/>
</map>
<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../index.html"><img alt="matplotlib" border="0" src="../_static/logo2.svg" width="540px"/></a>
</div>
<div class="related">
<h3>Navigation</h3>
<ul>
<li class="right" style="margin-right: 10px">
<a accesskey="I" href="../genindex.html" title="General Index">index</a></li>
<li class="right">
<a href="../py-modindex.html" title="Python Module Index">modules</a> |</li>
<li class="right">
<a accesskey="N" href="container_api.html" title="container">next</a> |</li>
<li class="right">
<a accesskey="P" href="colorbar_api.html" title="colorbar">previous</a> |</li>
<li><a href="../index.html">home</a>| </li>
<li><a href="../examples/index.html">examples</a>| </li>
<li><a href="../gallery.html">gallery</a>| </li>
<li><a href="pyplot_summary.html">pyplot</a>| </li>
<li><a href="../contents.html">docs</a> »</li>
<li><a accesskey="U" href="index.html">The Matplotlib API</a> »</li>
</ul>
</div>
<div class="sphinxsidebar">
<div class="sphinxsidebarwrapper">
<a href="http://depsy.org/package/python/matplotlib">
<img src="../_static/depsy_badge.svg"/>
</a>
<br/>

Travis-CI: <a href="https://travis-ci.org/matplotlib/matplotlib">
<img src="https://travis-ci.org/matplotlib/matplotlib.svg?branch=master"/>
</a>
<br/>
<h3><a href="../contents.html">Table Of Contents</a></h3>
<ul>
<li><a class="reference internal" href="#">colors</a><ul>
<li><a class="reference internal" href="#module-matplotlib.colors"><code class="docutils literal"><span class="pre">matplotlib.colors</span></code></a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
<li><a href="../contents.html">Documentation overview</a><ul>
<li><a href="index.html">The Matplotlib API</a><ul>
<li>Previous: <a href="colorbar_api.html" title="previous chapter">colorbar</a></li>
<li>Next: <a href="container_api.html" title="next chapter">container</a></li>
</ul></li>
</ul></li>
</ul>
</div>
<div aria-label="source link" role="note">
<h3>This Page</h3>
<ul class="this-page-menu">
<li><a href="../_sources/api/colors_api.rst.txt" rel="nofollow">Show Source</a></li>
</ul>
</div>
<div id="searchbox" role="search" style="display: none">
<h3>Quick search</h3>
<form action="../search.html" class="search" method="get">
<div><input name="q" type="text"/></div>
<div><input type="submit" value="Go"/></div>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
</div>
</div>
<div class="document">
<div class="documentwrapper">
<div class="bodywrapper">
<div class="body">
<div class="section" id="colors">
<h1>colors<a class="headerlink" href="#colors" title="Permalink to this headline">¶</a></h1>
<p>For a visual representation of the matplotlib colormaps, see the
“Color” section in the gallery.</p>
<div class="section" id="module-matplotlib.colors">
<span id="matplotlib-colors"></span><h2><a class="reference internal" href="#module-matplotlib.colors" title="matplotlib.colors"><code class="xref py py-mod docutils literal"><span class="pre">matplotlib.colors</span></code></a><a class="headerlink" href="#module-matplotlib.colors" title="Permalink to this headline">¶</a></h2>
<p>A module for converting numbers or color arguments to <em>RGB</em> or <em>RGBA</em></p>
<p><em>RGB</em> and <em>RGBA</em> are sequences of, respectively, 3 or 4 floats in the
range 0-1.</p>
<p>This module includes functions and classes for color specification
conversions, and for mapping numbers to colors in a 1-D array of colors called
a colormap. Colormapping typically involves two steps: a data array is first
mapped onto the range 0-1 using an instance of <a class="reference internal" href="#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code class="xref py py-class docutils literal"><span class="pre">Normalize</span></code></a> or of a
subclass; then this number in the 0-1 range is mapped to a color using an
instance of a subclass of <a class="reference internal" href="#matplotlib.colors.Colormap" title="matplotlib.colors.Colormap"><code class="xref py py-class docutils literal"><span class="pre">Colormap</span></code></a>.  Two are provided here:
<a class="reference internal" href="#matplotlib.colors.LinearSegmentedColormap" title="matplotlib.colors.LinearSegmentedColormap"><code class="xref py py-class docutils literal"><span class="pre">LinearSegmentedColormap</span></code></a>, which is used to generate all the built-in
colormap instances, but is also useful for making custom colormaps, and
<a class="reference internal" href="#matplotlib.colors.ListedColormap" title="matplotlib.colors.ListedColormap"><code class="xref py py-class docutils literal"><span class="pre">ListedColormap</span></code></a>, which is used for generating a custom colormap from a
list of color specifications.</p>
<p>The module also provides functions for checking whether an object can be
interpreted as a color (<a class="reference internal" href="#matplotlib.colors.is_color_like" title="matplotlib.colors.is_color_like"><code class="xref py py-func docutils literal"><span class="pre">is_color_like()</span></code></a>), for converting such an object
to an RGBA tuple (<a class="reference internal" href="#matplotlib.colors.to_rgba" title="matplotlib.colors.to_rgba"><code class="xref py py-func docutils literal"><span class="pre">to_rgba()</span></code></a>) or to an HTML-like hex string in the
<code class="xref py py-obj docutils literal"><span class="pre">#rrggbb</span></code> format (<a class="reference internal" href="#matplotlib.colors.to_hex" title="matplotlib.colors.to_hex"><code class="xref py py-func docutils literal"><span class="pre">to_hex()</span></code></a>), and a sequence of colors to an <code class="xref py py-obj docutils literal"><span class="pre">(n,</span> <span class="pre">4)</span></code>
RGBA array (<a class="reference internal" href="#matplotlib.colors.to_rgba_array" title="matplotlib.colors.to_rgba_array"><code class="xref py py-func docutils literal"><span class="pre">to_rgba_array()</span></code></a>).  Caching is used for efficiency.</p>
<p>Commands which take color arguments can use several formats to specify
the colors.  For the basic built-in colors, you can use a single letter</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref py py-obj docutils literal"><span class="pre">b</span></code>: blue</li>
<li><code class="xref py py-obj docutils literal"><span class="pre">g</span></code>: green</li>
<li><code class="xref py py-obj docutils literal"><span class="pre">r</span></code>: red</li>
<li><code class="xref py py-obj docutils literal"><span class="pre">c</span></code>: cyan</li>
<li><code class="xref py py-obj docutils literal"><span class="pre">m</span></code>: magenta</li>
<li><code class="xref py py-obj docutils literal"><span class="pre">y</span></code>: yellow</li>
<li><code class="xref py py-obj docutils literal"><span class="pre">k</span></code>: black</li>
<li><code class="xref py py-obj docutils literal"><span class="pre">w</span></code>: white</li>
</ul>
</div></blockquote>
<p>To use the colors that are part of the active color cycle in the current style,
use <code class="xref py py-obj docutils literal"><span class="pre">C</span></code> followed by a digit.  For example:</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref py py-obj docutils literal"><span class="pre">C0</span></code>: The first color in the cycle</li>
<li><code class="xref py py-obj docutils literal"><span class="pre">C1</span></code>: The second color in the cycle</li>
</ul>
</div></blockquote>
<p>Gray shades can be given as a string encoding a float in the 0-1 range, e.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">color</span> <span class="o">=</span> <span class="s1">'0.75'</span>
</pre></div>
</div>
<p>For a greater range of colors, you have two options.  You can specify the
color using an html hex string, as in:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">color</span> <span class="o">=</span> <span class="s1">'#eeefff'</span>
</pre></div>
</div>
<p>(possibly specifying an alpha value as well), or you can pass an <code class="xref py py-obj docutils literal"><span class="pre">(r,</span> <span class="pre">g,</span> <span class="pre">b)</span></code>
or <code class="xref py py-obj docutils literal"><span class="pre">(r,</span> <span class="pre">g,</span> <span class="pre">b,</span> <span class="pre">a)</span></code> tuple, where each of <code class="xref py py-obj docutils literal"><span class="pre">r</span></code>, <code class="xref py py-obj docutils literal"><span class="pre">g</span></code>, <code class="xref py py-obj docutils literal"><span class="pre">b</span></code> and <code class="xref py py-obj docutils literal"><span class="pre">a</span></code> are in the range
[0,1].</p>
<p>Finally, legal html names for colors, like ‘red’, ‘burlywood’ and ‘chartreuse’
are supported.</p>
<dl class="class">
<dt id="matplotlib.colors.BoundaryNorm">
<em class="property">class </em><code class="descclassname">matplotlib.colors.</code><code class="descname">BoundaryNorm</code><span class="sig-paren">(</span><em>boundaries</em>, <em>ncolors</em>, <em>clip=False</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.BoundaryNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code class="xref py py-class docutils literal"><span class="pre">matplotlib.colors.Normalize</span></code></a></p>
<p>Generate a colormap index based on discrete intervals.</p>
<p>Unlike <a class="reference internal" href="#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code class="xref py py-class docutils literal"><span class="pre">Normalize</span></code></a> or <a class="reference internal" href="#matplotlib.colors.LogNorm" title="matplotlib.colors.LogNorm"><code class="xref py py-class docutils literal"><span class="pre">LogNorm</span></code></a>,
<a class="reference internal" href="#matplotlib.colors.BoundaryNorm" title="matplotlib.colors.BoundaryNorm"><code class="xref py py-class docutils literal"><span class="pre">BoundaryNorm</span></code></a> maps values to integers instead of to the
interval 0-1.</p>
<p>Mapping to the 0-1 interval could have been done via
piece-wise linear interpolation, but using integers seems
simpler, and reduces the number of conversions back and forth
between integer and floating point.</p>
<dl class="docutils">
<dt><em>boundaries</em></dt>
<dd>a monotonically increasing sequence</dd>
<dt><em>ncolors</em></dt>
<dd>number of colors in the colormap to be used</dd>
</dl>
<p>If:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>then v is mapped to color j;
as i varies from 0 to len(boundaries)-2,
j goes from 0 to ncolors-1.</p>
<p>Out-of-range values are mapped
to -1 if low and ncolors if high; these are converted
to valid indices by
<code class="xref py py-meth docutils literal"><span class="pre">Colormap.__call__()</span></code> .
If clip == True, out-of-range values
are mapped to 0 if low and ncolors-1 if high.</p>
<dl class="method">
<dt id="matplotlib.colors.BoundaryNorm.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.BoundaryNorm.inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
<dl class="class">
<dt id="matplotlib.colors.Colormap">
<em class="property">class </em><code class="descclassname">matplotlib.colors.</code><code class="descname">Colormap</code><span class="sig-paren">(</span><em>name</em>, <em>N=256</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.Colormap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Baseclass for all scalar to RGBA mappings.</p>
<p>Typically Colormap instances are used to convert data values (floats) from
the interval <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">1]</span></code> to the RGBA color that the respective Colormap
represents. For scaling of data into the <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">1]</span></code> interval see
<a class="reference internal" href="#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code class="xref py py-class docutils literal"><span class="pre">matplotlib.colors.Normalize</span></code></a>. It is worth noting that
<a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code class="xref py py-class docutils literal"><span class="pre">matplotlib.cm.ScalarMappable</span></code></a> subclasses make heavy use of this
<code class="docutils literal"><span class="pre">data-&gt;normalize-&gt;map-to-color</span></code> processing chain.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>name</strong> : str</p>
<blockquote>
<div><p>The name of the colormap.</p>
</div></blockquote>
<p><strong>N</strong> : int</p>
<blockquote class="last">
<div><p>The number of rgb quantization levels.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="matplotlib.colors.Colormap.colorbar_extend">
<code class="descname">colorbar_extend</code><em class="property"> = None</em><a class="headerlink" href="#matplotlib.colors.Colormap.colorbar_extend" title="Permalink to this definition">¶</a></dt>
<dd><p>When this colormap exists on a scalar mappable and colorbar_extend
is not False, colorbar creation will pick up <code class="docutils literal"><span class="pre">colorbar_extend</span></code> as
the default value for the <code class="docutils literal"><span class="pre">extend</span></code> keyword in the
<a class="reference internal" href="colorbar_api.html#matplotlib.colorbar.Colorbar" title="matplotlib.colorbar.Colorbar"><code class="xref py py-class docutils literal"><span class="pre">matplotlib.colorbar.Colorbar</span></code></a> constructor.</p>
</dd></dl>
<dl class="method">
<dt id="matplotlib.colors.Colormap.is_gray">
<code class="descname">is_gray</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.Colormap.is_gray" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="method">
<dt id="matplotlib.colors.Colormap.set_bad">
<code class="descname">set_bad</code><span class="sig-paren">(</span><em>color='k'</em>, <em>alpha=None</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.Colormap.set_bad" title="Permalink to this definition">¶</a></dt>
<dd><p>Set color to be used for masked values.</p>
</dd></dl>
<dl class="method">
<dt id="matplotlib.colors.Colormap.set_over">
<code class="descname">set_over</code><span class="sig-paren">(</span><em>color='k'</em>, <em>alpha=None</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.Colormap.set_over" title="Permalink to this definition">¶</a></dt>
<dd><p>Set color to be used for high out-of-range values.
Requires norm.clip = False</p>
</dd></dl>
<dl class="method">
<dt id="matplotlib.colors.Colormap.set_under">
<code class="descname">set_under</code><span class="sig-paren">(</span><em>color='k'</em>, <em>alpha=None</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.Colormap.set_under" title="Permalink to this definition">¶</a></dt>
<dd><p>Set color to be used for low out-of-range values.
Requires norm.clip = False</p>
</dd></dl>
</dd></dl>
<dl class="class">
<dt id="matplotlib.colors.LightSource">
<em class="property">class </em><code class="descclassname">matplotlib.colors.</code><code class="descname">LightSource</code><span class="sig-paren">(</span><em>azdeg=315</em>, <em>altdeg=45</em>, <em>hsv_min_val=0</em>, <em>hsv_max_val=1</em>, <em>hsv_min_sat=1</em>, <em>hsv_max_sat=0</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.LightSource" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Create a light source coming from the specified azimuth and elevation.
Angles are in degrees, with the azimuth measured
clockwise from north and elevation up from the zero plane of the surface.</p>
<p>The <a class="reference internal" href="#matplotlib.colors.LightSource.shade" title="matplotlib.colors.LightSource.shade"><code class="xref py py-meth docutils literal"><span class="pre">shade()</span></code></a> is used to produce “shaded” rgb values for a data array.
<a class="reference internal" href="#matplotlib.colors.LightSource.shade_rgb" title="matplotlib.colors.LightSource.shade_rgb"><code class="xref py py-meth docutils literal"><span class="pre">shade_rgb()</span></code></a> can be used to combine an rgb image with
The <a class="reference internal" href="#matplotlib.colors.LightSource.shade_rgb" title="matplotlib.colors.LightSource.shade_rgb"><code class="xref py py-meth docutils literal"><span class="pre">shade_rgb()</span></code></a>
The <a class="reference internal" href="#matplotlib.colors.LightSource.hillshade" title="matplotlib.colors.LightSource.hillshade"><code class="xref py py-meth docutils literal"><span class="pre">hillshade()</span></code></a> produces an illumination map of a surface.</p>
<p>Specify the azimuth (measured clockwise from south) and altitude
(measured up from the plane of the surface) of the light source
in degrees.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>azdeg</strong> : number, optional</p>
<blockquote>
<div><p>The azimuth (0-360, degrees clockwise from North) of the light
source. Defaults to 315 degrees (from the northwest).</p>
</div></blockquote>
<p><strong>altdeg</strong> : number, optional</p>
<blockquote class="last">
<div><p>The altitude (0-90, degrees up from horizontal) of the light
source.  Defaults to 45 degrees from horizontal.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For backwards compatibility, the parameters <em>hsv_min_val</em>,
<em>hsv_max_val</em>, <em>hsv_min_sat</em>, and <em>hsv_max_sat</em> may be supplied at
initialization as well.  However, these parameters will only be used if
“blend_mode=’hsv’” is passed into <a class="reference internal" href="#matplotlib.colors.LightSource.shade" title="matplotlib.colors.LightSource.shade"><code class="xref py py-meth docutils literal"><span class="pre">shade()</span></code></a> or <a class="reference internal" href="#matplotlib.colors.LightSource.shade_rgb" title="matplotlib.colors.LightSource.shade_rgb"><code class="xref py py-meth docutils literal"><span class="pre">shade_rgb()</span></code></a>.
See the documentation for <a class="reference internal" href="#matplotlib.colors.LightSource.blend_hsv" title="matplotlib.colors.LightSource.blend_hsv"><code class="xref py py-meth docutils literal"><span class="pre">blend_hsv()</span></code></a> for more details.</p>
<dl class="method">
<dt id="matplotlib.colors.LightSource.blend_hsv">
<code class="descname">blend_hsv</code><span class="sig-paren">(</span><em>rgb</em>, <em>intensity</em>, <em>hsv_max_sat=None</em>, <em>hsv_max_val=None</em>, <em>hsv_min_val=None</em>, <em>hsv_min_sat=None</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.LightSource.blend_hsv" title="Permalink to this definition">¶</a></dt>
<dd><p>Take the input data array, convert to HSV values in the given colormap,
then adjust those color values to give the impression of a shaded
relief map with a specified light source.  RGBA values are returned,
which can then be used to plot the shaded image with imshow.</p>
<p>The color of the resulting image will be darkened by moving the (s,v)
values (in hsv colorspace) toward (hsv_min_sat, hsv_min_val) in the
shaded regions, or lightened by sliding (s,v) toward (hsv_max_sat
hsv_max_val) in regions that are illuminated.  The default extremes are
chose so that completely shaded points are nearly black (s = 1, v = 0)
and completely illuminated points are nearly white (s = 0, v = 1).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rgb</strong> : ndarray</p>
<blockquote>
<div><p>An MxNx3 RGB array of floats ranging from 0 to 1 (color image).</p>
</div></blockquote>
<p><strong>intensity</strong> : ndarray</p>
<blockquote>
<div><p>An MxNx1 array of floats ranging from 0 to 1 (grayscale image).</p>
</div></blockquote>
<p><strong>hsv_max_sat</strong> : number, optional</p>
<blockquote>
<div><p>The maximum saturation value that the <em>intensity</em> map can shift the
output image to. Defaults to 1.</p>
</div></blockquote>
<p><strong>hsv_min_sat</strong> : number, optional</p>
<blockquote>
<div><p>The minimum saturation value that the <em>intensity</em> map can shift the
output image to. Defaults to 0.</p>
</div></blockquote>
<p><strong>hsv_max_val</strong> : number, optional</p>
<blockquote>
<div><p>The maximum value (“v” in “hsv”) that the <em>intensity</em> map can shift
the output image to. Defaults to 1.</p>
</div></blockquote>
<p><strong>hsv_min_val: number, optional</strong></p>
<blockquote>
<div><p>The minimum value (“v” in “hsv”) that the <em>intensity</em> map can shift
the output image to. Defaults to 0.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>rgb</strong> : ndarray</p>
<blockquote class="last">
<div><p>An MxNx3 RGB array representing the combined images.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="method">
<dt id="matplotlib.colors.LightSource.blend_overlay">
<code class="descname">blend_overlay</code><span class="sig-paren">(</span><em>rgb</em>, <em>intensity</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.LightSource.blend_overlay" title="Permalink to this definition">¶</a></dt>
<dd><p>Combines an rgb image with an intensity map using “overlay” blending.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rgb</strong> : ndarray</p>
<blockquote>
<div><p>An MxNx3 RGB array of floats ranging from 0 to 1 (color image).</p>
</div></blockquote>
<p><strong>intensity</strong> : ndarray</p>
<blockquote>
<div><p>An MxNx1 array of floats ranging from 0 to 1 (grayscale image).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>rgb</strong> : ndarray</p>
<blockquote class="last">
<div><p>An MxNx3 RGB array representing the combined images.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="method">
<dt id="matplotlib.colors.LightSource.blend_soft_light">
<code class="descname">blend_soft_light</code><span class="sig-paren">(</span><em>rgb</em>, <em>intensity</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.LightSource.blend_soft_light" title="Permalink to this definition">¶</a></dt>
<dd><p>Combines an rgb image with an intensity map using “soft light”
blending.  Uses the “pegtop” formula.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rgb</strong> : ndarray</p>
<blockquote>
<div><p>An MxNx3 RGB array of floats ranging from 0 to 1 (color image).</p>
</div></blockquote>
<p><strong>intensity</strong> : ndarray</p>
<blockquote>
<div><p>An MxNx1 array of floats ranging from 0 to 1 (grayscale image).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>rgb</strong> : ndarray</p>
<blockquote class="last">
<div><p>An MxNx3 RGB array representing the combined images.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="method">
<dt id="matplotlib.colors.LightSource.hillshade">
<code class="descname">hillshade</code><span class="sig-paren">(</span><em>elevation</em>, <em>vert_exag=1</em>, <em>dx=1</em>, <em>dy=1</em>, <em>fraction=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.LightSource.hillshade" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the illumination intensity for a surface using the defined
azimuth and elevation for the light source.</p>
<p>Imagine an artificial sun placed at infinity in some azimuth and
elevation position illuminating our surface. The parts of the surface
that slope toward the sun should brighten while those sides facing away
should become darker.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>elevation</strong> : array-like</p>
<blockquote>
<div><p>A 2d array (or equivalent) of the height values used to generate an
illumination map</p>
</div></blockquote>
<p><strong>vert_exag</strong> : number, optional</p>
<blockquote>
<div><p>The amount to exaggerate the elevation values by when calculating
illumination. This can be used either to correct for differences in
units between the x-y coordinate system and the elevation
coordinate system (e.g. decimal degrees vs meters) or to exaggerate
or de-emphasize topographic effects.</p>
</div></blockquote>
<p><strong>dx</strong> : number, optional</p>
<blockquote>
<div><p>The x-spacing (columns) of the input <em>elevation</em> grid.</p>
</div></blockquote>
<p><strong>dy</strong> : number, optional</p>
<blockquote>
<div><p>The y-spacing (rows) of the input <em>elevation</em> grid.</p>
</div></blockquote>
<p><strong>fraction</strong> : number, optional</p>
<blockquote>
<div><p>Increases or decreases the contrast of the hillshade.  Values
greater than one will cause intermediate values to move closer to
full illumination or shadow (and clipping any values that move
beyond 0 or 1). Note that this is not visually or mathematically
the same as vertical exaggeration.</p>
</div></blockquote>
<p><strong>Returns</strong></p>
<p><strong>——-</strong></p>
<p><strong>intensity</strong> : ndarray</p>
<blockquote class="last">
<div><p>A 2d array of illumination values between 0-1, where 0 is
completely in shadow and 1 is completely illuminated.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="method">
<dt id="matplotlib.colors.LightSource.shade">
<code class="descname">shade</code><span class="sig-paren">(</span><em>data</em>, <em>cmap</em>, <em>norm=None</em>, <em>blend_mode='overlay'</em>, <em>vmin=None</em>, <em>vmax=None</em>, <em>vert_exag=1</em>, <em>dx=1</em>, <em>dy=1</em>, <em>fraction=1</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.LightSource.shade" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine colormapped data values with an illumination intensity map
(a.k.a.  “hillshade”) of the values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : array-like</p>
<blockquote>
<div><p>A 2d array (or equivalent) of the height values used to generate a
shaded map.</p>
</div></blockquote>
<p><strong>cmap</strong> : <a class="reference internal" href="#matplotlib.colors.Colormap" title="matplotlib.colors.Colormap"><code class="xref py py-obj docutils literal"><span class="pre">Colormap</span></code></a> instance</p>
<blockquote>
<div><p>The colormap used to color the <em>data</em> array. Note that this must be
a <a class="reference internal" href="#matplotlib.colors.Colormap" title="matplotlib.colors.Colormap"><code class="xref py py-obj docutils literal"><span class="pre">Colormap</span></code></a> instance.  For example, rather than
passing in <code class="xref py py-obj docutils literal"><span class="pre">cmap='gist_earth'</span></code>, use
<code class="xref py py-obj docutils literal"><span class="pre">cmap=plt.get_cmap('gist_earth')</span></code> instead.</p>
</div></blockquote>
<p><strong>norm</strong> : <a class="reference internal" href="#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code class="xref py py-obj docutils literal"><span class="pre">Normalize</span></code></a> instance, optional</p>
<blockquote>
<div><p>The normalization used to scale values before colormapping. If
None, the input will be linearly scaled between its min and max.</p>
</div></blockquote>
<p><strong>blend_mode</strong> : {‘hsv’, ‘overlay’, ‘soft’} or callable, optional</p>
<blockquote>
<div><p>The type of blending used to combine the colormapped data
values with the illumination intensity.  Default is
“overlay”.  Note that for most topographic surfaces,
“overlay” or “soft” appear more visually realistic. If a
user-defined function is supplied, it is expected to
combine an MxNx3 RGB array of floats (ranging 0 to 1) with
an MxNx1 hillshade array (also 0 to 1).  (Call signature
<code class="xref py py-obj docutils literal"><span class="pre">func(rgb,</span> <span class="pre">illum,</span> <span class="pre">**kwargs)</span></code>) Additional kwargs supplied
to this function will be passed on to the <em>blend_mode</em>
function.</p>
</div></blockquote>
<p><strong>vmin</strong> : scalar or None, optional</p>
<blockquote>
<div><p>The minimum value used in colormapping <em>data</em>. If <em>None</em> the
minimum value in <em>data</em> is used. If <em>norm</em> is specified, then this
argument will be ignored.</p>
</div></blockquote>
<p><strong>vmax</strong> : scalar or None, optional</p>
<blockquote>
<div><p>The maximum value used in colormapping <em>data</em>. If <em>None</em> the
maximum value in <em>data</em> is used. If <em>norm</em> is specified, then this
argument will be ignored.</p>
</div></blockquote>
<p><strong>vert_exag</strong> : number, optional</p>
<blockquote>
<div><p>The amount to exaggerate the elevation values by when calculating
illumination. This can be used either to correct for differences in
units between the x-y coordinate system and the elevation
coordinate system (e.g. decimal degrees vs meters) or to exaggerate
or de-emphasize topography.</p>
</div></blockquote>
<p><strong>dx</strong> : number, optional</p>
<blockquote>
<div><p>The x-spacing (columns) of the input <em>elevation</em> grid.</p>
</div></blockquote>
<p><strong>dy</strong> : number, optional</p>
<blockquote>
<div><p>The y-spacing (rows) of the input <em>elevation</em> grid.</p>
</div></blockquote>
<p><strong>fraction</strong> : number, optional</p>
<blockquote>
<div><p>Increases or decreases the contrast of the hillshade.  Values
greater than one will cause intermediate values to move closer to
full illumination or shadow (and clipping any values that move
beyond 0 or 1). Note that this is not visually or mathematically
the same as vertical exaggeration.</p>
</div></blockquote>
<p><strong>Additional kwargs are passed on to the *blend_mode* function.</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>rgba</strong> : ndarray</p>
<blockquote class="last">
<div><p>An MxNx4 array of floats ranging between 0-1.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="method">
<dt id="matplotlib.colors.LightSource.shade_rgb">
<code class="descname">shade_rgb</code><span class="sig-paren">(</span><em>rgb</em>, <em>elevation</em>, <em>fraction=1.0</em>, <em>blend_mode='hsv'</em>, <em>vert_exag=1</em>, <em>dx=1</em>, <em>dy=1</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.LightSource.shade_rgb" title="Permalink to this definition">¶</a></dt>
<dd><p>Take the input RGB array (ny*nx*3) adjust their color values
to given the impression of a shaded relief map with a
specified light source using the elevation (ny*nx).
A new RGB array ((ny*nx*3)) is returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rgb</strong> : array-like</p>
<blockquote>
<div><p>An MxNx3 RGB array, assumed to be in the range of 0 to 1.</p>
</div></blockquote>
<p><strong>elevation</strong> : array-like</p>
<blockquote>
<div><p>A 2d array (or equivalent) of the height values used to generate a
shaded map.</p>
</div></blockquote>
<p><strong>fraction</strong> : number</p>
<blockquote>
<div><p>Increases or decreases the contrast of the hillshade.  Values
greater than one will cause intermediate values to move closer to
full illumination or shadow (and clipping any values that move
beyond 0 or 1). Note that this is not visually or mathematically
the same as vertical exaggeration.</p>
</div></blockquote>
<p><strong>blend_mode</strong> : {‘hsv’, ‘overlay’, ‘soft’} or callable, optional</p>
<blockquote>
<div><p>The type of blending used to combine the colormapped data values
with the illumination intensity.  For backwards compatibility, this
defaults to “hsv”. Note that for most topographic surfaces,
“overlay” or “soft” appear more visually realistic. If a
user-defined function is supplied, it is expected to combine an
MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade
array (also 0 to 1).  (Call signature <code class="xref py py-obj docutils literal"><span class="pre">func(rgb,</span> <span class="pre">illum,</span> <span class="pre">**kwargs)</span></code>)
Additional kwargs supplied to this function will be passed on to
the <em>blend_mode</em> function.</p>
</div></blockquote>
<p><strong>vert_exag</strong> : number, optional</p>
<blockquote>
<div><p>The amount to exaggerate the elevation values by when calculating
illumination. This can be used either to correct for differences in
units between the x-y coordinate system and the elevation
coordinate system (e.g. decimal degrees vs meters) or to exaggerate
or de-emphasize topography.</p>
</div></blockquote>
<p><strong>dx</strong> : number, optional</p>
<blockquote>
<div><p>The x-spacing (columns) of the input <em>elevation</em> grid.</p>
</div></blockquote>
<p><strong>dy</strong> : number, optional</p>
<blockquote>
<div><p>The y-spacing (rows) of the input <em>elevation</em> grid.</p>
</div></blockquote>
<p><strong>Additional kwargs are passed on to the *blend_mode* function.</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>shaded_rgb</strong> : ndarray</p>
<blockquote class="last">
<div><p>An MxNx3 array of floats ranging between 0-1.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>
</dd></dl>
<dl class="class">
<dt id="matplotlib.colors.LinearSegmentedColormap">
<em class="property">class </em><code class="descclassname">matplotlib.colors.</code><code class="descname">LinearSegmentedColormap</code><span class="sig-paren">(</span><em>name</em>, <em>segmentdata</em>, <em>N=256</em>, <em>gamma=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.LinearSegmentedColormap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.colors.Colormap" title="matplotlib.colors.Colormap"><code class="xref py py-class docutils literal"><span class="pre">matplotlib.colors.Colormap</span></code></a></p>
<p>Colormap objects based on lookup tables using linear segments.</p>
<p>The lookup table is generated using linear interpolation for each
primary color, with the 0-1 domain divided into any number of
segments.</p>
<p>Create color map from linear mapping segments</p>
<p>segmentdata argument is a dictionary with a red, green and blue
entries. Each entry should be a list of <em>x</em>, <em>y0</em>, <em>y1</em> tuples,
forming rows in a table. Entries for alpha are optional.</p>
<p>Example: suppose you want red to increase from 0 to 1 over
the bottom half, green to do the same over the middle half,
and blue over the top half.  Then you would use:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">cdict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'red'</span><span class="p">:</span>   <span class="p">[(</span><span class="mf">0.0</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
                   <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
                   <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)],</span>

         <span class="s1">'green'</span><span class="p">:</span> <span class="p">[(</span><span class="mf">0.0</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
                   <span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
                   <span class="p">(</span><span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
                   <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)],</span>

         <span class="s1">'blue'</span><span class="p">:</span>  <span class="p">[(</span><span class="mf">0.0</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
                   <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
                   <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)]}</span>
</pre></div>
</div>
<p>Each row in the table for a given color is a sequence of
<em>x</em>, <em>y0</em>, <em>y1</em> tuples.  In each sequence, <em>x</em> must increase
monotonically from 0 to 1.  For any input value <em>z</em> falling
between <em>x[i]</em> and <em>x[i+1]</em>, the output value of a given color
will be linearly interpolated between <em>y1[i]</em> and <em>y0[i+1]</em>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">row</span> <span class="n">i</span><span class="p">:</span>   <span class="n">x</span>  <span class="n">y0</span>  <span class="n">y1</span>
               <span class="o">/</span>
              <span class="o">/</span>
<span class="n">row</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span> <span class="n">x</span>  <span class="n">y0</span>  <span class="n">y1</span>
</pre></div>
</div>
<p>Hence y0 in the first row and y1 in the last row are never used.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><a class="reference internal" href="#matplotlib.colors.LinearSegmentedColormap.from_list" title="matplotlib.colors.LinearSegmentedColormap.from_list"><code class="xref py py-meth docutils literal"><span class="pre">LinearSegmentedColormap.from_list()</span></code></a>
Static method; factory function for generating a
smoothly-varying LinearSegmentedColormap.</p>
<p class="last"><a class="reference internal" href="#matplotlib.colors.makeMappingArray" title="matplotlib.colors.makeMappingArray"><code class="xref py py-func docutils literal"><span class="pre">makeMappingArray()</span></code></a>
For information about making a mapping array.</p>
</div>
<dl class="staticmethod">
<dt id="matplotlib.colors.LinearSegmentedColormap.from_list">
<em class="property">static </em><code class="descname">from_list</code><span class="sig-paren">(</span><em>name</em>, <em>colors</em>, <em>N=256</em>, <em>gamma=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.LinearSegmentedColormap.from_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a linear segmented colormap with <em>name</em> from a sequence
of <em>colors</em> which evenly transitions from colors[0] at val=0
to colors[-1] at val=1.  <em>N</em> is the number of rgb quantization
levels.
Alternatively, a list of (value, color) tuples can be given
to divide the range unevenly.</p>
</dd></dl>
<dl class="method">
<dt id="matplotlib.colors.LinearSegmentedColormap.set_gamma">
<code class="descname">set_gamma</code><span class="sig-paren">(</span><em>gamma</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.LinearSegmentedColormap.set_gamma" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a new gamma value and regenerate color map.</p>
</dd></dl>
</dd></dl>
<dl class="class">
<dt id="matplotlib.colors.ListedColormap">
<em class="property">class </em><code class="descclassname">matplotlib.colors.</code><code class="descname">ListedColormap</code><span class="sig-paren">(</span><em>colors</em>, <em>name='from_list'</em>, <em>N=None</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.ListedColormap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.colors.Colormap" title="matplotlib.colors.Colormap"><code class="xref py py-class docutils literal"><span class="pre">matplotlib.colors.Colormap</span></code></a></p>
<p>Colormap object generated from a list of colors.</p>
<p>This may be most useful when indexing directly into a colormap,
but it can also be used to generate special colormaps for ordinary
mapping.</p>
<p>Make a colormap from a list of colors.</p>
<dl class="docutils">
<dt><em>colors</em></dt>
<dd>a list of matplotlib color specifications,
or an equivalent Nx3 or Nx4 floating point array
(<em>N</em> rgb or rgba values)</dd>
<dt><em>name</em></dt>
<dd>a string to identify the colormap</dd>
<dt><em>N</em></dt>
<dd><p class="first">the number of entries in the map.  The default is <em>None</em>,
in which case there is one colormap entry for each
element in the list of colors.  If:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>
</pre></div>
</div>
<p>the list will be truncated at <em>N</em>.  If:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">the list will be extended by repetition.</p>
</dd>
</dl>
</dd></dl>
<dl class="class">
<dt id="matplotlib.colors.LogNorm">
<em class="property">class </em><code class="descclassname">matplotlib.colors.</code><code class="descname">LogNorm</code><span class="sig-paren">(</span><em>vmin=None</em>, <em>vmax=None</em>, <em>clip=False</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.LogNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code class="xref py py-class docutils literal"><span class="pre">matplotlib.colors.Normalize</span></code></a></p>
<p>Normalize a given value to the 0-1 range on a log scale</p>
<p>If <em>vmin</em> or <em>vmax</em> is not given, they are initialized from the
minimum and maximum value respectively of the first input
processed.  That is, <em>__call__(A)</em> calls <em>autoscale_None(A)</em>.
If <em>clip</em> is <em>True</em> and the given value falls outside the range,
the returned value will be 0 or 1, whichever is closer.
Returns 0 if:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">vmin</span><span class="o">==</span><span class="n">vmax</span>
</pre></div>
</div>
<p>Works with scalars or arrays, including masked arrays.  If
<em>clip</em> is <em>True</em>, masked values are set to 1; otherwise they
remain masked.  Clipping silently defeats the purpose of setting
the over, under, and masked colors in the colormap, so it is
likely to lead to surprises; therefore the default is
<em>clip</em> = <em>False</em>.</p>
<dl class="method">
<dt id="matplotlib.colors.LogNorm.autoscale">
<code class="descname">autoscale</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.LogNorm.autoscale" title="Permalink to this definition">¶</a></dt>
<dd><p>Set <em>vmin</em>, <em>vmax</em> to min, max of <em>A</em>.</p>
</dd></dl>
<dl class="method">
<dt id="matplotlib.colors.LogNorm.autoscale_None">
<code class="descname">autoscale_None</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.LogNorm.autoscale_None" title="Permalink to this definition">¶</a></dt>
<dd><p>autoscale only None-valued vmin or vmax</p>
</dd></dl>
<dl class="method">
<dt id="matplotlib.colors.LogNorm.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.LogNorm.inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
<dl class="class">
<dt id="matplotlib.colors.NoNorm">
<em class="property">class </em><code class="descclassname">matplotlib.colors.</code><code class="descname">NoNorm</code><span class="sig-paren">(</span><em>vmin=None</em>, <em>vmax=None</em>, <em>clip=False</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.NoNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code class="xref py py-class docutils literal"><span class="pre">matplotlib.colors.Normalize</span></code></a></p>
<p>Dummy replacement for Normalize, for the case where we
want to use indices directly in a
<a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><code class="xref py py-class docutils literal"><span class="pre">ScalarMappable</span></code></a> .</p>
<p>If <em>vmin</em> or <em>vmax</em> is not given, they are initialized from the
minimum and maximum value respectively of the first input
processed.  That is, <em>__call__(A)</em> calls <em>autoscale_None(A)</em>.
If <em>clip</em> is <em>True</em> and the given value falls outside the range,
the returned value will be 0 or 1, whichever is closer.
Returns 0 if:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">vmin</span><span class="o">==</span><span class="n">vmax</span>
</pre></div>
</div>
<p>Works with scalars or arrays, including masked arrays.  If
<em>clip</em> is <em>True</em>, masked values are set to 1; otherwise they
remain masked.  Clipping silently defeats the purpose of setting
the over, under, and masked colors in the colormap, so it is
likely to lead to surprises; therefore the default is
<em>clip</em> = <em>False</em>.</p>
<dl class="method">
<dt id="matplotlib.colors.NoNorm.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.NoNorm.inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
<dl class="class">
<dt id="matplotlib.colors.Normalize">
<em class="property">class </em><code class="descclassname">matplotlib.colors.</code><code class="descname">Normalize</code><span class="sig-paren">(</span><em>vmin=None</em>, <em>vmax=None</em>, <em>clip=False</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.Normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>A class which, when called, can normalize data into
the <code class="docutils literal"><span class="pre">[0.0,</span> <span class="pre">1.0]</span></code> interval.</p>
<p>If <em>vmin</em> or <em>vmax</em> is not given, they are initialized from the
minimum and maximum value respectively of the first input
processed.  That is, <em>__call__(A)</em> calls <em>autoscale_None(A)</em>.
If <em>clip</em> is <em>True</em> and the given value falls outside the range,
the returned value will be 0 or 1, whichever is closer.
Returns 0 if:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">vmin</span><span class="o">==</span><span class="n">vmax</span>
</pre></div>
</div>
<p>Works with scalars or arrays, including masked arrays.  If
<em>clip</em> is <em>True</em>, masked values are set to 1; otherwise they
remain masked.  Clipping silently defeats the purpose of setting
the over, under, and masked colors in the colormap, so it is
likely to lead to surprises; therefore the default is
<em>clip</em> = <em>False</em>.</p>
<dl class="method">
<dt id="matplotlib.colors.Normalize.autoscale">
<code class="descname">autoscale</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.Normalize.autoscale" title="Permalink to this definition">¶</a></dt>
<dd><p>Set <em>vmin</em>, <em>vmax</em> to min, max of <em>A</em>.</p>
</dd></dl>
<dl class="method">
<dt id="matplotlib.colors.Normalize.autoscale_None">
<code class="descname">autoscale_None</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.Normalize.autoscale_None" title="Permalink to this definition">¶</a></dt>
<dd><p>autoscale only None-valued vmin or vmax</p>
</dd></dl>
<dl class="method">
<dt id="matplotlib.colors.Normalize.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.Normalize.inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
<dl class="staticmethod">
<dt id="matplotlib.colors.Normalize.process_value">
<em class="property">static </em><code class="descname">process_value</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.Normalize.process_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Homogenize the input <em>value</em> for easy and efficient normalization.</p>
<p><em>value</em> can be a scalar or sequence.</p>
<p>Returns <em>result</em>, <em>is_scalar</em>, where <em>result</em> is a
masked array matching <em>value</em>.  Float dtypes are preserved;
integer types with two bytes or smaller are converted to
np.float32, and larger types are converted to np.float.
Preserving float32 when possible, and using in-place operations,
can greatly improve speed for large arrays.</p>
<p>Experimental; we may want to add an option to force the
use of float32.</p>
</dd></dl>
<dl class="method">
<dt id="matplotlib.colors.Normalize.scaled">
<code class="descname">scaled</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.Normalize.scaled" title="Permalink to this definition">¶</a></dt>
<dd><p>return true if vmin and vmax set</p>
</dd></dl>
</dd></dl>
<dl class="class">
<dt id="matplotlib.colors.PowerNorm">
<em class="property">class </em><code class="descclassname">matplotlib.colors.</code><code class="descname">PowerNorm</code><span class="sig-paren">(</span><em>gamma</em>, <em>vmin=None</em>, <em>vmax=None</em>, <em>clip=False</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.PowerNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code class="xref py py-class docutils literal"><span class="pre">matplotlib.colors.Normalize</span></code></a></p>
<p>Normalize a given value to the <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">1]</span></code> interval with a power-law
scaling. This will clip any negative data points to 0.</p>
<dl class="method">
<dt id="matplotlib.colors.PowerNorm.autoscale">
<code class="descname">autoscale</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.PowerNorm.autoscale" title="Permalink to this definition">¶</a></dt>
<dd><p>Set <em>vmin</em>, <em>vmax</em> to min, max of <em>A</em>.</p>
</dd></dl>
<dl class="method">
<dt id="matplotlib.colors.PowerNorm.autoscale_None">
<code class="descname">autoscale_None</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.PowerNorm.autoscale_None" title="Permalink to this definition">¶</a></dt>
<dd><p>autoscale only None-valued vmin or vmax</p>
</dd></dl>
<dl class="method">
<dt id="matplotlib.colors.PowerNorm.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.PowerNorm.inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
<dl class="class">
<dt id="matplotlib.colors.SymLogNorm">
<em class="property">class </em><code class="descclassname">matplotlib.colors.</code><code class="descname">SymLogNorm</code><span class="sig-paren">(</span><em>linthresh</em>, <em>linscale=1.0</em>, <em>vmin=None</em>, <em>vmax=None</em>, <em>clip=False</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.SymLogNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code class="xref py py-class docutils literal"><span class="pre">matplotlib.colors.Normalize</span></code></a></p>
<p>The symmetrical logarithmic scale is logarithmic in both the
positive and negative directions from the origin.</p>
<p>Since the values close to zero tend toward infinity, there is a
need to have a range around zero that is linear.  The parameter
<em>linthresh</em> allows the user to specify the size of this range
(-<em>linthresh</em>, <em>linthresh</em>).</p>
<p><em>linthresh</em>:
The range within which the plot is linear (to
avoid having the plot go to infinity around zero).</p>
<p><em>linscale</em>:
This allows the linear range (-<em>linthresh</em> to <em>linthresh</em>)
to be stretched relative to the logarithmic range.  Its
value is the number of decades to use for each half of the
linear range.  For example, when <em>linscale</em> == 1.0 (the
default), the space used for the positive and negative
halves of the linear range will be equal to one decade in
the logarithmic range. Defaults to 1.</p>
<dl class="method">
<dt id="matplotlib.colors.SymLogNorm.autoscale">
<code class="descname">autoscale</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.SymLogNorm.autoscale" title="Permalink to this definition">¶</a></dt>
<dd><p>Set <em>vmin</em>, <em>vmax</em> to min, max of <em>A</em>.</p>
</dd></dl>
<dl class="method">
<dt id="matplotlib.colors.SymLogNorm.autoscale_None">
<code class="descname">autoscale_None</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.SymLogNorm.autoscale_None" title="Permalink to this definition">¶</a></dt>
<dd><p>autoscale only None-valued vmin or vmax</p>
</dd></dl>
<dl class="method">
<dt id="matplotlib.colors.SymLogNorm.inverse">
<code class="descname">inverse</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.SymLogNorm.inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>
</dd></dl>
<dl class="function">
<dt id="matplotlib.colors.from_levels_and_colors">
<code class="descclassname">matplotlib.colors.</code><code class="descname">from_levels_and_colors</code><span class="sig-paren">(</span><em>levels</em>, <em>colors</em>, <em>extend='neither'</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.from_levels_and_colors" title="Permalink to this definition">¶</a></dt>
<dd><p>A helper routine to generate a cmap and a norm instance which
behave similar to contourf’s levels and colors arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>levels</strong> : sequence of numbers</p>
<blockquote>
<div><p>The quantization levels used to construct the <a class="reference internal" href="#matplotlib.colors.BoundaryNorm" title="matplotlib.colors.BoundaryNorm"><code class="xref py py-class docutils literal"><span class="pre">BoundaryNorm</span></code></a>.
Values <code class="docutils literal"><span class="pre">v</span></code> are quantizized to level <code class="docutils literal"><span class="pre">i</span></code> if
<code class="docutils literal"><span class="pre">lev[i]</span> <span class="pre">&lt;=</span> <span class="pre">v</span> <span class="pre">&lt;</span> <span class="pre">lev[i+1]</span></code>.</p>
</div></blockquote>
<p><strong>colors</strong> : sequence of colors</p>
<blockquote>
<div><p>The fill color to use for each level. If <code class="xref py py-obj docutils literal"><span class="pre">extend</span></code> is “neither” there
must be <code class="docutils literal"><span class="pre">n_level</span> <span class="pre">-</span> <span class="pre">1</span></code> colors. For an <code class="xref py py-obj docutils literal"><span class="pre">extend</span></code> of “min” or “max” add
one extra color, and for an <code class="xref py py-obj docutils literal"><span class="pre">extend</span></code> of “both” add two colors.</p>
</div></blockquote>
<p><strong>extend</strong> : {‘neither’, ‘min’, ‘max’, ‘both’}, optional</p>
<blockquote>
<div><p>The behaviour when a value falls out of range of the given levels.
See <a class="reference internal" href="pyplot_api.html#matplotlib.pyplot.contourf" title="matplotlib.pyplot.contourf"><code class="xref py py-func docutils literal"><span class="pre">contourf()</span></code></a> for details.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>(cmap, norm)</strong> : tuple containing a <a class="reference internal" href="#matplotlib.colors.Colormap" title="matplotlib.colors.Colormap"><code class="xref py py-class docutils literal"><span class="pre">Colormap</span></code></a> and a                    <a class="reference internal" href="#matplotlib.colors.Normalize" title="matplotlib.colors.Normalize"><code class="xref py py-class docutils literal"><span class="pre">Normalize</span></code></a> instance</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="matplotlib.colors.get_named_colors_mapping">
<code class="descclassname">matplotlib.colors.</code><code class="descname">get_named_colors_mapping</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.get_named_colors_mapping" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the global mapping of names to named colors.</p>
</dd></dl>
<dl class="function">
<dt id="matplotlib.colors.hsv_to_rgb">
<code class="descclassname">matplotlib.colors.</code><code class="descname">hsv_to_rgb</code><span class="sig-paren">(</span><em>hsv</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.hsv_to_rgb" title="Permalink to this definition">¶</a></dt>
<dd><p>convert hsv values in a numpy array to rgb values
all values assumed to be in range [0, 1]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>hsv</strong> : (..., 3) array-like</p>
<blockquote>
<div><p>All values assumed to be in range [0, 1]</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>rgb</strong> : (..., 3) ndarray</p>
<blockquote class="last">
<div><p>Colors converted to RGB values in range [0, 1]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="matplotlib.colors.is_color_like">
<code class="descclassname">matplotlib.colors.</code><code class="descname">is_color_like</code><span class="sig-paren">(</span><em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.is_color_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether <code class="xref py py-obj docutils literal"><span class="pre">c</span></code> can be interpreted as an RGB(A) color.</p>
</dd></dl>
<dl class="function">
<dt id="matplotlib.colors.makeMappingArray">
<code class="descclassname">matplotlib.colors.</code><code class="descname">makeMappingArray</code><span class="sig-paren">(</span><em>N</em>, <em>data</em>, <em>gamma=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.makeMappingArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an <em>N</em> -element 1-d lookup table</p>
<p><em>data</em> represented by a list of x,y0,y1 mapping correspondences.
Each element in this list represents how a value between 0 and 1
(inclusive) represented by x is mapped to a corresponding value
between 0 and 1 (inclusive). The two values of y are to allow
for discontinuous mapping functions (say as might be found in a
sawtooth) where y0 represents the value of y for values of x
&lt;= to that given, and y1 is the value to be used for x &gt; than
that given). The list must start with x=0, end with x=1, and
all values of x must be in increasing order. Values between
the given mapping points are determined by simple linear interpolation.</p>
<p>Alternatively, data can be a function mapping values between 0 - 1
to 0 - 1.</p>
<p>The function returns an array “result” where <code class="docutils literal"><span class="pre">result[x*(N-1)]</span></code>
gives the closest value for values of x between 0 and 1.</p>
</dd></dl>
<dl class="function">
<dt id="matplotlib.colors.rgb_to_hsv">
<code class="descclassname">matplotlib.colors.</code><code class="descname">rgb_to_hsv</code><span class="sig-paren">(</span><em>arr</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.rgb_to_hsv" title="Permalink to this definition">¶</a></dt>
<dd><p>convert float rgb values (in the range [0, 1]), in a numpy array to hsv
values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name"/>
<col class="field-body"/>
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>arr</strong> : (..., 3) array-like</p>
<blockquote>
<div><p>All values must be in the range [0, 1]</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>hsv</strong> : (..., 3) ndarray</p>
<blockquote class="last">
<div><p>Colors converted to hsv values in range [0, 1]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="function">
<dt id="matplotlib.colors.to_hex">
<code class="descclassname">matplotlib.colors.</code><code class="descname">to_hex</code><span class="sig-paren">(</span><em>c</em>, <em>keep_alpha=False</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.to_hex" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert <code class="xref py py-obj docutils literal"><span class="pre">c</span></code> to a hex color.</p>
<p>Uses the #rrggbb format if <code class="xref py py-obj docutils literal"><span class="pre">keep_alpha</span></code> is False (the default), <code class="xref py py-obj docutils literal"><span class="pre">#rrggbbaa</span></code>
otherwise.</p>
</dd></dl>
<dl class="function">
<dt id="matplotlib.colors.to_rgb">
<code class="descclassname">matplotlib.colors.</code><code class="descname">to_rgb</code><span class="sig-paren">(</span><em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.to_rgb" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert <code class="xref py py-obj docutils literal"><span class="pre">c</span></code> to an RGB color, silently dropping the alpha channel.</p>
</dd></dl>
<dl class="function">
<dt id="matplotlib.colors.to_rgba">
<code class="descclassname">matplotlib.colors.</code><code class="descname">to_rgba</code><span class="sig-paren">(</span><em>c</em>, <em>alpha=None</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.to_rgba" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert <code class="xref py py-obj docutils literal"><span class="pre">c</span></code> to an RGBA color.</p>
<p>If <code class="xref py py-obj docutils literal"><span class="pre">alpha</span></code> is not <code class="xref py py-obj docutils literal"><span class="pre">None</span></code>, it forces the alpha value, except if <code class="xref py py-obj docutils literal"><span class="pre">c</span></code> is
“none” (case-insensitive), which always maps to <code class="xref py py-obj docutils literal"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0)</span></code>.</p>
</dd></dl>
<dl class="function">
<dt id="matplotlib.colors.to_rgba_array">
<code class="descclassname">matplotlib.colors.</code><code class="descname">to_rgba_array</code><span class="sig-paren">(</span><em>c</em>, <em>alpha=None</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.colors.to_rgba_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert <code class="xref py py-obj docutils literal"><span class="pre">c</span></code> to a (n, 4) array of RGBA colors.</p>
<p>If <code class="xref py py-obj docutils literal"><span class="pre">alpha</span></code> is not <code class="xref py py-obj docutils literal"><span class="pre">None</span></code>, it forces the alpha value.  If <code class="xref py py-obj docutils literal"><span class="pre">c</span></code> is “none”
(case-insensitive) or an empty list, an empty array is returned.</p>
</dd></dl>
</div>
</div>
</div>
</div>
</div>
<div class="clearer"></div>
</div>
<div class="footer">
        © Copyright 2002 - 2012 John Hunter, Darren Dale, Eric Firing, Michael Droettboom and the Matplotlib development team; 2012 - 2016 The Matplotlib development team.
      Last updated on May 10, 2017.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.5.
    </div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-55954603-1', 'auto');
  ga('send', 'pageview');

</script>
</body>
<footer>
<!--Flipcause Integration v3.0// Flipcause Integration Instructions:
Install the following code block once in the website Header (after <head> tag) -->
<style>

.fc-black_overlay{
display:none; position: fixed; z-index:1000001; top: 0%;left: 0%;width: 100%;height: 100%;
background-color: black; filter: alpha(opacity=50); cursor:pointer; opacity:0.5;
}

.fc-white_content {
opacity:1; display:none; margin-top: -320px; margin-left: -485px; width:970px; height:640px;
position:fixed; top:50%; left:50%; border: none;z-index:1000002;overflow: auto;
}

.fc-main-box{
opacity:1; display:none; margin:15px auto 0 auto; width:930px; position:relative; z-index:1000003;
}

.fc-widget_close{
opacity:1; content:url(http://i1338.photobucket.com/albums/o691/WeCause/X_zpse4a7e538.png);
position:absolute; z-index=1000004; right:-16px; top:-16px; display:block; cursor:pointer;
}

.floating_button{
display: block; margin-top: 0px; margin-left: 0px; width:auto ; height: auto;
position:fixed; z-index:999999; overflow: auto;
}

@keyframes backfadesin {
   from { opacity:0; }
   to {opacity:.5;}
}

@-moz-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}

@-webkit-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}

@-o-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}


@-ms-keyframes backfadesin {
    from { opacity:0; }
    to {opacity:.5;}
}

@keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; transform: translateY(20px);}
   100% {opacity: 1; transform: translateY(0);}
}

@-moz-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -moz-transform: translateY(20px);}
   100% {opacity: 1; -moz-transform: translateY(0);}
}

@-webkit-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -webkit-transform: translateY(20px);}
   100% {opacity: 1; -webkit-transform: translateY(0);}
}

@-o-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -o-transform: translateY(20px);}
   100% {opacity: 1; -o-transform: translateY(0);}
}

@-ms-keyframes fadesin {
   0%{ opacity:0; }
   50%{ opacity:0; }
   75% {opacity: 0; -ms-transform: translateY(20px);}
   100% {opacity: 1; -ms-transform: translateY(0);}
}

</style>
<script>

function open_window(cause_id) {
var  protocol=String(document.location.protocol);
var new_url;
if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)){
new_url="https://www.flipcause.com/widget/"+cause_id
window.open(new_url);
}

else {
document.getElementById("fc-fade").style.display = "block";
document.getElementById("fc-fade").style.webkitAnimation = "backfadesin 1s";
document.getElementById("fc-fade").style.animation = "backfadesin 1s";
document.getElementById("fc-fade").style.mozAnimation = "backfadesin 1s";
document.getElementById("fc-light").style.display = "block";
document.getElementById("fc-light").style.webkitAnimation = "fadesin 1.5s";
document.getElementById("fc-light").style.animation = "fadesin 1.5s";
document.getElementById("fc-light").style.mozAnimation = "fadesin 1.5s";
document.getElementById("fc-main").style.display = "block";
document.getElementById("fc-main").style.webkitAnimation = "fadesin 1.5s";
document.getElementById("fc-main").style.animation = "fadesin 1.5s";
document.getElementById("fc-main").style.mozAnimation = "fadesin 1.5s";
document.getElementById("fc-close").style.display = "block";
document.getElementById("fc-close").style.webkitAnimation = "fadesin 1.5s";
document.getElementById("fc-close").style.animation = "fadesin 1.5s";
document.getElementById("fc-close").style.mozAnimation = "fadesin 1.5s";
document.getElementById("fc-myFrame").style.display = "block";
document.getElementById("fc-myFrame").style.webkitAnimation = "fadesin 1.5s";
document.getElementById("fc-myFrame").style.animation = "fadesin 1.5s";
document.getElementById("fc-myFrame").style.mozAnimation = "fadesin 1.5s";
document.getElementById("fc-myFrame").src="https://www.flipcause.com/widget/"+cause_id;
}
}


function close_window() {
document.getElementById("fc-fade").style.display="none";
document.getElementById("fc-light").style.display="none";
document.getElementById("fc-main").style.display="none";
document.getElementById("fc-close").style.display="none";
document.getElementById("fc-myFrame").style.display="none";
}

</script>
<div class="fc-black_overlay" id="fc-fade" onclick="close_window()"></div>
<div class="fc-white_content" id="fc-light">
<div class="fc-main-box" id="fc-main">
<div class="fc-widget_close" id="fc-close" onclick="close_window()">
</div><iframe height="580" id="fc-myFrame" iframe="" scrolling="no" src="" style="border: 0;
border-radius:5px 5px 5px 5px; box-shadow:0 0 8px rgba(0, 0, 0, 0.5);" width="925"></iframe></div>
</div>
<!--END Flipcause Main Integration Code-->
</footer>
</html>