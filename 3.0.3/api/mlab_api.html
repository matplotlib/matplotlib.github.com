<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>mlab &mdash; Matplotlib 3.0.3 documentation</title>
    
    <link rel="stylesheet" href="../_static/mpl.css"
type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css"
type="text/css" />
    <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
    <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Matplotlib 3.0.3 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html"
/>
    <link rel="search" title="Search" href="../search.html"
/>
    <link rel="top" title="Matplotlib 3.0.3 documentation" href="../index.html" />
    <link rel="up" title="The Matplotlib API" href="index.html" />
    <link rel="next" title="offsetbox" href="offsetbox_api.html" />
    <link rel="prev" title="mathtext" href="mathtext_api.html" />
  <link rel="canonical" href="https://matplotlib.org/stable/api/mlab_api.html" />



    <script data-domain="matplotlib.org" defer="defer" src="https://views.scientific-python.org/js/script.js"></script>
  </head>
  <body>
<div id="unreleased-message"> You are reading an old version of the documentation (v3.0.3).  For the latest version see <a href="https://matplotlib.org/stable/api/mlab_api.html">https://matplotlib.org/stable/api/mlab_api.html</a></div>



<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px; position: relative;">
<a href="../index.html">
    <div style="float: left; position: absolute; width: 496px; bottom: 0; padding-bottom: 24px"><span style="float: right; color: #789; background: white">Version 3.0.3</span></div>
    <img src="../_static/logo2.png" height="125px" border="0" alt="matplotlib"/></a>

<!-- The "Fork me on github" ribbon -->
<div id="forkongithub"><a href="https://github.com/matplotlib/matplotlib">Fork me on GitHub</a></div>
</div>




    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="offsetbox_api.html" title="offsetbox"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="mathtext_api.html" title="mathtext"
             accesskey="P">previous</a> |</li>

        <li><a href="../index.html">home</a>|&nbsp;</li>
        <li><a href="../gallery/index.html">examples</a>|&nbsp;</li>
        <li><a href="../tutorials/index.html">tutorials</a>|&nbsp;</li>
        <li><a href="api_overview.html">API</a>|&nbsp;</li>
        <li><a href="../contents.html">docs</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">The Matplotlib API</a> &raquo;</li> 
      </ul>
    </div>

  
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">mlab</a><ul>
<li><a class="reference internal" href="#module-matplotlib.mlab"><code class="docutils literal notranslate"><span class="pre">matplotlib.mlab</span></code></a><ul>
<li><a class="reference internal" href="#matlab-compatible-functions">MATLAB compatible functions</a></li>
<li><a class="reference internal" href="#miscellaneous-functions">Miscellaneous functions</a></li>
<li><a class="reference internal" href="#record-array-helper-functions">record array helper functions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../contents.html">Documentation overview</a><ul>
  <li><a href="index.html">The Matplotlib API</a><ul>
      <li>Previous: <a href="mathtext_api.html" title="previous chapter">mathtext</a></li>
      <li>Next: <a href="offsetbox_api.html" title="next chapter">offsetbox</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div id="sidebar-pagesource" role="note" aria-label="source link"
    style="margin-top: 1.5em; padding-top: 0.1em; border-top: 1px solid #86989b">
  <a href="../_sources/api/mlab_api.rst.txt"
     style="color: #c0c0c0" rel="nofollow">Show Page Source</a>
  </div>
        </div>
      </div>
    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="mlab">
<h1>mlab<a class="headerlink" href="#mlab" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-matplotlib.mlab">
<span id="matplotlib-mlab"></span><h2><a class="reference internal" href="#module-matplotlib.mlab" title="matplotlib.mlab"><code class="xref py py-mod docutils literal notranslate"><span class="pre">matplotlib.mlab</span></code></a><a class="headerlink" href="#module-matplotlib.mlab" title="Permalink to this headline">¶</a></h2>
<p>Numerical python functions written for compatibility with MATLAB
commands with the same names.</p>
<div class="section" id="matlab-compatible-functions">
<h3>MATLAB compatible functions<a class="headerlink" href="#matlab-compatible-functions" title="Permalink to this headline">¶</a></h3>
<dl class="docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.cohere" title="matplotlib.mlab.cohere"><code class="xref py py-func docutils literal notranslate"><span class="pre">cohere()</span></code></a></dt>
<dd>Coherence (normalized cross spectral density)</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.csd" title="matplotlib.mlab.csd"><code class="xref py py-func docutils literal notranslate"><span class="pre">csd()</span></code></a></dt>
<dd>Cross spectral density using Welch's average periodogram</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.detrend" title="matplotlib.mlab.detrend"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend()</span></code></a></dt>
<dd>Remove the mean or best fit line from an array</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.find" title="matplotlib.mlab.find"><code class="xref py py-func docutils literal notranslate"><span class="pre">find()</span></code></a></dt>
<dd>Return the indices where some condition is true;
numpy.nonzero is similar but more general.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.griddata" title="matplotlib.mlab.griddata"><code class="xref py py-func docutils literal notranslate"><span class="pre">griddata()</span></code></a></dt>
<dd>Interpolate irregularly distributed data to a
regular grid.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.prctile" title="matplotlib.mlab.prctile"><code class="xref py py-func docutils literal notranslate"><span class="pre">prctile()</span></code></a></dt>
<dd>Find the percentiles of a sequence</dd>
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">prepca()</span></code></dt>
<dd>Principal Component Analysis</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code class="xref py py-func docutils literal notranslate"><span class="pre">psd()</span></code></a></dt>
<dd>Power spectral density using Welch's average periodogram</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.rk4" title="matplotlib.mlab.rk4"><code class="xref py py-func docutils literal notranslate"><span class="pre">rk4()</span></code></a></dt>
<dd>A 4th order runge kutta integrator for 1D or ND systems</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code class="xref py py-func docutils literal notranslate"><span class="pre">specgram()</span></code></a></dt>
<dd>Spectrogram (spectrum over segments of time)</dd>
</dl>
</div>
<div class="section" id="miscellaneous-functions">
<h3>Miscellaneous functions<a class="headerlink" href="#miscellaneous-functions" title="Permalink to this headline">¶</a></h3>
<p>Functions that don't exist in MATLAB, but are useful anyway:</p>
<dl class="docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.cohere_pairs" title="matplotlib.mlab.cohere_pairs"><code class="xref py py-func docutils literal notranslate"><span class="pre">cohere_pairs()</span></code></a></dt>
<dd>Coherence over all pairs.  This is not a MATLAB function, but we
compute coherence a lot in my lab, and we compute it for a lot of
pairs.  This function is optimized to do this efficiently by
caching the direct FFTs.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.rk4" title="matplotlib.mlab.rk4"><code class="xref py py-func docutils literal notranslate"><span class="pre">rk4()</span></code></a></dt>
<dd>A 4th order Runge-Kutta ODE integrator in case you ever find
yourself stranded without scipy (and the far superior
scipy.integrate tools)</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.contiguous_regions" title="matplotlib.mlab.contiguous_regions"><code class="xref py py-func docutils literal notranslate"><span class="pre">contiguous_regions()</span></code></a></dt>
<dd>Return the indices of the regions spanned by some logical mask</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.cross_from_below" title="matplotlib.mlab.cross_from_below"><code class="xref py py-func docutils literal notranslate"><span class="pre">cross_from_below()</span></code></a></dt>
<dd>Return the indices where a 1D array crosses a threshold from below</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.cross_from_above" title="matplotlib.mlab.cross_from_above"><code class="xref py py-func docutils literal notranslate"><span class="pre">cross_from_above()</span></code></a></dt>
<dd>Return the indices where a 1D array crosses a threshold from above</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex_spectrum()</span></code></a></dt>
<dd>Return the complex-valued frequency spectrum of a signal</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">magnitude_spectrum()</span></code></a></dt>
<dd>Return the magnitude of the frequency spectrum of a signal</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">angle_spectrum()</span></code></a></dt>
<dd>Return the angle (wrapped phase) of the frequency spectrum of a signal</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">phase_spectrum()</span></code></a></dt>
<dd>Return the phase (unwrapped angle) of the frequency spectrum of a signal</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_mean()</span></code></a></dt>
<dd>Remove the mean from a line.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.demean" title="matplotlib.mlab.demean"><code class="xref py py-func docutils literal notranslate"><span class="pre">demean()</span></code></a></dt>
<dd>Remove the mean from a line. This function is the same as
<a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_mean()</span></code></a> except for the default <em>axis</em>.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_linear()</span></code></a></dt>
<dd>Remove the best fit line from a line.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_none()</span></code></a></dt>
<dd>Return the original line.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.stride_windows" title="matplotlib.mlab.stride_windows"><code class="xref py py-func docutils literal notranslate"><span class="pre">stride_windows()</span></code></a></dt>
<dd>Get all windows in an array in a memory-efficient manner</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.stride_repeat" title="matplotlib.mlab.stride_repeat"><code class="xref py py-func docutils literal notranslate"><span class="pre">stride_repeat()</span></code></a></dt>
<dd>Repeat an array in a memory-efficient manner</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.apply_window" title="matplotlib.mlab.apply_window"><code class="xref py py-func docutils literal notranslate"><span class="pre">apply_window()</span></code></a></dt>
<dd>Apply a window along a given axis</dd>
</dl>
</div>
<div class="section" id="record-array-helper-functions">
<h3>record array helper functions<a class="headerlink" href="#record-array-helper-functions" title="Permalink to this headline">¶</a></h3>
<p>A collection of helper methods for numpyrecord arrays</p>
<blockquote id="htmlonly">
<div>See <a class="reference internal" href="../gallery/index.html#misc-examples-index"><span class="std std-ref">Miscellaneous</span></a></div></blockquote>
<dl class="docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.rec2txt" title="matplotlib.mlab.rec2txt"><code class="xref py py-func docutils literal notranslate"><span class="pre">rec2txt()</span></code></a></dt>
<dd>Pretty print a record array</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.rec2csv" title="matplotlib.mlab.rec2csv"><code class="xref py py-func docutils literal notranslate"><span class="pre">rec2csv()</span></code></a></dt>
<dd>Store record array in CSV file</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.csv2rec" title="matplotlib.mlab.csv2rec"><code class="xref py py-func docutils literal notranslate"><span class="pre">csv2rec()</span></code></a></dt>
<dd>Import record array from CSV file with type inspection</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.rec_append_fields" title="matplotlib.mlab.rec_append_fields"><code class="xref py py-func docutils literal notranslate"><span class="pre">rec_append_fields()</span></code></a></dt>
<dd>Adds field(s)/array(s) to record array</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.rec_drop_fields" title="matplotlib.mlab.rec_drop_fields"><code class="xref py py-func docutils literal notranslate"><span class="pre">rec_drop_fields()</span></code></a></dt>
<dd>Drop fields from record array</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.rec_join" title="matplotlib.mlab.rec_join"><code class="xref py py-func docutils literal notranslate"><span class="pre">rec_join()</span></code></a></dt>
<dd>Join two record arrays on sequence of fields</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.recs_join" title="matplotlib.mlab.recs_join"><code class="xref py py-func docutils literal notranslate"><span class="pre">recs_join()</span></code></a></dt>
<dd>A simple join of multiple recarrays using a single column as a key</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.rec_groupby" title="matplotlib.mlab.rec_groupby"><code class="xref py py-func docutils literal notranslate"><span class="pre">rec_groupby()</span></code></a></dt>
<dd>Summarize data by groups (similar to SQL GROUP BY)</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.rec_summarize" title="matplotlib.mlab.rec_summarize"><code class="xref py py-func docutils literal notranslate"><span class="pre">rec_summarize()</span></code></a></dt>
<dd>Helper code to filter rec array fields into new fields</dd>
</dl>
<p>For the rec viewer functions(e rec2csv), there are a bunch of Format
objects you can pass into the functions that will do things like color
negative values red, set percent formatting and scaling, etc.</p>
<p>Example usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="n">csv2rec</span><span class="p">(</span><span class="s1">&#39;somefile.csv&#39;</span><span class="p">,</span> <span class="n">checkrows</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="n">formatd</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="n">FormatFloat</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
    <span class="n">change</span> <span class="o">=</span> <span class="n">FormatPercent</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
    <span class="n">cost</span>   <span class="o">=</span> <span class="n">FormatThousands</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
    <span class="p">)</span>


<span class="n">rec2excel</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="s1">&#39;test.xls&#39;</span><span class="p">,</span> <span class="n">formatd</span><span class="o">=</span><span class="n">formatd</span><span class="p">)</span>
<span class="n">rec2csv</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="s1">&#39;test.csv&#39;</span><span class="p">,</span> <span class="n">formatd</span><span class="o">=</span><span class="n">formatd</span><span class="p">)</span>
</pre></div>
</div>
<dl class="class">
<dt id="matplotlib.mlab.FormatBool">
<em class="property">class </em><code class="descclassname">matplotlib.mlab.</code><code class="descname">FormatBool</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#FormatBool"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.FormatBool" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.mlab.FormatObj" title="matplotlib.mlab.FormatObj"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.mlab.FormatObj</span></code></a></p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The FormatBool class was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p></p>
<dl class="method">
<dt id="matplotlib.mlab.FormatBool.fromstr">
<code class="descname">fromstr</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#FormatBool.fromstr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.FormatBool.fromstr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.mlab.FormatBool.toval">
<code class="descname">toval</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#FormatBool.toval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.FormatBool.toval" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.mlab.FormatDate">
<em class="property">class </em><code class="descclassname">matplotlib.mlab.</code><code class="descname">FormatDate</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#FormatDate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.FormatDate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.mlab.FormatObj" title="matplotlib.mlab.FormatObj"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.mlab.FormatObj</span></code></a></p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The FormatDate class was deprecated in Matplotlib 2.2 and will be removed in 3.1. Use date.strftime instead.</p>
</div>
<p></p>
<dl class="method">
<dt id="matplotlib.mlab.FormatDate.fromstr">
<code class="descname">fromstr</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#FormatDate.fromstr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.FormatDate.fromstr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.mlab.FormatDate.toval">
<code class="descname">toval</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#FormatDate.toval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.FormatDate.toval" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.mlab.FormatDatetime">
<em class="property">class </em><code class="descclassname">matplotlib.mlab.</code><code class="descname">FormatDatetime</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#FormatDatetime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.FormatDatetime" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.mlab.FormatDate" title="matplotlib.mlab.FormatDate"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.mlab.FormatDate</span></code></a></p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The FormatDatetime class was deprecated in Matplotlib 2.2 and will be removed in 3.1. Use datetime.strftime instead.</p>
</div>
<p></p>
<dl class="method">
<dt id="matplotlib.mlab.FormatDatetime.fromstr">
<code class="descname">fromstr</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#FormatDatetime.fromstr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.FormatDatetime.fromstr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.mlab.FormatFloat">
<em class="property">class </em><code class="descclassname">matplotlib.mlab.</code><code class="descname">FormatFloat</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#FormatFloat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.FormatFloat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.mlab.FormatFormatStr" title="matplotlib.mlab.FormatFormatStr"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.mlab.FormatFormatStr</span></code></a></p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The FormatFloat class was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p></p>
<dl class="method">
<dt id="matplotlib.mlab.FormatFloat.fromstr">
<code class="descname">fromstr</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#FormatFloat.fromstr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.FormatFloat.fromstr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.mlab.FormatFloat.toval">
<code class="descname">toval</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#FormatFloat.toval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.FormatFloat.toval" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.mlab.FormatFormatStr">
<em class="property">class </em><code class="descclassname">matplotlib.mlab.</code><code class="descname">FormatFormatStr</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#FormatFormatStr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.FormatFormatStr" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.mlab.FormatObj" title="matplotlib.mlab.FormatObj"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.mlab.FormatObj</span></code></a></p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The FormatFormatStr class was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p></p>
<dl class="method">
<dt id="matplotlib.mlab.FormatFormatStr.tostr">
<code class="descname">tostr</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#FormatFormatStr.tostr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.FormatFormatStr.tostr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.mlab.FormatInt">
<em class="property">class </em><code class="descclassname">matplotlib.mlab.</code><code class="descname">FormatInt</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#FormatInt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.FormatInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.mlab.FormatObj" title="matplotlib.mlab.FormatObj"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.mlab.FormatObj</span></code></a></p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The FormatInt class was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p></p>
<dl class="method">
<dt id="matplotlib.mlab.FormatInt.fromstr">
<code class="descname">fromstr</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#FormatInt.fromstr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.FormatInt.fromstr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.mlab.FormatInt.tostr">
<code class="descname">tostr</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#FormatInt.tostr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.FormatInt.tostr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.mlab.FormatInt.toval">
<code class="descname">toval</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#FormatInt.toval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.FormatInt.toval" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.mlab.FormatMillions">
<em class="property">class </em><code class="descclassname">matplotlib.mlab.</code><code class="descname">FormatMillions</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#FormatMillions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.FormatMillions" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.mlab.FormatFloat" title="matplotlib.mlab.FormatFloat"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.mlab.FormatFloat</span></code></a></p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The FormatMillions class was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p></p>
</dd></dl>

<dl class="class">
<dt id="matplotlib.mlab.FormatObj">
<em class="property">class </em><code class="descclassname">matplotlib.mlab.</code><code class="descname">FormatObj</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#FormatObj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.FormatObj" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The FormatObj class was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p></p>
<dl class="method">
<dt id="matplotlib.mlab.FormatObj.fromstr">
<code class="descname">fromstr</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#FormatObj.fromstr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.FormatObj.fromstr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.mlab.FormatObj.tostr">
<code class="descname">tostr</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#FormatObj.tostr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.FormatObj.tostr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.mlab.FormatObj.toval">
<code class="descname">toval</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#FormatObj.toval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.FormatObj.toval" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.mlab.FormatPercent">
<em class="property">class </em><code class="descclassname">matplotlib.mlab.</code><code class="descname">FormatPercent</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#FormatPercent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.FormatPercent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.mlab.FormatFloat" title="matplotlib.mlab.FormatFloat"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.mlab.FormatFloat</span></code></a></p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The FormatPercent class was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p></p>
</dd></dl>

<dl class="class">
<dt id="matplotlib.mlab.FormatString">
<em class="property">class </em><code class="descclassname">matplotlib.mlab.</code><code class="descname">FormatString</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#FormatString"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.FormatString" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.mlab.FormatObj" title="matplotlib.mlab.FormatObj"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.mlab.FormatObj</span></code></a></p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The FormatString class was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p></p>
<dl class="method">
<dt id="matplotlib.mlab.FormatString.tostr">
<code class="descname">tostr</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#FormatString.tostr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.FormatString.tostr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.mlab.FormatThousands">
<em class="property">class </em><code class="descclassname">matplotlib.mlab.</code><code class="descname">FormatThousands</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#FormatThousands"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.FormatThousands" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.mlab.FormatFloat" title="matplotlib.mlab.FormatFloat"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.mlab.FormatFloat</span></code></a></p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The FormatThousands class was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p></p>
</dd></dl>

<dl class="class">
<dt id="matplotlib.mlab.GaussianKDE">
<em class="property">class </em><code class="descclassname">matplotlib.mlab.</code><code class="descname">GaussianKDE</code><span class="sig-paren">(</span><em>dataset</em>, <em>bw_method=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#GaussianKDE"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.GaussianKDE" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Representation of a kernel-density estimate using Gaussian kernels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dataset</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">Datapoints to estimate from. In case of univariate data this is a 1-D
array, otherwise a 2-D array with shape (# of dims, # of data).</p>
</dd>
<dt><strong>bw_method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, scalar or callable, optional</span></dt>
<dd><p class="first last">The method used to calculate the estimator bandwidth.  This can be
'scott', 'silverman', a scalar constant or a callable.  If a
scalar, this will be used directly as <code class="xref py py-obj docutils literal notranslate"><span class="pre">kde.factor</span></code>.  If a
callable, it should take a <a class="reference internal" href="#matplotlib.mlab.GaussianKDE" title="matplotlib.mlab.GaussianKDE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GaussianKDE</span></code></a> instance as only
parameter and return a scalar. If None (default), 'scott' is used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dataset</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The dataset with which <code class="xref py py-obj docutils literal notranslate"><span class="pre">gaussian_kde</span></code> was initialized.</p>
</dd>
<dt><strong>dim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of dimensions.</p>
</dd>
<dt><strong>num_dp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of datapoints.</p>
</dd>
<dt><strong>factor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The bandwidth factor, obtained from <code class="xref py py-obj docutils literal notranslate"><span class="pre">kde.covariance_factor</span></code>, with which
the covariance matrix is multiplied.</p>
</dd>
<dt><strong>covariance</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The covariance matrix of <code class="xref py py-obj docutils literal notranslate"><span class="pre">dataset</span></code>, scaled by the calculated bandwidth
(<code class="xref py py-obj docutils literal notranslate"><span class="pre">kde.factor</span></code>).</p>
</dd>
<dt><strong>inv_cov</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The inverse of <code class="xref py py-obj docutils literal notranslate"><span class="pre">covariance</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>kde.evaluate(points)</strong></td>
<td>(ndarray) Evaluate the estimated pdf on a provided set of points.</td>
</tr>
<tr class="row-even"><td><strong>kde(points)</strong></td>
<td>(ndarray) Same as kde.evaluate(points)</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="matplotlib.mlab.GaussianKDE.covariance_factor">
<code class="descname">covariance_factor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.mlab.GaussianKDE.covariance_factor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.mlab.GaussianKDE.evaluate">
<code class="descname">evaluate</code><span class="sig-paren">(</span><em>points</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#GaussianKDE.evaluate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.GaussianKDE.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the estimated pdf on a set of points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(# of dimensions, # of points)-array</span></dt>
<dd><p class="first last">Alternatively, a (# of dimensions,) vector can be passed in and
treated as a single point.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>values</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(# of points,)-array</span></dt>
<dd><p class="first last">The values at each point.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong> <span class="classifier-delimiter">:</span> <span class="classifier">if the dimensionality of the input points is different</span></dt>
<dd><p class="first last">than the dimensionality of the KDE.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="matplotlib.mlab.GaussianKDE.scotts_factor">
<code class="descname">scotts_factor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#GaussianKDE.scotts_factor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.GaussianKDE.scotts_factor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.mlab.GaussianKDE.silverman_factor">
<code class="descname">silverman_factor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#GaussianKDE.silverman_factor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.GaussianKDE.silverman_factor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.mlab.PCA">
<em class="property">class </em><code class="descclassname">matplotlib.mlab.</code><code class="descname">PCA</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#PCA"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.PCA" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The PCA class was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p></p>
<dl class="method">
<dt id="matplotlib.mlab.PCA.center">
<code class="descname">center</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#PCA.center"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.PCA.center" title="Permalink to this definition">¶</a></dt>
<dd><p>center and optionally standardize the data using the mean and sigma
from training set a</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.mlab.PCA.project">
<code class="descname">project</code><span class="sig-paren">(</span><em>x</em>, <em>minfrac=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#PCA.project"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.PCA.project" title="Permalink to this definition">¶</a></dt>
<dd><p>project x onto the principle axes, dropping any axes where fraction
of variance&lt;minfrac</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.amap">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">amap</code><span class="sig-paren">(</span><em>fn</em>, <em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#amap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.amap" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The amap function was deprecated in Matplotlib 2.2 and will be removed in 3.1. Use numpy.array(list(map(...))) instead.</p>
</div>
<p>amap(function, sequence[, sequence, ...]) -&gt; array.</p>
<p>Works like <a class="reference external" href="https://docs.python.org/3/library/functions.html#map" title="(in Python v3.7)"><code class="xref py py-func docutils literal notranslate"><span class="pre">map()</span></code></a>, but it returns an array.  This is just a
convenient shorthand for <code class="docutils literal notranslate"><span class="pre">numpy.array(map(...))</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.angle_spectrum">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">angle_spectrum</code><span class="sig-paren">(</span><em>x</em>, <em>Fs=None</em>, <em>window=None</em>, <em>pad_to=None</em>, <em>sides=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#angle_spectrum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.angle_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the angle of the frequency spectrum (wrapped phase spectrum) of
<em>x</em>.  Data is padded to a length of <em>pad_to</em> and the windowing function
<em>window</em> is applied to the signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D array or sequence</span></dt>
<dd><p class="first last">Array or sequence containing the data</p>
</dd>
<dt><strong>Fs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd><p class="first last">The sampling frequency (samples per time unit).  It is used
to calculate the Fourier frequencies, freqs, in cycles per time
unit. The default value is 2.</p>
</dd>
<dt><strong>window</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable or ndarray</span></dt>
<dd><p class="first last">A function or a vector of length <em>NFFT</em>. To create window
vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-func docutils literal notranslate"><span class="pre">window_hanning()</span></code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code class="xref py py-func docutils literal notranslate"><span class="pre">window_none()</span></code></a>,
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.blackman()</span></code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.hamming()</span></code></a>,
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.bartlett()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.signal()</span></code>,
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.2.1)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.signal.get_window()</span></code></a>, etc. The default is
<a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-func docutils literal notranslate"><span class="pre">window_hanning()</span></code></a>.  If a function is passed as the
argument, it must take a data segment as an argument and
return the windowed version of the segment.</p>
</dd>
<dt><strong>sides</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{'default', 'onesided', 'twosided'}</span></dt>
<dd><p class="first last">Specifies which sides of the spectrum to return.  Default gives the
default behavior, which returns one-sided for real data and both
for complex data.  'onesided' forces the return of a one-sided
spectrum, while 'twosided' forces two-sided.</p>
</dd>
<dt><strong>pad_to</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of points to which the data segment is padded when
performing the FFT.  While not increasing the actual resolution of
the spectrum (the minimum distance between resolvable peaks),
this can give more points in the plot, allowing for more
detail. This corresponds to the <em>n</em> parameter in the call to fft().
The default is None, which sets <em>pad_to</em> equal to the length of the
input signal (i.e. no padding).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>spectrum</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D array</span></dt>
<dd><p class="first last">The values for the angle spectrum in radians (real valued)</p>
</dd>
<dt><strong>freqs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D array</span></dt>
<dd><p class="first last">The frequencies corresponding to the elements in <em>spectrum</em></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex_spectrum()</span></code></a></dt>
<dd>This function returns the angle value of <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex_spectrum()</span></code></a>.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">magnitude_spectrum()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">angle_spectrum()</span></code></a> returns the magnitudes of the corresponding frequencies.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">phase_spectrum()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">phase_spectrum()</span></code></a> returns the unwrapped version of this function.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code class="xref py py-func docutils literal notranslate"><span class="pre">specgram()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code class="xref py py-func docutils literal notranslate"><span class="pre">specgram()</span></code></a> can return the angle spectrum of segments within the signal.</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.apply_window">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">apply_window</code><span class="sig-paren">(</span><em>x</em>, <em>window</em>, <em>axis=0</em>, <em>return_window=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#apply_window"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.apply_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the given window to the given 1D or 2D array along the given axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D or 2D array or sequence</span></dt>
<dd><p class="first last">Array or sequence containing the data.</p>
</dd>
<dt><strong>window</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function or array.</span></dt>
<dd><p class="first last">Either a function to generate a window or an array with length
<em>x</em>.shape[<em>axis</em>]</p>
</dd>
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The axis over which to do the repetition.
Must be 0 or 1.  The default is 0</p>
</dd>
<dt><strong>return_window</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If true, also return the 1D values of the window that was applied</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.base_repr">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">base_repr</code><span class="sig-paren">(</span><em>number</em>, <em>base=2</em>, <em>padding=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#base_repr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.base_repr" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The base_repr function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Return the representation of a <em>number</em> in any given <em>base</em>.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.binary_repr">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">binary_repr</code><span class="sig-paren">(</span><em>number</em>, <em>max_length=1025</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#binary_repr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.binary_repr" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The binary_repr function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Return the binary representation of the input <em>number</em> as a
string.</p>
<p>This is more efficient than using <a class="reference internal" href="#matplotlib.mlab.base_repr" title="matplotlib.mlab.base_repr"><code class="xref py py-func docutils literal notranslate"><span class="pre">base_repr()</span></code></a> with base 2.</p>
<p>Increase the value of max_length for very large numbers. Note that
on 32-bit machines, 2**1023 is the largest integer power of 2
which can be converted to a Python float.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.bivariate_normal">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">bivariate_normal</code><span class="sig-paren">(</span><em>X</em>, <em>Y</em>, <em>sigmax=1.0</em>, <em>sigmay=1.0</em>, <em>mux=0.0</em>, <em>muy=0.0</em>, <em>sigmaxy=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#bivariate_normal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.bivariate_normal" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The bivariate_normal function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Bivariate Gaussian distribution for equal shape <em>X</em>, <em>Y</em>.</p>
<p>See <a class="reference external" href="http://mathworld.wolfram.com/BivariateNormalDistribution.html">bivariate normal</a>
at mathworld.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.center_matrix">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">center_matrix</code><span class="sig-paren">(</span><em>M</em>, <em>dim=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#center_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.center_matrix" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The center_matrix function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Return the matrix <em>M</em> with each row having zero mean and unit std.</p>
<p>If <em>dim</em> = 1 operate on columns instead of rows.  (<em>dim</em> is
opposite to the numpy axis kwarg.)</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.cohere">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">cohere</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>NFFT=256</em>, <em>Fs=2</em>, <em>detrend=&lt;function detrend_none&gt;</em>, <em>window=&lt;function window_hanning&gt;</em>, <em>noverlap=0</em>, <em>pad_to=None</em>, <em>sides='default'</em>, <em>scale_by_freq=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#cohere"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.cohere" title="Permalink to this definition">¶</a></dt>
<dd><p>The coherence between <em>x</em> and <em>y</em>.  Coherence is the normalized
cross spectral density:</p>
<div class="math notranslate nohighlight">
\[C_{xy} = \frac{|P_{xy}|^2}{P_{xx}P_{yy}}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x, y</strong></dt>
<dd><p class="first last">Array or sequence containing the data</p>
</dd>
<dt><strong>Fs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd><p class="first last">The sampling frequency (samples per time unit).  It is used
to calculate the Fourier frequencies, freqs, in cycles per time
unit. The default value is 2.</p>
</dd>
<dt><strong>window</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable or ndarray</span></dt>
<dd><p class="first last">A function or a vector of length <em>NFFT</em>. To create window
vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-func docutils literal notranslate"><span class="pre">window_hanning()</span></code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code class="xref py py-func docutils literal notranslate"><span class="pre">window_none()</span></code></a>,
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.blackman()</span></code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.hamming()</span></code></a>,
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.bartlett()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.signal()</span></code>,
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.2.1)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.signal.get_window()</span></code></a>, etc. The default is
<a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-func docutils literal notranslate"><span class="pre">window_hanning()</span></code></a>.  If a function is passed as the
argument, it must take a data segment as an argument and
return the windowed version of the segment.</p>
</dd>
<dt><strong>sides</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{'default', 'onesided', 'twosided'}</span></dt>
<dd><p class="first last">Specifies which sides of the spectrum to return.  Default gives the
default behavior, which returns one-sided for real data and both
for complex data.  'onesided' forces the return of a one-sided
spectrum, while 'twosided' forces two-sided.</p>
</dd>
<dt><strong>pad_to</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of points to which the data segment is padded when
performing the FFT.  This can be different from <em>NFFT</em>, which
specifies the number of data points used.  While not increasing
the actual resolution of the spectrum (the minimum distance between
resolvable peaks), this can give more points in the plot,
allowing for more detail. This corresponds to the <em>n</em> parameter
in the call to fft(). The default is None, which sets <em>pad_to</em>
equal to <em>NFFT</em></p>
</dd>
<dt><strong>NFFT</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of data points used in each block for the FFT.
A power 2 is most efficient.  The default value is 256.
This should <em>NOT</em> be used to get zero padding, or the scaling of the
result will be incorrect. Use <em>pad_to</em> for this instead.</p>
</dd>
<dt><strong>detrend</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{'default', 'constant', 'mean', 'linear', 'none'} or callable</span></dt>
<dd><p class="first last">The function applied to each segment before fft-ing,
designed to remove the mean or linear trend.  Unlike in
MATLAB, where the <em>detrend</em> parameter is a vector, in
matplotlib is it a function.  The <a class="reference internal" href="#module-matplotlib.mlab" title="matplotlib.mlab"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mlab</span></code></a>
module defines <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_none()</span></code></a>,
<a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_mean()</span></code></a>, and
<a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_linear()</span></code></a>, but you can use
a custom function as well.  You can also use a string to choose
one of the functions.  'default', 'constant', and 'mean' call
<a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_mean()</span></code></a>.  'linear' calls
<a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_linear()</span></code></a>.  'none' calls
<a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_none()</span></code></a>.</p>
</dd>
<dt><strong>scale_by_freq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Specifies whether the resulting density values should be scaled
by the scaling frequency, which gives density in units of Hz^-1.
This allows for integration over the returned frequency values.
The default is True for MATLAB compatibility.</p>
</dd>
<dt><strong>noverlap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The number of points of overlap between blocks.  The default value
is 0 (no overlap).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>The return value is the tuple (*Cxy*, *f*), where *f* are the</strong></dt>
<dd></dd>
<dt><strong>frequencies of the coherence vector. For cohere, scaling the</strong></dt>
<dd></dd>
<dt><strong>individual densities by the sampling frequency has no effect,</strong></dt>
<dd></dd>
<dt><strong>since the factors cancel out.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code class="xref py py-func docutils literal notranslate"><span class="pre">psd()</span></code></a>, <a class="reference internal" href="#matplotlib.mlab.csd" title="matplotlib.mlab.csd"><code class="xref py py-func docutils literal notranslate"><span class="pre">csd()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.cohere_pairs">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">cohere_pairs</code><span class="sig-paren">(</span><em>X</em>, <em>ij</em>, <em>NFFT=256</em>, <em>Fs=2</em>, <em>detrend=&lt;function detrend_none&gt;</em>, <em>window=&lt;function window_hanning&gt;</em>, <em>noverlap=0</em>, <em>preferSpeedOverMemory=True</em>, <em>progressCallback=&lt;function donothing_callback&gt;</em>, <em>returnPxx=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#cohere_pairs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.cohere_pairs" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>scipy.signal.coherence</p>
</div>
<p>Compute the coherence and phase for all pairs <em>ij</em>, in <em>X</em>.</p>
<p><em>X</em> is a <em>numSamples</em> * <em>numCols</em> array</p>
<p><em>ij</em> is a list of tuples.  Each tuple is a pair of indexes into
the columns of X for which you want to compute coherence.  For
example, if <em>X</em> has 64 columns, and you want to compute all
nonredundant pairs, define <em>ij</em> as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ij</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">64</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">64</span><span class="p">):</span>
        <span class="n">ij</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p><em>preferSpeedOverMemory</em> is an optional bool. Defaults to true. If
False, limits the caching by only making one, rather than two,
complex cache arrays. This is useful if memory becomes critical.
Even when <em>preferSpeedOverMemory</em> is False, <a class="reference internal" href="#matplotlib.mlab.cohere_pairs" title="matplotlib.mlab.cohere_pairs"><code class="xref py py-func docutils literal notranslate"><span class="pre">cohere_pairs()</span></code></a>
will still give significant performance gains over calling
<a class="reference internal" href="#matplotlib.mlab.cohere" title="matplotlib.mlab.cohere"><code class="xref py py-func docutils literal notranslate"><span class="pre">cohere()</span></code></a> for each pair, and will use subtantially less
memory than if <em>preferSpeedOverMemory</em> is True.  In my tests with
a 43000,64 array over all nonredundant pairs,
<em>preferSpeedOverMemory</em> = True delivered a 33% performance boost
on a 1.7GHZ Athlon with 512MB RAM compared with
<em>preferSpeedOverMemory</em> = False.  But both solutions were more
than 10x faster than naively crunching all possible pairs through
<a class="reference internal" href="#matplotlib.mlab.cohere" title="matplotlib.mlab.cohere"><code class="xref py py-func docutils literal notranslate"><span class="pre">cohere()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Cxy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dictionary of (<em>i</em>, <em>j</em>) tuples -&gt; coherence vector for</span></dt>
<dd><p class="first last">that pair.  i.e., <code class="docutils literal notranslate"><span class="pre">Cxy[(i,j)</span> <span class="pre">=</span> <span class="pre">cohere(X[:,i],</span> <span class="pre">X[:,j])</span></code>.
Number of dictionary keys is <code class="docutils literal notranslate"><span class="pre">len(ij)</span></code>.</p>
</dd>
<dt><strong>Phase</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dictionary of phases of the cross spectral density at</span></dt>
<dd><p class="first last">each frequency for each pair.  Keys are (<em>i</em>, <em>j</em>).</p>
</dd>
<dt><strong>freqs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">vector of frequencies, equal in length to either the</span></dt>
<dd><p class="first last">coherence or phase vectors for any (<em>i</em>, <em>j</em>) key.</p>
</dd>
<dt><strong>e.g., to make a coherence Bode plot::</strong></dt>
<dd><p class="first last">subplot(211)
plot( freqs, Cxy[(12,19)])
subplot(212)
plot( freqs, Phase[(12,19)])</p>
</dd>
<dt><strong>For a large number of pairs, :func:`cohere_pairs` can be much more</strong></dt>
<dd></dd>
<dt><strong>efficient than just calling :func:`cohere` for each pair, because</strong></dt>
<dd></dd>
<dt><strong>it caches most of the intensive computations.  If :math:`N` is the</strong></dt>
<dd></dd>
<dt><strong>number of pairs, this function is :math:`O(N)` for most of the</strong></dt>
<dd></dd>
<dt><strong>heavy lifting, whereas calling cohere for each pair is</strong></dt>
<dd></dd>
<dt><strong>:math:`O(N^2)`.  However, because of the caching, it is also more</strong></dt>
<dd></dd>
<dt><strong>memory intensive, making 2 additional complex arrays with</strong></dt>
<dd></dd>
<dt><strong>approximately the same number of elements as *X*.</strong></dt>
<dd></dd>
<dt><strong>See :file:`test/cohere_pairs_test.py` in the src tree for an</strong></dt>
<dd></dd>
<dt><strong>example script that shows that this :func:`cohere_pairs` and</strong></dt>
<dd></dd>
<dt><strong>:func:`cohere` give the same results for a given pair.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code class="xref py py-func docutils literal notranslate"><span class="pre">psd()</span></code></a></dt>
<dd>For information about the methods used to compute <span class="math notranslate nohighlight">\(P_{xy}\)</span>, <span class="math notranslate nohighlight">\(P_{xx}\)</span> and <span class="math notranslate nohighlight">\(P_{yy}\)</span>.</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.complex_spectrum">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">complex_spectrum</code><span class="sig-paren">(</span><em>x</em>, <em>Fs=None</em>, <em>window=None</em>, <em>pad_to=None</em>, <em>sides=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#complex_spectrum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.complex_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the complex-valued frequency spectrum of <em>x</em>.  Data is padded to a
length of <em>pad_to</em> and the windowing function <em>window</em> is applied to the
signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D array or sequence</span></dt>
<dd><p class="first last">Array or sequence containing the data</p>
</dd>
<dt><strong>Fs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd><p class="first last">The sampling frequency (samples per time unit).  It is used
to calculate the Fourier frequencies, freqs, in cycles per time
unit. The default value is 2.</p>
</dd>
<dt><strong>window</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable or ndarray</span></dt>
<dd><p class="first last">A function or a vector of length <em>NFFT</em>. To create window
vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-func docutils literal notranslate"><span class="pre">window_hanning()</span></code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code class="xref py py-func docutils literal notranslate"><span class="pre">window_none()</span></code></a>,
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.blackman()</span></code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.hamming()</span></code></a>,
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.bartlett()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.signal()</span></code>,
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.2.1)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.signal.get_window()</span></code></a>, etc. The default is
<a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-func docutils literal notranslate"><span class="pre">window_hanning()</span></code></a>.  If a function is passed as the
argument, it must take a data segment as an argument and
return the windowed version of the segment.</p>
</dd>
<dt><strong>sides</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{'default', 'onesided', 'twosided'}</span></dt>
<dd><p class="first last">Specifies which sides of the spectrum to return.  Default gives the
default behavior, which returns one-sided for real data and both
for complex data.  'onesided' forces the return of a one-sided
spectrum, while 'twosided' forces two-sided.</p>
</dd>
<dt><strong>pad_to</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of points to which the data segment is padded when
performing the FFT.  While not increasing the actual resolution of
the spectrum (the minimum distance between resolvable peaks),
this can give more points in the plot, allowing for more
detail. This corresponds to the <em>n</em> parameter in the call to fft().
The default is None, which sets <em>pad_to</em> equal to the length of the
input signal (i.e. no padding).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>spectrum</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D array</span></dt>
<dd><p class="first last">The values for the complex spectrum (complex valued)</p>
</dd>
<dt><strong>freqs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D array</span></dt>
<dd><p class="first last">The frequencies corresponding to the elements in <em>spectrum</em></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">magnitude_spectrum()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">magnitude_spectrum()</span></code></a> returns the absolute value of this function.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">angle_spectrum()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">angle_spectrum()</span></code></a> returns the angle of this function.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">phase_spectrum()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">phase_spectrum()</span></code></a> returns the phase (unwrapped angle) of this function.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code class="xref py py-func docutils literal notranslate"><span class="pre">specgram()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code class="xref py py-func docutils literal notranslate"><span class="pre">specgram()</span></code></a> can return the complex spectrum of segments within the signal.</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.contiguous_regions">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">contiguous_regions</code><span class="sig-paren">(</span><em>mask</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#contiguous_regions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.contiguous_regions" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>Moved to matplotlib.cbook</p>
</div>
<p>return a list of (ind0, ind1) such that mask[ind0:ind1].all() is
True and we cover all such regions</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.cross_from_above">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">cross_from_above</code><span class="sig-paren">(</span><em>x</em>, <em>threshold</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#cross_from_above"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.cross_from_above" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The cross_from_above function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>return the indices into <em>x</em> where <em>x</em> crosses some threshold from
below, e.g., the i's where:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">threshold</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">threshold</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#matplotlib.mlab.cross_from_below" title="matplotlib.mlab.cross_from_below"><code class="xref py py-func docutils literal notranslate"><span class="pre">cross_from_below()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.cross_from_below">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">cross_from_below</code><span class="sig-paren">(</span><em>x</em>, <em>threshold</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#cross_from_below"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.cross_from_below" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The cross_from_below function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>return the indices into <em>x</em> where <em>x</em> crosses some threshold from
below, e.g., the i's where:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">threshold</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">threshold</span>
</pre></div>
</div>
<p>Example code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="s1">&#39;-o&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>

<span class="n">ind</span> <span class="o">=</span> <span class="n">cross_from_below</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">ind</span> <span class="o">=</span> <span class="n">cross_from_above</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#matplotlib.mlab.cross_from_above" title="matplotlib.mlab.cross_from_above"><code class="xref py py-func docutils literal notranslate"><span class="pre">cross_from_above()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.csd">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">csd</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>NFFT=None</em>, <em>Fs=None</em>, <em>detrend=None</em>, <em>window=None</em>, <em>noverlap=None</em>, <em>pad_to=None</em>, <em>sides=None</em>, <em>scale_by_freq=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#csd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.csd" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the cross-spectral density.</p>
<p>Call signature:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">csd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">mlab</span><span class="o">.</span><span class="n">detrend_none</span><span class="p">,</span>
    <span class="n">window</span><span class="o">=</span><span class="n">mlab</span><span class="o">.</span><span class="n">window_hanning</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">sides</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<p>The cross spectral density <span class="math notranslate nohighlight">\(P_{xy}\)</span> by Welch's average
periodogram method.  The vectors <em>x</em> and <em>y</em> are divided into
<em>NFFT</em> length segments.  Each segment is detrended by function
<em>detrend</em> and windowed by function <em>window</em>.  <em>noverlap</em> gives
the length of the overlap between segments.  The product of
the direct FFTs of <em>x</em> and <em>y</em> are averaged over each segment
to compute <span class="math notranslate nohighlight">\(P_{xy}\)</span>, with a scaling to correct for power
loss due to windowing.</p>
<p>If len(<em>x</em>) &lt; <em>NFFT</em> or len(<em>y</em>) &lt; <em>NFFT</em>, they will be zero
padded to <em>NFFT</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x, y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D arrays or sequences</span></dt>
<dd><p class="first last">Arrays or sequences containing the data</p>
</dd>
<dt><strong>Fs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd><p class="first last">The sampling frequency (samples per time unit).  It is used
to calculate the Fourier frequencies, freqs, in cycles per time
unit. The default value is 2.</p>
</dd>
<dt><strong>window</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable or ndarray</span></dt>
<dd><p class="first last">A function or a vector of length <em>NFFT</em>. To create window
vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-func docutils literal notranslate"><span class="pre">window_hanning()</span></code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code class="xref py py-func docutils literal notranslate"><span class="pre">window_none()</span></code></a>,
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.blackman()</span></code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.hamming()</span></code></a>,
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.bartlett()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.signal()</span></code>,
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.2.1)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.signal.get_window()</span></code></a>, etc. The default is
<a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-func docutils literal notranslate"><span class="pre">window_hanning()</span></code></a>.  If a function is passed as the
argument, it must take a data segment as an argument and
return the windowed version of the segment.</p>
</dd>
<dt><strong>sides</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{'default', 'onesided', 'twosided'}</span></dt>
<dd><p class="first last">Specifies which sides of the spectrum to return.  Default gives the
default behavior, which returns one-sided for real data and both
for complex data.  'onesided' forces the return of a one-sided
spectrum, while 'twosided' forces two-sided.</p>
</dd>
<dt><strong>pad_to</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of points to which the data segment is padded when
performing the FFT.  This can be different from <em>NFFT</em>, which
specifies the number of data points used.  While not increasing
the actual resolution of the spectrum (the minimum distance between
resolvable peaks), this can give more points in the plot,
allowing for more detail. This corresponds to the <em>n</em> parameter
in the call to fft(). The default is None, which sets <em>pad_to</em>
equal to <em>NFFT</em></p>
</dd>
<dt><strong>NFFT</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of data points used in each block for the FFT.
A power 2 is most efficient.  The default value is 256.
This should <em>NOT</em> be used to get zero padding, or the scaling of the
result will be incorrect. Use <em>pad_to</em> for this instead.</p>
</dd>
<dt><strong>detrend</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{'default', 'constant', 'mean', 'linear', 'none'} or callable</span></dt>
<dd><p class="first last">The function applied to each segment before fft-ing,
designed to remove the mean or linear trend.  Unlike in
MATLAB, where the <em>detrend</em> parameter is a vector, in
matplotlib is it a function.  The <a class="reference internal" href="#module-matplotlib.mlab" title="matplotlib.mlab"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mlab</span></code></a>
module defines <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_none()</span></code></a>,
<a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_mean()</span></code></a>, and
<a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_linear()</span></code></a>, but you can use
a custom function as well.  You can also use a string to choose
one of the functions.  'default', 'constant', and 'mean' call
<a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_mean()</span></code></a>.  'linear' calls
<a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_linear()</span></code></a>.  'none' calls
<a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_none()</span></code></a>.</p>
</dd>
<dt><strong>scale_by_freq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Specifies whether the resulting density values should be scaled
by the scaling frequency, which gives density in units of Hz^-1.
This allows for integration over the returned frequency values.
The default is True for MATLAB compatibility.</p>
</dd>
<dt><strong>noverlap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The number of points of overlap between segments.
The default value is 0 (no overlap).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Pxy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D array</span></dt>
<dd><p class="first last">The values for the cross spectrum <code class="xref py py-obj docutils literal notranslate"><span class="pre">P_{xy}</span></code> before scaling (real valued)</p>
</dd>
<dt><strong>freqs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D array</span></dt>
<dd><p class="first last">The frequencies corresponding to the elements in <em>Pxy</em></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code class="xref py py-func docutils literal notranslate"><span class="pre">psd()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code class="xref py py-func docutils literal notranslate"><span class="pre">psd()</span></code></a> is the equivalent to setting y=x.</dd>
</dl>
</div>
<p class="rubric">References</p>
<p>Bendat &amp; Piersol -- Random Data: Analysis and Measurement Procedures, John
Wiley &amp; Sons (1986)</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.csv2rec">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">csv2rec</code><span class="sig-paren">(</span><em>fname</em>, <em>comments='#'</em>, <em>skiprows=0</em>, <em>checkrows=0</em>, <em>delimiter='</em>, <em>'</em>, <em>converterd=None</em>, <em>names=None</em>, <em>missing=''</em>, <em>missingd=None</em>, <em>use_mrecords=False</em>, <em>dayfirst=False</em>, <em>yearfirst=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#csv2rec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.csv2rec" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The csv2rec function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Load data from comma/space/tab delimited file in <em>fname</em> into a
numpy record array and return the record array.</p>
<p>If <em>names</em> is <em>None</em>, a header row is required to automatically
assign the recarray names.  The headers will be lower cased,
spaces will be converted to underscores, and illegal attribute
name characters removed.  If <em>names</em> is not <em>None</em>, it is a
sequence of names to use for the column names.  In this case, it
is assumed there is no header row.</p>
<ul>
<li><p class="first"><em>fname</em>: can be a filename or a file handle.  Support for gzipped
files is automatic, if the filename ends in '.gz'</p>
</li>
<li><p class="first"><em>comments</em>: the character used to indicate the start of a comment
in the file, or <em>None</em> to switch off the removal of comments</p>
</li>
<li><p class="first"><em>skiprows</em>: is the number of rows from the top to skip</p>
</li>
<li><p class="first"><em>checkrows</em>: is the number of rows to check to validate the column
data type.  When set to zero all rows are validated.</p>
</li>
<li><p class="first"><em>converterd</em>: if not <em>None</em>, is a dictionary mapping column number or
munged column name to a converter function.</p>
</li>
<li><p class="first"><em>names</em>: if not None, is a list of header names.  In this case, no
header will be read from the file</p>
</li>
<li><p class="first"><em>missingd</em> is a dictionary mapping munged column names to field values
which signify that the field does not contain actual data and should
be masked, e.g., '0000-00-00' or 'unused'</p>
</li>
<li><p class="first"><em>missing</em>: a string whose value signals a missing field regardless of
the column it appears in</p>
</li>
<li><p class="first"><em>use_mrecords</em>: if True, return an mrecords.fromrecords record array if
any of the data are missing</p>
</li>
<li><p class="first"><em>dayfirst</em>: default is False so that MM-DD-YY has precedence over
DD-MM-YY.  See
<a class="reference external" href="http://labix.org/python-dateutil#head-b95ce2094d189a89f80f5ae52a05b4ab7b41af47">http://labix.org/python-dateutil#head-b95ce2094d189a89f80f5ae52a05b4ab7b41af47</a>
for further information.</p>
</li>
<li><p class="first"><em>yearfirst</em>: default is False so that MM-DD-YY has precedence over
YY-MM-DD. See
<a class="reference external" href="http://labix.org/python-dateutil#head-b95ce2094d189a89f80f5ae52a05b4ab7b41af47">http://labix.org/python-dateutil#head-b95ce2094d189a89f80f5ae52a05b4ab7b41af47</a>
for further information.</p>
<p>If no rows are found, <em>None</em> is returned</p>
</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.csvformat_factory">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">csvformat_factory</code><span class="sig-paren">(</span><em>format</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#csvformat_factory"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.csvformat_factory" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The csvformat_factory function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p></p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.demean">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">demean</code><span class="sig-paren">(</span><em>x</em>, <em>axis=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#demean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.demean" title="Permalink to this definition">¶</a></dt>
<dd><p>Return x minus its mean along the specified axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array or sequence</span></dt>
<dd><p class="first last">Array or sequence containing the data
Can have any dimensionality</p>
</dd>
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The axis along which to take the mean.  See numpy.mean for a
description of this argument.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">delinear()</span></code></p>
<dl class="last docutils">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">denone()</span></code></dt>
<dd><code class="xref py py-func docutils literal notranslate"><span class="pre">delinear()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">denone()</span></code> are other detrend algorithms.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_mean()</span></code></a></dt>
<dd>This function is the same as <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_mean()</span></code></a> except for the default <em>axis</em>.</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.detrend">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">detrend</code><span class="sig-paren">(</span><em>x</em>, <em>key=None</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#detrend"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.detrend" title="Permalink to this definition">¶</a></dt>
<dd><p>Return x with its trend removed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array or sequence</span></dt>
<dd><p class="first last">Array or sequence containing the data.</p>
</dd>
<dt><strong>key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">[ 'default' | 'constant' | 'mean' | 'linear' | 'none'] or function</span></dt>
<dd><p class="first last">Specifies the detrend algorithm to use. 'default' is 'mean', which is
the same as <a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_mean()</span></code></a>. 'constant' is the same. 'linear' is
the same as <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_linear()</span></code></a>. 'none' is the same as
<a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_none()</span></code></a>. The default is 'mean'. See the corresponding
functions for more details regarding the algorithms. Can also be a
function that carries out the detrend operation.</p>
</dd>
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The axis along which to do the detrending.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_mean()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_mean()</span></code></a> implements the 'mean' algorithm.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_linear()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_linear()</span></code></a> implements the 'linear' algorithm.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_none()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_none()</span></code></a> implements the 'none' algorithm.</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.detrend_linear">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">detrend_linear</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#detrend_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.detrend_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Return x minus best fit line; 'linear' detrending.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">0-D or 1-D array or sequence</span></dt>
<dd><p class="first last">Array or sequence containing the data</p>
</dd>
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The axis along which to take the mean.  See numpy.mean for a
description of this argument.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="docutils">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">delinear()</span></code></dt>
<dd>This function is the same as <code class="xref py py-func docutils literal notranslate"><span class="pre">delinear()</span></code> except for the default <em>axis</em>.</dd>
</dl>
<p><a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_mean()</span></code></a></p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_none()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_mean()</span></code></a> and <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_none()</span></code></a> are other detrend algorithms.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.detrend" title="matplotlib.mlab.detrend"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.detrend" title="matplotlib.mlab.detrend"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend()</span></code></a> is a wrapper around all the detrend algorithms.</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.detrend_mean">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">detrend_mean</code><span class="sig-paren">(</span><em>x</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#detrend_mean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.detrend_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Return x minus the mean(x).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array or sequence</span></dt>
<dd><p class="first last">Array or sequence containing the data
Can have any dimensionality</p>
</dd>
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The axis along which to take the mean.  See numpy.mean for a
description of this argument.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.demean" title="matplotlib.mlab.demean"><code class="xref py py-func docutils literal notranslate"><span class="pre">demean()</span></code></a></dt>
<dd>This function is the same as <a class="reference internal" href="#matplotlib.mlab.demean" title="matplotlib.mlab.demean"><code class="xref py py-func docutils literal notranslate"><span class="pre">demean()</span></code></a> except for the default <em>axis</em>.</dd>
</dl>
<p><a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_linear()</span></code></a></p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_none()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_linear()</span></code></a> and <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_none()</span></code></a> are other detrend algorithms.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.detrend" title="matplotlib.mlab.detrend"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.detrend" title="matplotlib.mlab.detrend"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend()</span></code></a> is a wrapper around all the detrend algorithms.</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.detrend_none">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">detrend_none</code><span class="sig-paren">(</span><em>x</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#detrend_none"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.detrend_none" title="Permalink to this definition">¶</a></dt>
<dd><p>Return x: no detrending.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">any object</span></dt>
<dd><p class="first last">An object containing the data</p>
</dd>
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">This parameter is ignored.
It is included for compatibility with detrend_mean</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="docutils">
<dt><code class="xref py py-func docutils literal notranslate"><span class="pre">denone()</span></code></dt>
<dd>This function is the same as <code class="xref py py-func docutils literal notranslate"><span class="pre">denone()</span></code> except for the default <em>axis</em>, which has no effect.</dd>
</dl>
<p><a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_mean()</span></code></a></p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_linear()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_mean()</span></code></a> and <a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_linear()</span></code></a> are other detrend algorithms.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.detrend" title="matplotlib.mlab.detrend"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.detrend" title="matplotlib.mlab.detrend"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend()</span></code></a> is a wrapper around all the detrend algorithms.</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.dist">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">dist</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.dist" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>numpy.hypot</p>
</div>
<p>Return the distance between two points.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.dist_point_to_segment">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">dist_point_to_segment</code><span class="sig-paren">(</span><em>p</em>, <em>s0</em>, <em>s1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#dist_point_to_segment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.dist_point_to_segment" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The dist_point_to_segment function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Get the distance of a point to a segment.</p>
<blockquote>
<div><em>p</em>, <em>s0</em>, <em>s1</em> are <em>xy</em> sequences</div></blockquote>
<p>This algorithm from
<a class="reference external" href="http://geomalgorithms.com/a02-_lines.html">http://geomalgorithms.com/a02-_lines.html</a></p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.distances_along_curve">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">distances_along_curve</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#distances_along_curve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.distances_along_curve" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The distances_along_curve function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Computes the distance between a set of successive points in <em>N</em> dimensions.</p>
<p>Where <em>X</em> is an <em>M</em> x <em>N</em> array or matrix.  The distances between
successive rows is computed.  Distance is the standard Euclidean
distance.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.donothing_callback">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">donothing_callback</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#donothing_callback"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.donothing_callback" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The donothing_callback function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p></p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.entropy">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">entropy</code><span class="sig-paren">(</span><em>y</em>, <em>bins</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#entropy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.entropy" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>scipy.stats.entropy</p>
</div>
<p>Return the entropy of the data in <em>y</em> in units of nat.</p>
<div class="math notranslate nohighlight">
\[-\sum p_i \ln(p_i)\]</div>
<p>where <span class="math notranslate nohighlight">\(p_i\)</span> is the probability of observing <em>y</em> in the
<span class="math notranslate nohighlight">\(i^{th}\)</span> bin of <em>bins</em>.  <em>bins</em> can be a number of bins or a
range of bins; see <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.histogram.html#numpy.histogram" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.histogram()</span></code></a>.</p>
<p>Compare <em>S</em> with analytic calculation for a Gaussian:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">+</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">randn</span><span class="p">(</span><span class="mi">200000</span><span class="p">)</span>
<span class="n">Sanalytic</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">sigma</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.exp_safe">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">exp_safe</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#exp_safe"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.exp_safe" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>numpy.exp</p>
</div>
<p>Compute exponentials which safely underflow to zero.</p>
<p>Slow, but convenient to use. Note that numpy provides proper
floating point exception handling with access to the underlying
hardware.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.fftsurr">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">fftsurr</code><span class="sig-paren">(</span><em>x</em>, <em>detrend=&lt;function detrend_none&gt;</em>, <em>window=&lt;function window_none&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#fftsurr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.fftsurr" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The fftsurr function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Compute an FFT phase randomized surrogate of <em>x</em>.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.find">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">find</code><span class="sig-paren">(</span><em>condition</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#find"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.find" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The find function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Return the indices where ravel(condition) is true</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.frange">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">frange</code><span class="sig-paren">(</span><em>xini</em>, <em>xfin=None</em>, <em>delta=None</em>, <em>**kw</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#frange"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.frange" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>numpy.arange</p>
</div>
<p>frange([start,] stop[, step, keywords]) -&gt; array of floats</p>
<p>Return a numpy ndarray containing a progression of floats. Similar to
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html#numpy.arange" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.arange()</span></code></a>, but defaults to a closed interval.</p>
<p><code class="docutils literal notranslate"><span class="pre">frange(x0,</span> <span class="pre">x1)</span></code> returns <code class="docutils literal notranslate"><span class="pre">[x0,</span> <span class="pre">x0+1,</span> <span class="pre">x0+2,</span> <span class="pre">...,</span> <span class="pre">x1]</span></code>; <em>start</em>
defaults to 0, and the endpoint <em>is included</em>. This behavior is
different from that of <code class="xref py py-func docutils literal notranslate"><span class="pre">range()</span></code> and
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html#numpy.arange" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.arange()</span></code></a>. This is deliberate, since <a class="reference internal" href="#matplotlib.mlab.frange" title="matplotlib.mlab.frange"><code class="xref py py-func docutils literal notranslate"><span class="pre">frange()</span></code></a>
will probably be more useful for generating lists of points for
function evaluation, and endpoints are often desired in this
use. The usual behavior of <code class="xref py py-func docutils literal notranslate"><span class="pre">range()</span></code> can be obtained by
setting the keyword <em>closed</em> = 0, in this case, <a class="reference internal" href="#matplotlib.mlab.frange" title="matplotlib.mlab.frange"><code class="xref py py-func docutils literal notranslate"><span class="pre">frange()</span></code></a>
basically becomes :func:numpy.arange`.</p>
<p>When <em>step</em> is given, it specifies the increment (or
decrement). All arguments can be floating point numbers.</p>
<p><code class="docutils literal notranslate"><span class="pre">frange(x0,x1,d)</span></code> returns <code class="docutils literal notranslate"><span class="pre">[x0,x0+d,x0+2d,...,xfin]</span></code> where
<em>xfin</em> &lt;= <em>x1</em>.</p>
<p><a class="reference internal" href="#matplotlib.mlab.frange" title="matplotlib.mlab.frange"><code class="xref py py-func docutils literal notranslate"><span class="pre">frange()</span></code></a> can also be called with the keyword <em>npts</em>. This
sets the number of points the list should contain (and overrides
the value <em>step</em> might have been given). <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html#numpy.arange" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.arange()</span></code></a>
doesn't offer this option.</p>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">frange</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">array([ 0.,  1.,  2.,  3.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">closed</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([ 0.,  1.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([1, 3, 5])   or 1,3,5,7, depending on floating point vagueries</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">frange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mf">6.5</span><span class="p">,</span><span class="n">npts</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">array([ 1.   ,  2.375,  3.75 ,  5.125,  6.5  ])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.get_formatd">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">get_formatd</code><span class="sig-paren">(</span><em>r</em>, <em>formatd=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#get_formatd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.get_formatd" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The get_formatd function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>build a formatd guaranteed to have a key for every dtype name</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.get_sparse_matrix">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">get_sparse_matrix</code><span class="sig-paren">(</span><em>M</em>, <em>N</em>, <em>frac=0.1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#get_sparse_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.get_sparse_matrix" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The get_sparse_matrix function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Return a <em>M</em> x <em>N</em> sparse matrix with <em>frac</em> elements randomly
filled.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.get_xyz_where">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">get_xyz_where</code><span class="sig-paren">(</span><em>Z</em>, <em>Cond</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#get_xyz_where"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.get_xyz_where" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The get_xyz_where function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p><em>Z</em> and <em>Cond</em> are <em>M</em> x <em>N</em> matrices.  <em>Z</em> are data and <em>Cond</em> is
a boolean matrix where some condition is satisfied.  Return value
is (<em>x</em>, <em>y</em>, <em>z</em>) where <em>x</em> and <em>y</em> are the indices into <em>Z</em> and
<em>z</em> are the values of <em>Z</em> at those indices.  <em>x</em>, <em>y</em>, and <em>z</em> are
1D arrays.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.griddata">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">griddata</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em>, <em>xi</em>, <em>yi</em>, <em>interp='nn'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#griddata"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.griddata" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The griddata function was deprecated in Matplotlib 2.2 and will be removed in 3.1. Use scipy.interpolate.griddata instead.</p>
</div>
<p>Interpolates from a nonuniformly spaced grid to some other grid.</p>
<p>Fits a surface of the form z = f(<code class="xref py py-obj docutils literal notranslate"><span class="pre">x</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">y</span></code>) to the data in the
(usually) nonuniformly spaced vectors (<code class="xref py py-obj docutils literal notranslate"><span class="pre">x</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">y</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">z</span></code>), then
interpolates this surface at the points specified by
(<code class="xref py py-obj docutils literal notranslate"><span class="pre">xi</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">yi</span></code>) to produce <code class="xref py py-obj docutils literal notranslate"><span class="pre">zi</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x, y, z</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d array_like</span></dt>
<dd><p class="first last">Coordinates of grid points to interpolate from.</p>
</dd>
<dt><strong>xi, yi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1d or 2d array_like</span></dt>
<dd><p class="first last">Coordinates of grid points to interpolate to.</p>
</dd>
<dt><strong>interp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string key from {'nn', 'linear'}</span></dt>
<dd><p class="first last">Interpolation algorithm, either 'nn' for natural neighbor, or
'linear' for linear interpolation.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>2d float array</strong></dt>
<dd><p class="first last">Array of values interpolated at (<code class="xref py py-obj docutils literal notranslate"><span class="pre">xi</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">yi</span></code>) points.  Array
will be masked is any of (<code class="xref py py-obj docutils literal notranslate"><span class="pre">xi</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">yi</span></code>) are outside the convex
hull of (<code class="xref py py-obj docutils literal notranslate"><span class="pre">x</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">y</span></code>).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If <code class="xref py py-obj docutils literal notranslate"><span class="pre">interp</span></code> is 'nn' (the default), uses natural neighbor
interpolation based on Delaunay triangulation.  This option is
only available if the mpl_toolkits.natgrid module is installed.
This can be downloaded from <a class="reference external" href="https://github.com/matplotlib/natgrid">https://github.com/matplotlib/natgrid</a>.
The (<code class="xref py py-obj docutils literal notranslate"><span class="pre">xi</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">yi</span></code>) grid must be regular and monotonically increasing
in this case.</p>
<p>If <code class="xref py py-obj docutils literal notranslate"><span class="pre">interp</span></code> is 'linear', linear interpolation is used via
matplotlib.tri.LinearTriInterpolator.</p>
<p>Instead of using <a class="reference internal" href="#matplotlib.mlab.griddata" title="matplotlib.mlab.griddata"><code class="xref py py-obj docutils literal notranslate"><span class="pre">griddata</span></code></a>, more flexible functionality and other
interpolation options are available using a
matplotlib.tri.Triangulation and a matplotlib.tri.TriInterpolator.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.identity">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">identity</code><span class="sig-paren">(</span><em>n</em>, <em>rank=2</em>, <em>dtype='l'</em>, <em>typecode=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#identity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.identity" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>numpy.identity</p>
</div>
<p>Returns the identity matrix of shape (<em>n</em>, <em>n</em>, ..., <em>n</em>) (rank <em>r</em>).</p>
<p>For ranks higher than 2, this object is simply a multi-index Kronecker
delta:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>                    <span class="o">/</span>  <span class="mi">1</span>  <span class="k">if</span> <span class="n">i0</span><span class="o">=</span><span class="n">i1</span><span class="o">=...=</span><span class="n">iR</span><span class="p">,</span>
<span class="nb">id</span><span class="p">[</span><span class="n">i0</span><span class="p">,</span><span class="n">i1</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">iR</span><span class="p">]</span> <span class="o">=</span> <span class="o">-|</span>
                    \  <span class="mi">0</span>  <span class="n">otherwise</span><span class="o">.</span>
</pre></div>
</div>
<p>Optionally a <em>dtype</em> (or typecode) may be given (it defaults to 'l').</p>
<p>Since rank defaults to 2, this function behaves in the default case (when
only <em>n</em> is given) like <code class="docutils literal notranslate"><span class="pre">numpy.identity(n)</span></code> -- but surprisingly, it is
much faster.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.inside_poly">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">inside_poly</code><span class="sig-paren">(</span><em>points</em>, <em>verts</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#inside_poly"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.inside_poly" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The inside_poly function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p><em>points</em> is a sequence of <em>x</em>, <em>y</em> points.
<em>verts</em> is a sequence of <em>x</em>, <em>y</em> vertices of a polygon.</p>
<p>Return value is a sequence of indices into points for the points
that are inside the polygon.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.is_closed_polygon">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">is_closed_polygon</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#is_closed_polygon"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.is_closed_polygon" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The is_closed_polygon function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Tests whether first and last object in a sequence are the same.  These are
presumably coordinates on a polygonal curve, in which case this function
tests if that curve is closed.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.ispower2">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">ispower2</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#ispower2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.ispower2" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The ispower2 function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Returns the log base 2 of <em>n</em> if <em>n</em> is a power of 2, zero otherwise.</p>
<p>Note the potential ambiguity if <em>n</em> == 1: 2**0 == 1, interpret accordingly.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.isvector">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">isvector</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#isvector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.isvector" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The isvector function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Like the MATLAB function with the same name, returns <em>True</em>
if the supplied numpy array or matrix <em>X</em> looks like a vector,
meaning it has a one non-singleton axis (i.e., it can have
multiple axes, but all must have length 1, except for one of
them).</p>
<p>If you just want to see if the array has 1 axis, use X.ndim == 1.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.l1norm">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">l1norm</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#l1norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.l1norm" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The l1norm function was deprecated in Matplotlib 2.2 and will be removed in 3.1. Use numpy.linalg.norm(a, ord=1) instead.</p>
</div>
<p>Return the <em>l1</em> norm of <em>a</em>, flattened out.</p>
<p>Implemented as a separate function (not a call to <code class="xref py py-func docutils literal notranslate"><span class="pre">norm()</span></code> for speed).</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.l2norm">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">l2norm</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#l2norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.l2norm" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The l2norm function was deprecated in Matplotlib 2.2 and will be removed in 3.1. Use numpy.linalg.norm(a, ord=2) instead.</p>
</div>
<p>Return the <em>l2</em> norm of <em>a</em>, flattened out.</p>
<p>Implemented as a separate function (not a call to <code class="xref py py-func docutils literal notranslate"><span class="pre">norm()</span></code> for speed).</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.less_simple_linear_interpolation">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">less_simple_linear_interpolation</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>xi</em>, <em>extrap=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#less_simple_linear_interpolation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.less_simple_linear_interpolation" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The less_simple_linear_interpolation function was deprecated in Matplotlib 2.2 and will be removed in 3.1. Use numpy.interp instead.</p>
</div>
<p>This function provides simple (but somewhat less so than
<code class="xref py py-func docutils literal notranslate"><span class="pre">cbook.simple_linear_interpolation()</span></code>) linear interpolation.
<code class="xref py py-func docutils literal notranslate"><span class="pre">simple_linear_interpolation()</span></code> will give a list of point
between a start and an end, while this does true linear
interpolation at an arbitrary set of points.</p>
<p>This is very inefficient linear interpolation meant to be used
only for a small number of points in relatively non-intensive use
cases.  For real linear interpolation, use scipy.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.log2">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">log2</code><span class="sig-paren">(</span><em>x</em>, <em>ln2=0.6931471805599453</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#log2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.log2" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>numpy.log2</p>
</div>
<p>Return the log(<em>x</em>) in base 2.</p>
<p>This is a _slow_ function but which is guaranteed to return the correct
integer value if the input is an integer exact power of 2.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.logspace">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">logspace</code><span class="sig-paren">(</span><em>xmin</em>, <em>xmax</em>, <em>N</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#logspace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.logspace" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The logspace function was deprecated in Matplotlib 2.2 and will be removed in 3.1. Use numpy.logspace or numpy.geomspace instead.</p>
</div>
<p>Return N values logarithmically spaced between xmin and xmax.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.longest_contiguous_ones">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">longest_contiguous_ones</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#longest_contiguous_ones"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.longest_contiguous_ones" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The longest_contiguous_ones function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Return the indices of the longest stretch of contiguous ones in <em>x</em>,
assuming <em>x</em> is a vector of zeros and ones.  If there are two
equally long stretches, pick the first.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.longest_ones">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">longest_ones</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#longest_ones"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.longest_ones" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The longest_ones function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>alias for longest_contiguous_ones</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.magnitude_spectrum">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">magnitude_spectrum</code><span class="sig-paren">(</span><em>x</em>, <em>Fs=None</em>, <em>window=None</em>, <em>pad_to=None</em>, <em>sides=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#magnitude_spectrum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.magnitude_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the magnitude (absolute value) of the frequency spectrum of
<em>x</em>.  Data is padded to a length of <em>pad_to</em> and the windowing function
<em>window</em> is applied to the signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D array or sequence</span></dt>
<dd><p class="first last">Array or sequence containing the data</p>
</dd>
<dt><strong>Fs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd><p class="first last">The sampling frequency (samples per time unit).  It is used
to calculate the Fourier frequencies, freqs, in cycles per time
unit. The default value is 2.</p>
</dd>
<dt><strong>window</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable or ndarray</span></dt>
<dd><p class="first last">A function or a vector of length <em>NFFT</em>. To create window
vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-func docutils literal notranslate"><span class="pre">window_hanning()</span></code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code class="xref py py-func docutils literal notranslate"><span class="pre">window_none()</span></code></a>,
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.blackman()</span></code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.hamming()</span></code></a>,
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.bartlett()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.signal()</span></code>,
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.2.1)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.signal.get_window()</span></code></a>, etc. The default is
<a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-func docutils literal notranslate"><span class="pre">window_hanning()</span></code></a>.  If a function is passed as the
argument, it must take a data segment as an argument and
return the windowed version of the segment.</p>
</dd>
<dt><strong>sides</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{'default', 'onesided', 'twosided'}</span></dt>
<dd><p class="first last">Specifies which sides of the spectrum to return.  Default gives the
default behavior, which returns one-sided for real data and both
for complex data.  'onesided' forces the return of a one-sided
spectrum, while 'twosided' forces two-sided.</p>
</dd>
<dt><strong>pad_to</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of points to which the data segment is padded when
performing the FFT.  While not increasing the actual resolution of
the spectrum (the minimum distance between resolvable peaks),
this can give more points in the plot, allowing for more
detail. This corresponds to the <em>n</em> parameter in the call to fft().
The default is None, which sets <em>pad_to</em> equal to the length of the
input signal (i.e. no padding).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>spectrum</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D array</span></dt>
<dd><p class="first last">The values for the magnitude spectrum (real valued)</p>
</dd>
<dt><strong>freqs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D array</span></dt>
<dd><p class="first last">The frequencies corresponding to the elements in <em>spectrum</em></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code class="xref py py-func docutils literal notranslate"><span class="pre">psd()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code class="xref py py-func docutils literal notranslate"><span class="pre">psd()</span></code></a> returns the power spectral density.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex_spectrum()</span></code></a></dt>
<dd>This function returns the absolute value of <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex_spectrum()</span></code></a>.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">angle_spectrum()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">angle_spectrum()</span></code></a> returns the angles of the corresponding frequencies.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">phase_spectrum()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">phase_spectrum()</span></code></a> returns the phase (unwrapped angle) of the corresponding frequencies.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code class="xref py py-func docutils literal notranslate"><span class="pre">specgram()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code class="xref py py-func docutils literal notranslate"><span class="pre">specgram()</span></code></a> can return the magnitude spectrum of segments within the signal.</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.movavg">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">movavg</code><span class="sig-paren">(</span><em>x</em>, <em>n</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#movavg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.movavg" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The movavg function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Compute the len(<em>n</em>) moving average of <em>x</em>.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.norm_flat">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">norm_flat</code><span class="sig-paren">(</span><em>a</em>, <em>p=2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#norm_flat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.norm_flat" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The norm_flat function was deprecated in Matplotlib 2.2 and will be removed in 3.1. Use numpy.linalg.norm(a.flat, ord=p) instead.</p>
</div>
<p>norm(a,p=2) -&gt; l-p norm of a.flat</p>
<p>Return the l-p norm of <em>a</em>, considered as a flat array.  This is NOT a true
matrix norm, since arrays of arbitrary rank are always flattened.</p>
<p><em>p</em> can be a number or the string 'Infinity' to get the L-infinity norm.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.normpdf">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">normpdf</code><span class="sig-paren">(</span><em>x</em>, <em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#normpdf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.normpdf" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>scipy.stats.norm.pdf</p>
</div>
<p>Return the normal pdf evaluated at <em>x</em>; args provides <em>mu</em>, <em>sigma</em></p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.offset_line">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">offset_line</code><span class="sig-paren">(</span><em>y</em>, <em>yerr</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#offset_line"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.offset_line" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The offset_line function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Offsets an array <em>y</em> by +/- an error and returns a tuple
(y - err, y + err).</p>
<p>The error term can be:</p>
<ul>
<li><p class="first">A scalar. In this case, the returned tuple is obvious.</p>
</li>
<li><p class="first">A vector of the same length as <em>y</em>. The quantities y +/- err are computed
component-wise.</p>
</li>
<li><p class="first">A tuple of length 2. In this case, yerr[0] is the error below <em>y</em> and
yerr[1] is error above <em>y</em>. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">y_minus</span><span class="p">,</span> <span class="n">y_plus</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">offset_line</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_minus</span><span class="p">,</span> <span class="n">y2</span><span class="o">=</span><span class="n">y_plus</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.path_length">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">path_length</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#path_length"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.path_length" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The path_length function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Computes the distance travelled along a polygonal curve in <em>N</em> dimensions.</p>
<p>Where <em>X</em> is an <em>M</em> x <em>N</em> array or matrix.  Returns an array of
length <em>M</em> consisting of the distance along the curve at each point
(i.e., the rows of <em>X</em>).</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.phase_spectrum">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">phase_spectrum</code><span class="sig-paren">(</span><em>x</em>, <em>Fs=None</em>, <em>window=None</em>, <em>pad_to=None</em>, <em>sides=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#phase_spectrum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.phase_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the phase of the frequency spectrum (unwrapped angle spectrum) of
<em>x</em>.  Data is padded to a length of <em>pad_to</em> and the windowing function
<em>window</em> is applied to the signal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D array or sequence</span></dt>
<dd><p class="first last">Array or sequence containing the data</p>
</dd>
<dt><strong>Fs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd><p class="first last">The sampling frequency (samples per time unit).  It is used
to calculate the Fourier frequencies, freqs, in cycles per time
unit. The default value is 2.</p>
</dd>
<dt><strong>window</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable or ndarray</span></dt>
<dd><p class="first last">A function or a vector of length <em>NFFT</em>. To create window
vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-func docutils literal notranslate"><span class="pre">window_hanning()</span></code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code class="xref py py-func docutils literal notranslate"><span class="pre">window_none()</span></code></a>,
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.blackman()</span></code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.hamming()</span></code></a>,
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.bartlett()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.signal()</span></code>,
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.2.1)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.signal.get_window()</span></code></a>, etc. The default is
<a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-func docutils literal notranslate"><span class="pre">window_hanning()</span></code></a>.  If a function is passed as the
argument, it must take a data segment as an argument and
return the windowed version of the segment.</p>
</dd>
<dt><strong>sides</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{'default', 'onesided', 'twosided'}</span></dt>
<dd><p class="first last">Specifies which sides of the spectrum to return.  Default gives the
default behavior, which returns one-sided for real data and both
for complex data.  'onesided' forces the return of a one-sided
spectrum, while 'twosided' forces two-sided.</p>
</dd>
<dt><strong>pad_to</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of points to which the data segment is padded when
performing the FFT.  While not increasing the actual resolution of
the spectrum (the minimum distance between resolvable peaks),
this can give more points in the plot, allowing for more
detail. This corresponds to the <em>n</em> parameter in the call to fft().
The default is None, which sets <em>pad_to</em> equal to the length of the
input signal (i.e. no padding).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>spectrum</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D array</span></dt>
<dd><p class="first last">The values for the phase spectrum in radians (real valued)</p>
</dd>
<dt><strong>freqs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D array</span></dt>
<dd><p class="first last">The frequencies corresponding to the elements in <em>spectrum</em></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex_spectrum()</span></code></a></dt>
<dd>This function returns the angle value of <a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">complex_spectrum()</span></code></a>.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">magnitude_spectrum()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">magnitude_spectrum()</span></code></a> returns the magnitudes of the corresponding frequencies.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">angle_spectrum()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">angle_spectrum()</span></code></a> returns the wrapped version of this function.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code class="xref py py-func docutils literal notranslate"><span class="pre">specgram()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code class="xref py py-func docutils literal notranslate"><span class="pre">specgram()</span></code></a> can return the phase spectrum of segments within the signal.</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.poly_below">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">poly_below</code><span class="sig-paren">(</span><em>xmin</em>, <em>xs</em>, <em>ys</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#poly_below"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.poly_below" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The poly_below function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Given a sequence of <em>xs</em> and <em>ys</em>, return the vertices of a
polygon that has a horizontal base at <em>xmin</em> and an upper bound at
the <em>ys</em>.  <em>xmin</em> is a scalar.</p>
<p>Intended for use with <a class="reference internal" href="_as_gen/matplotlib.axes.Axes.fill.html#matplotlib.axes.Axes.fill" title="matplotlib.axes.Axes.fill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">matplotlib.axes.Axes.fill()</span></code></a>, e.g.,:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span> <span class="o">=</span> <span class="n">poly_below</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.poly_between">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">poly_between</code><span class="sig-paren">(</span><em>x</em>, <em>ylower</em>, <em>yupper</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#poly_between"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.poly_between" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The poly_between function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Given a sequence of <em>x</em>, <em>ylower</em> and <em>yupper</em>, return the polygon
that fills the regions between them.  <em>ylower</em> or <em>yupper</em> can be
scalar or iterable.  If they are iterable, they must be equal in
length to <em>x</em>.</p>
<p>Return value is <em>x</em>, <em>y</em> arrays for use with
<a class="reference internal" href="_as_gen/matplotlib.axes.Axes.fill.html#matplotlib.axes.Axes.fill" title="matplotlib.axes.Axes.fill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">matplotlib.axes.Axes.fill()</span></code></a>.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.prctile">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">prctile</code><span class="sig-paren">(</span><em>x</em>, <em>p=(0.0</em>, <em>25.0</em>, <em>50.0</em>, <em>75.0</em>, <em>100.0)</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#prctile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.prctile" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>numpy.percentile</p>
</div>
<p>Return the percentiles of <em>x</em>.  <em>p</em> can either be a sequence of
percentile values or a scalar.  If <em>p</em> is a sequence, the ith
element of the return sequence is the <em>p*(i)-th percentile of *x</em>.
If <em>p</em> is a scalar, the largest value of <em>x</em> less than or equal to
the <em>p</em> percentage point in the sequence is returned.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.prctile_rank">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">prctile_rank</code><span class="sig-paren">(</span><em>x</em>, <em>p</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#prctile_rank"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.prctile_rank" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The prctile_rank function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Return the rank for each element in <em>x</em>, return the rank
0..len(<em>p</em>).  e.g., if <em>p</em> = (25, 50, 75), the return value will be a
len(<em>x</em>) array with values in [0,1,2,3] where 0 indicates the
value is less than the 25th percentile, 1 indicates the value is
&gt;= the 25th and &lt; 50th percentile, ... and 3 indicates the value
is above the 75th percentile cutoff.</p>
<p><em>p</em> is either an array of percentiles in [0..100] or a scalar which
indicates how many quantiles of data you want ranked.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.psd">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">psd</code><span class="sig-paren">(</span><em>x</em>, <em>NFFT=None</em>, <em>Fs=None</em>, <em>detrend=None</em>, <em>window=None</em>, <em>noverlap=None</em>, <em>pad_to=None</em>, <em>sides=None</em>, <em>scale_by_freq=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#psd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.psd" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the power spectral density.</p>
<p>Call signature:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">psd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">mlab</span><span class="o">.</span><span class="n">detrend_none</span><span class="p">,</span>
    <span class="n">window</span><span class="o">=</span><span class="n">mlab</span><span class="o">.</span><span class="n">window_hanning</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">sides</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<p>The power spectral density <span class="math notranslate nohighlight">\(P_{xx}\)</span> by Welch's average
periodogram method.  The vector <em>x</em> is divided into <em>NFFT</em> length
segments.  Each segment is detrended by function <em>detrend</em> and
windowed by function <em>window</em>.  <em>noverlap</em> gives the length of
the overlap between segments.  The <span class="math notranslate nohighlight">\(|\mathrm{fft}(i)|^2\)</span>
of each segment <span class="math notranslate nohighlight">\(i\)</span> are averaged to compute <span class="math notranslate nohighlight">\(P_{xx}\)</span>.</p>
<p>If len(<em>x</em>) &lt; <em>NFFT</em>, it will be zero padded to <em>NFFT</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D array or sequence</span></dt>
<dd><p class="first last">Array or sequence containing the data</p>
</dd>
<dt><strong>Fs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd><p class="first last">The sampling frequency (samples per time unit).  It is used
to calculate the Fourier frequencies, freqs, in cycles per time
unit. The default value is 2.</p>
</dd>
<dt><strong>window</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable or ndarray</span></dt>
<dd><p class="first last">A function or a vector of length <em>NFFT</em>. To create window
vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-func docutils literal notranslate"><span class="pre">window_hanning()</span></code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code class="xref py py-func docutils literal notranslate"><span class="pre">window_none()</span></code></a>,
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.blackman()</span></code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.hamming()</span></code></a>,
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.bartlett()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.signal()</span></code>,
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.2.1)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.signal.get_window()</span></code></a>, etc. The default is
<a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-func docutils literal notranslate"><span class="pre">window_hanning()</span></code></a>.  If a function is passed as the
argument, it must take a data segment as an argument and
return the windowed version of the segment.</p>
</dd>
<dt><strong>sides</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{'default', 'onesided', 'twosided'}</span></dt>
<dd><p class="first last">Specifies which sides of the spectrum to return.  Default gives the
default behavior, which returns one-sided for real data and both
for complex data.  'onesided' forces the return of a one-sided
spectrum, while 'twosided' forces two-sided.</p>
</dd>
<dt><strong>pad_to</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of points to which the data segment is padded when
performing the FFT.  This can be different from <em>NFFT</em>, which
specifies the number of data points used.  While not increasing
the actual resolution of the spectrum (the minimum distance between
resolvable peaks), this can give more points in the plot,
allowing for more detail. This corresponds to the <em>n</em> parameter
in the call to fft(). The default is None, which sets <em>pad_to</em>
equal to <em>NFFT</em></p>
</dd>
<dt><strong>NFFT</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of data points used in each block for the FFT.
A power 2 is most efficient.  The default value is 256.
This should <em>NOT</em> be used to get zero padding, or the scaling of the
result will be incorrect. Use <em>pad_to</em> for this instead.</p>
</dd>
<dt><strong>detrend</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{'default', 'constant', 'mean', 'linear', 'none'} or callable</span></dt>
<dd><p class="first last">The function applied to each segment before fft-ing,
designed to remove the mean or linear trend.  Unlike in
MATLAB, where the <em>detrend</em> parameter is a vector, in
matplotlib is it a function.  The <a class="reference internal" href="#module-matplotlib.mlab" title="matplotlib.mlab"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mlab</span></code></a>
module defines <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_none()</span></code></a>,
<a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_mean()</span></code></a>, and
<a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_linear()</span></code></a>, but you can use
a custom function as well.  You can also use a string to choose
one of the functions.  'default', 'constant', and 'mean' call
<a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_mean()</span></code></a>.  'linear' calls
<a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_linear()</span></code></a>.  'none' calls
<a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_none()</span></code></a>.</p>
</dd>
<dt><strong>scale_by_freq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Specifies whether the resulting density values should be scaled
by the scaling frequency, which gives density in units of Hz^-1.
This allows for integration over the returned frequency values.
The default is True for MATLAB compatibility.</p>
</dd>
<dt><strong>noverlap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The number of points of overlap between segments.
The default value is 0 (no overlap).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Pxx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D array</span></dt>
<dd><p class="first last">The values for the power spectrum <code class="xref py py-obj docutils literal notranslate"><span class="pre">P_{xx}</span></code> (real valued)</p>
</dd>
<dt><strong>freqs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D array</span></dt>
<dd><p class="first last">The frequencies corresponding to the elements in <em>Pxx</em></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code class="xref py py-func docutils literal notranslate"><span class="pre">specgram()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.specgram" title="matplotlib.mlab.specgram"><code class="xref py py-func docutils literal notranslate"><span class="pre">specgram()</span></code></a> differs in the default overlap; in not returning the mean of the segment periodograms; and in returning the times of the segments.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">magnitude_spectrum()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code class="xref py py-func docutils literal notranslate"><span class="pre">magnitude_spectrum()</span></code></a> returns the magnitude spectrum.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.csd" title="matplotlib.mlab.csd"><code class="xref py py-func docutils literal notranslate"><span class="pre">csd()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.csd" title="matplotlib.mlab.csd"><code class="xref py py-func docutils literal notranslate"><span class="pre">csd()</span></code></a> returns the spectral density between two signals.</dd>
</dl>
</div>
<p class="rubric">References</p>
<p>Bendat &amp; Piersol -- Random Data: Analysis and Measurement Procedures, John
Wiley &amp; Sons (1986)</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.quad2cubic">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">quad2cubic</code><span class="sig-paren">(</span><em>q0x</em>, <em>q0y</em>, <em>q1x</em>, <em>q1y</em>, <em>q2x</em>, <em>q2y</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#quad2cubic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.quad2cubic" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The quad2cubic function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Converts a quadratic Bezier curve to a cubic approximation.</p>
<p>The inputs are the <em>x</em> and <em>y</em> coordinates of the three control
points of a quadratic curve, and the output is a tuple of <em>x</em> and
<em>y</em> coordinates of the four control points of the cubic curve.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.rec2csv">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">rec2csv</code><span class="sig-paren">(</span><em>r</em>, <em>fname</em>, <em>delimiter='</em>, <em>'</em>, <em>formatd=None</em>, <em>missing=''</em>, <em>missingd=None</em>, <em>withheader=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#rec2csv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.rec2csv" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The rec2csv function was deprecated in Matplotlib 2.2 and will be removed in 3.1. Use numpy.recarray.tofile instead.</p>
</div>
<p>Save the data from numpy recarray <em>r</em> into a
comma-/space-/tab-delimited file.  The record array dtype names
will be used for column headers.</p>
<dl class="docutils">
<dt><em>fname</em>: can be a filename or a file handle.  Support for gzipped</dt>
<dd>files is automatic, if the filename ends in '.gz'</dd>
<dt><em>withheader</em>: if withheader is False, do not write the attribute</dt>
<dd>names in the first row</dd>
</dl>
<p>for formatd type FormatFloat, we override the precision to store
full precision floats in the CSV file</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.csv2rec" title="matplotlib.mlab.csv2rec"><code class="xref py py-func docutils literal notranslate"><span class="pre">csv2rec()</span></code></a></dt>
<dd>For information about <em>missing</em> and <em>missingd</em>, which can be used to fill in masked values into your CSV file.</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.rec2txt">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">rec2txt</code><span class="sig-paren">(</span><em>r</em>, <em>header=None</em>, <em>padding=3</em>, <em>precision=3</em>, <em>fields=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#rec2txt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.rec2txt" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The rec2txt function was deprecated in Matplotlib 2.2 and will be removed in 3.1. Use numpy.recarray.tofile instead.</p>
</div>
<p>Returns a textual representation of a record array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>r: numpy recarray</strong></dt>
<dd></dd>
<dt><strong>header: list</strong></dt>
<dd><p class="first last">column headers</p>
</dd>
<dt><strong>padding:</strong></dt>
<dd><p class="first last">space between each column</p>
</dd>
<dt><strong>precision: number of decimal places to use for floats.</strong></dt>
<dd><p class="first last">Set to an integer to apply to all floats.  Set to a
list of integers to apply precision individually.
Precision for non-floats is simply ignored.</p>
</dd>
<dt><strong>fields</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">If not None, a list of field names to print.  fields
can be a list of strings like ['field1', 'field2'] or a single
comma separated string like 'field1,field2'</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>For <code class="docutils literal notranslate"><span class="pre">precision=[0,2,3]</span></code>, the output is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ID</span>    <span class="n">Price</span>   <span class="n">Return</span>
<span class="n">ABC</span>   <span class="mf">12.54</span>    <span class="mf">0.234</span>
<span class="n">XYZ</span>    <span class="mf">6.32</span>   <span class="o">-</span><span class="mf">0.076</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.rec_append_fields">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">rec_append_fields</code><span class="sig-paren">(</span><em>rec</em>, <em>names</em>, <em>arrs</em>, <em>dtypes=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#rec_append_fields"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.rec_append_fields" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The rec_append_fields function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Return a new record array with field names populated with data
from arrays in <em>arrs</em>.  If appending a single field, then <em>names</em>,
<em>arrs</em> and <em>dtypes</em> do not have to be lists. They can just be the
values themselves.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.rec_drop_fields">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">rec_drop_fields</code><span class="sig-paren">(</span><em>rec</em>, <em>names</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#rec_drop_fields"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.rec_drop_fields" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The rec_drop_fields function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Return a new numpy record array with fields in <em>names</em> dropped.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.rec_groupby">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">rec_groupby</code><span class="sig-paren">(</span><em>r</em>, <em>groupby</em>, <em>stats</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#rec_groupby"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.rec_groupby" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The rec_groupby function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p><em>r</em> is a numpy record array</p>
<p><em>groupby</em> is a sequence of record array attribute names that
together form the grouping key.  e.g., ('date', 'productcode')</p>
<p><em>stats</em> is a sequence of (<em>attr</em>, <em>func</em>, <em>outname</em>) tuples which
will call <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">func(attr)</span></code> and assign <em>x</em> to the record array
output with attribute <em>outname</em>.  For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stats</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="s1">&#39;sales&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">,</span> <span class="s1">&#39;numsales&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;sales&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="s1">&#39;avgsale&#39;</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>Return record array has <em>dtype</em> names for each attribute name in
the <em>groupby</em> argument, with the associated group values, and
for each outname name in the <em>stats</em> argument, with the associated
stat summary output.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.rec_join">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">rec_join</code><span class="sig-paren">(</span><em>key</em>, <em>r1</em>, <em>r2</em>, <em>jointype='inner'</em>, <em>defaults=None</em>, <em>r1postfix='1'</em>, <em>r2postfix='2'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#rec_join"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.rec_join" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The rec_join function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Join record arrays <em>r1</em> and <em>r2</em> on <em>key</em>; <em>key</em> is a tuple of
field names -- if <em>key</em> is a string it is assumed to be a single
attribute name. If <em>r1</em> and <em>r2</em> have equal values on all the keys
in the <em>key</em> tuple, then their fields will be merged into a new
record array containing the intersection of the fields of <em>r1</em> and
<em>r2</em>.</p>
<p><em>r1</em> (also <em>r2</em>) must not have any duplicate keys.</p>
<p>The <em>jointype</em> keyword can be 'inner', 'outer', 'leftouter'.  To
do a rightouter join just reverse <em>r1</em> and <em>r2</em>.</p>
<p>The <em>defaults</em> keyword is a dictionary filled with
<code class="docutils literal notranslate"><span class="pre">{column_name:default_value}</span></code> pairs.</p>
<p>The keywords <em>r1postfix</em> and <em>r2postfix</em> are postfixed to column names
(other than keys) that are both in <em>r1</em> and <em>r2</em>.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.rec_keep_fields">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">rec_keep_fields</code><span class="sig-paren">(</span><em>rec</em>, <em>names</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#rec_keep_fields"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.rec_keep_fields" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The rec_keep_fields function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Return a new numpy record array with only fields listed in names</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.rec_summarize">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">rec_summarize</code><span class="sig-paren">(</span><em>r</em>, <em>summaryfuncs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#rec_summarize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.rec_summarize" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The rec_summarize function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p><em>r</em> is a numpy record array</p>
<p><em>summaryfuncs</em> is a list of (<em>attr</em>, <em>func</em>, <em>outname</em>) tuples
which will apply <em>func</em> to the array <em>r*[attr] and assign the
output to a new attribute name *outname</em>.  The returned record
array is identical to <em>r</em>, with extra arrays for each element in
<em>summaryfuncs</em>.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.recs_join">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">recs_join</code><span class="sig-paren">(</span><em>key</em>, <em>name</em>, <em>recs</em>, <em>jointype='outer'</em>, <em>missing=0.0</em>, <em>postfixes=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#recs_join"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.recs_join" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The recs_join function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Join a sequence of record arrays on single column key.</p>
<p>This function only joins a single column of the multiple record arrays</p>
<dl class="docutils">
<dt><em>key</em></dt>
<dd>is the column name that acts as a key</dd>
<dt><em>name</em></dt>
<dd>is the name of the column that we want to join</dd>
<dt><em>recs</em></dt>
<dd>is a list of record arrays to join</dd>
<dt><em>jointype</em></dt>
<dd>is a string 'inner' or 'outer'</dd>
<dt><em>missing</em></dt>
<dd>is what any missing field is replaced by</dd>
<dt><em>postfixes</em></dt>
<dd>if not None, a len recs sequence of postfixes</dd>
</dl>
<p>returns a record array with columns [rowkey, name0, name1, ... namen-1].
or if postfixes [PF0, PF1, ..., PFN-1] are supplied,
[rowkey, namePF0, namePF1, ... namePFN-1].</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">r</span> <span class="o">=</span> <span class="n">recs_join</span><span class="p">(</span><span class="s2">&quot;date&quot;</span><span class="p">,</span> <span class="s2">&quot;close&quot;</span><span class="p">,</span> <span class="n">recs</span><span class="o">=</span><span class="p">[</span><span class="n">r0</span><span class="p">,</span> <span class="n">r1</span><span class="p">],</span> <span class="n">missing</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.rk4">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">rk4</code><span class="sig-paren">(</span><em>derivs</em>, <em>y0</em>, <em>t</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#rk4"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.rk4" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>scipy.integrate.ode</p>
</div>
<p>Integrate 1D or ND system of ODEs using 4-th order Runge-Kutta.
This is a toy implementation which may be useful if you find
yourself stranded on a system w/o scipy.  Otherwise use
<code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.integrate()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>y0</strong></dt>
<dd><p class="first last">initial state vector</p>
</dd>
<dt><strong>t</strong></dt>
<dd><p class="first last">sample times</p>
</dd>
<dt><strong>derivs</strong></dt>
<dd><p class="first last">returns the derivative of the system and has the
signature <code class="docutils literal notranslate"><span class="pre">dy</span> <span class="pre">=</span> <span class="pre">derivs(yi,</span> <span class="pre">ti)</span></code></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>A 2D system:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">derivs6</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
    <span class="n">d1</span> <span class="o">=</span>  <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">d2</span> <span class="o">=</span>  <span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">)</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.0005</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
<span class="n">y0</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">yout</span> <span class="o">=</span> <span class="n">rk4</span><span class="p">(</span><span class="n">derivs6</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>A 1D system:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alpha</span> <span class="o">=</span> <span class="mi">2</span>
<span class="k">def</span> <span class="nf">derivs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">alpha</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span><span class="p">)</span>

<span class="n">y0</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">yout</span> <span class="o">=</span> <span class="n">rk4</span><span class="p">(</span><span class="n">derivs</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
<p>If you have access to scipy, you should probably be using the
scipy.integrate tools rather than this function.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.rms_flat">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">rms_flat</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#rms_flat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.rms_flat" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The rms_flat function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Return the root mean square of all the elements of <em>a</em>, flattened out.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.safe_isinf">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">safe_isinf</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#safe_isinf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.safe_isinf" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>numpy.isinf</p>
</div>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.isinf()</span></code> for arbitrary types</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.safe_isnan">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">safe_isnan</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#safe_isnan"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.safe_isnan" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>numpy.isnan</p>
</div>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.isnan()</span></code> for arbitrary types</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.segments_intersect">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">segments_intersect</code><span class="sig-paren">(</span><em>s1</em>, <em>s2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#segments_intersect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.segments_intersect" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The segments_intersect function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Return <em>True</em> if <em>s1</em> and <em>s2</em> intersect.
<em>s1</em> and <em>s2</em> are defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s1</span><span class="p">:</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span>
<span class="n">s2</span><span class="p">:</span> <span class="p">(</span><span class="n">x3</span><span class="p">,</span> <span class="n">y3</span><span class="p">),</span> <span class="p">(</span><span class="n">x4</span><span class="p">,</span> <span class="n">y4</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.slopes">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">slopes</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#slopes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.slopes" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The slopes function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p><a class="reference internal" href="#matplotlib.mlab.slopes" title="matplotlib.mlab.slopes"><code class="xref py py-func docutils literal notranslate"><span class="pre">slopes()</span></code></a> calculates the slope <em>y</em>'(<em>x</em>)</p>
<p>The slope is estimated using the slope obtained from that of a
parabola through any three consecutive points.</p>
<p>This method should be superior to that described in the appendix
of A CONSISTENTLY WELL BEHAVED METHOD OF INTERPOLATION by Russel
W. Stineman (Creative Computing July 1980) in at least one aspect:</p>
<blockquote>
<div>Circles for interpolation demand a known aspect ratio between
<em>x</em>- and <em>y</em>-values.  For many functions, however, the abscissa
are given in different dimensions, so an aspect ratio is
completely arbitrary.</div></blockquote>
<p>The parabola method gives very similar results to the circle
method for most regular cases but behaves much better in special
cases.</p>
<p>Norbert Nemec, Institute of Theoretical Physics, University or
Regensburg, April 2006 Norbert.Nemec at physik.uni-regensburg.de</p>
<p>(inspired by a original implementation by Halldor Bjornsson,
Icelandic Meteorological Office, March 2006 halldor at vedur.is)</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.specgram">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">specgram</code><span class="sig-paren">(</span><em>x</em>, <em>NFFT=None</em>, <em>Fs=None</em>, <em>detrend=None</em>, <em>window=None</em>, <em>noverlap=None</em>, <em>pad_to=None</em>, <em>sides=None</em>, <em>scale_by_freq=None</em>, <em>mode=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#specgram"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.specgram" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a spectrogram.</p>
<p>Compute and plot a spectrogram of data in x.  Data are split into
NFFT length segments and the spectrum of each section is
computed.  The windowing function window is applied to each
segment, and the amount of overlap of each segment is
specified with noverlap.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">1-D array or sequence.</p>
</dd>
<dt><strong>Fs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd><p class="first last">The sampling frequency (samples per time unit).  It is used
to calculate the Fourier frequencies, freqs, in cycles per time
unit. The default value is 2.</p>
</dd>
<dt><strong>window</strong> <span class="classifier-delimiter">:</span> <span class="classifier">callable or ndarray</span></dt>
<dd><p class="first last">A function or a vector of length <em>NFFT</em>. To create window
vectors see <a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-func docutils literal notranslate"><span class="pre">window_hanning()</span></code></a>, <a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code class="xref py py-func docutils literal notranslate"><span class="pre">window_none()</span></code></a>,
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.blackman.html#numpy.blackman" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.blackman()</span></code></a>, <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.hamming.html#numpy.hamming" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.hamming()</span></code></a>,
<a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.bartlett.html#numpy.bartlett" title="(in NumPy v1.16)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.bartlett()</span></code></a>, <code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.signal()</span></code>,
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.get_window.html#scipy.signal.get_window" title="(in SciPy v1.2.1)"><code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.signal.get_window()</span></code></a>, etc. The default is
<a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-func docutils literal notranslate"><span class="pre">window_hanning()</span></code></a>.  If a function is passed as the
argument, it must take a data segment as an argument and
return the windowed version of the segment.</p>
</dd>
<dt><strong>sides</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{'default', 'onesided', 'twosided'}</span></dt>
<dd><p class="first last">Specifies which sides of the spectrum to return.  Default gives the
default behavior, which returns one-sided for real data and both
for complex data.  'onesided' forces the return of a one-sided
spectrum, while 'twosided' forces two-sided.</p>
</dd>
<dt><strong>pad_to</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of points to which the data segment is padded when
performing the FFT.  This can be different from <em>NFFT</em>, which
specifies the number of data points used.  While not increasing
the actual resolution of the spectrum (the minimum distance between
resolvable peaks), this can give more points in the plot,
allowing for more detail. This corresponds to the <em>n</em> parameter
in the call to fft(). The default is None, which sets <em>pad_to</em>
equal to <em>NFFT</em></p>
</dd>
<dt><strong>NFFT</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of data points used in each block for the FFT.
A power 2 is most efficient.  The default value is 256.
This should <em>NOT</em> be used to get zero padding, or the scaling of the
result will be incorrect. Use <em>pad_to</em> for this instead.</p>
</dd>
<dt><strong>detrend</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{'default', 'constant', 'mean', 'linear', 'none'} or callable</span></dt>
<dd><p class="first last">The function applied to each segment before fft-ing,
designed to remove the mean or linear trend.  Unlike in
MATLAB, where the <em>detrend</em> parameter is a vector, in
matplotlib is it a function.  The <a class="reference internal" href="#module-matplotlib.mlab" title="matplotlib.mlab"><code class="xref py py-mod docutils literal notranslate"><span class="pre">mlab</span></code></a>
module defines <a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_none()</span></code></a>,
<a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_mean()</span></code></a>, and
<a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_linear()</span></code></a>, but you can use
a custom function as well.  You can also use a string to choose
one of the functions.  'default', 'constant', and 'mean' call
<a class="reference internal" href="#matplotlib.mlab.detrend_mean" title="matplotlib.mlab.detrend_mean"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_mean()</span></code></a>.  'linear' calls
<a class="reference internal" href="#matplotlib.mlab.detrend_linear" title="matplotlib.mlab.detrend_linear"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_linear()</span></code></a>.  'none' calls
<a class="reference internal" href="#matplotlib.mlab.detrend_none" title="matplotlib.mlab.detrend_none"><code class="xref py py-func docutils literal notranslate"><span class="pre">detrend_none()</span></code></a>.</p>
</dd>
<dt><strong>scale_by_freq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">Specifies whether the resulting density values should be scaled
by the scaling frequency, which gives density in units of Hz^-1.
This allows for integration over the returned frequency values.
The default is True for MATLAB compatibility.</p>
</dd>
<dt><strong>noverlap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">The number of points of overlap between blocks.  The default
value is 128.</p>
</dd>
<dt><strong>mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><dl class="first last docutils">
<dt>What sort of spectrum to use, default is 'psd'.</dt>
<dd><dl class="first last docutils">
<dt>'psd'</dt>
<dd><p class="first last">Returns the power spectral density.</p>
</dd>
<dt>'complex'</dt>
<dd><p class="first last">Returns the complex-valued frequency spectrum.</p>
</dd>
<dt>'magnitude'</dt>
<dd><p class="first last">Returns the magnitude spectrum.</p>
</dd>
<dt>'angle'</dt>
<dd><p class="first last">Returns the phase spectrum without unwrapping.</p>
</dd>
<dt>'phase'</dt>
<dd><p class="first last">Returns the phase spectrum with unwrapping.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>spectrum</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">2-D array, columns are the periodograms of successive segments.</p>
</dd>
<dt><strong>freqs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">1-D array, frequencies corresponding to the rows in <em>spectrum</em>.</p>
</dd>
<dt><strong>t</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">1-D array, the times corresponding to midpoints of segments
(i.e the columns in <em>spectrum</em>).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.psd" title="matplotlib.mlab.psd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">psd</span></code></a></dt>
<dd>differs in the overlap and in the return values.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.complex_spectrum" title="matplotlib.mlab.complex_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">complex_spectrum</span></code></a></dt>
<dd>similar, but with complex valued frequencies.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.magnitude_spectrum" title="matplotlib.mlab.magnitude_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">magnitude_spectrum</span></code></a></dt>
<dd>similar single segment when mode is 'magnitude'.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.angle_spectrum" title="matplotlib.mlab.angle_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">angle_spectrum</span></code></a></dt>
<dd>similar to single segment when mode is 'angle'.</dd>
<dt><a class="reference internal" href="#matplotlib.mlab.phase_spectrum" title="matplotlib.mlab.phase_spectrum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">phase_spectrum</span></code></a></dt>
<dd>similar to single segment when mode is 'phase'.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>detrend and scale_by_freq only apply when <em>mode</em> is set to 'psd'.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.stineman_interp">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">stineman_interp</code><span class="sig-paren">(</span><em>xi</em>, <em>x</em>, <em>y</em>, <em>yp=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#stineman_interp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.stineman_interp" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The stineman_interp function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Given data vectors <em>x</em> and <em>y</em>, the slope vector <em>yp</em> and a new
abscissa vector <em>xi</em>, the function <a class="reference internal" href="#matplotlib.mlab.stineman_interp" title="matplotlib.mlab.stineman_interp"><code class="xref py py-func docutils literal notranslate"><span class="pre">stineman_interp()</span></code></a> uses
Stineman interpolation to calculate a vector <em>yi</em> corresponding to
<em>xi</em>.</p>
<p>Here's an example that generates a coarse sine curve, then
interpolates over a finer abscissa:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span>  <span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="n">yp</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">xi</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">,</span><span class="mi">40</span><span class="p">);</span>
<span class="n">yi</span> <span class="o">=</span> <span class="n">stineman_interp</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">yp</span><span class="p">);</span>
<span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="s1">&#39;o&#39;</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">yi</span><span class="p">)</span>
</pre></div>
</div>
<p>The interpolation method is described in the article A
CONSISTENTLY WELL BEHAVED METHOD OF INTERPOLATION by Russell
W. Stineman. The article appeared in the July 1980 issue of
Creative Computing with a note from the editor stating that while
they were:</p>
<blockquote>
<div>not an academic journal but once in a while something serious
and original comes in adding that this was
&quot;apparently a real solution&quot; to a well known problem.</div></blockquote>
<p>For <em>yp</em> = <em>None</em>, the routine automatically determines the slopes
using the <a class="reference internal" href="#matplotlib.mlab.slopes" title="matplotlib.mlab.slopes"><code class="xref py py-func docutils literal notranslate"><span class="pre">slopes()</span></code></a> routine.</p>
<p><em>x</em> is assumed to be sorted in increasing order.</p>
<p>For values <code class="docutils literal notranslate"><span class="pre">xi[j]</span> <span class="pre">&lt;</span> <span class="pre">x[0]</span></code> or <code class="docutils literal notranslate"><span class="pre">xi[j]</span> <span class="pre">&gt;</span> <span class="pre">x[-1]</span></code>, the routine
tries an extrapolation.  The relevance of the data obtained from
this, of course, is questionable...</p>
<p>Original implementation by Halldor Bjornsson, Icelandic
Meteorolocial Office, March 2006 halldor at vedur.is</p>
<p>Completely reworked and optimized for Python by Norbert Nemec,
Institute of Theoretical Physics, University or Regensburg, April
2006 Norbert.Nemec at physik.uni-regensburg.de</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.stride_repeat">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">stride_repeat</code><span class="sig-paren">(</span><em>x</em>, <em>n</em>, <em>axis=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#stride_repeat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.stride_repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Repeat the values in an array in a memory-efficient manner.  Array x is
stacked vertically n times.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">It is not safe to write to the output array.  Multiple
elements may point to the same piece of memory, so
modifying one value may change others.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array or sequence</span></dt>
<dd><p class="first last">Array or sequence containing the data.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The number of time to repeat the array.</p>
</dd>
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The axis along which the data will run.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p><a class="reference external" href="http://stackoverflow.com/a/5568169">stackoverflow: Repeat NumPy array without replicating data?</a></p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.stride_windows">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">stride_windows</code><span class="sig-paren">(</span><em>x</em>, <em>n</em>, <em>noverlap=None</em>, <em>axis=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#stride_windows"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.stride_windows" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all windows of x with length n as a single array,
using strides to avoid data duplication.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">It is not safe to write to the output array.  Multiple
elements may point to the same piece of memory,
so modifying one value may change others.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>x</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array or sequence</span></dt>
<dd><p class="first last">Array or sequence containing the data.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The number of data points in each window.</p>
</dd>
<dt><strong>noverlap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The overlap between adjacent windows.
Default is 0 (no overlap)</p>
</dd>
<dt><strong>axis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The axis along which the windows will run.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p><a class="reference external" href="http://stackoverflow.com/a/6811241">stackoverflow: Rolling window for 1D arrays in Numpy?</a>
<a class="reference external" href="http://stackoverflow.com/a/4947453">stackoverflow: Using strides for an efficient moving average filter</a></p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.vector_lengths">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">vector_lengths</code><span class="sig-paren">(</span><em>X</em>, <em>P=2.0</em>, <em>axis=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#vector_lengths"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.vector_lengths" title="Permalink to this definition">¶</a></dt>
<dd><div class="deprecated">
<p><span class="versionmodified">Deprecated since version 2.2: </span>The vector_lengths function was deprecated in Matplotlib 2.2 and will be removed in 3.1.</p>
</div>
<p>Finds the length of a set of vectors in <em>n</em> dimensions.  This is
like the <code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.norm()</span></code> function for vectors, but has the ability to
work over a particular axis of the supplied array or matrix.</p>
<p>Computes <code class="docutils literal notranslate"><span class="pre">(sum((x_i)^P))^(1/P)</span></code> for each <code class="docutils literal notranslate"><span class="pre">{x_i}</span></code> being the
elements of <em>X</em> along the given axis.  If <em>axis</em> is <em>None</em>,
compute over all elements of <em>X</em>.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.window_hanning">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">window_hanning</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#window_hanning"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.window_hanning" title="Permalink to this definition">¶</a></dt>
<dd><p>Return x times the hanning window of len(x).</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code class="xref py py-func docutils literal notranslate"><span class="pre">window_none()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.window_none" title="matplotlib.mlab.window_none"><code class="xref py py-func docutils literal notranslate"><span class="pre">window_none()</span></code></a> is another window algorithm.</dd>
</dl>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.mlab.window_none">
<code class="descclassname">matplotlib.mlab.</code><code class="descname">window_none</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/mlab.html#window_none"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.mlab.window_none" title="Permalink to this definition">¶</a></dt>
<dd><p>No window function; simply return x.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-func docutils literal notranslate"><span class="pre">window_hanning()</span></code></a></dt>
<dd><a class="reference internal" href="#matplotlib.mlab.window_hanning" title="matplotlib.mlab.window_hanning"><code class="xref py py-func docutils literal notranslate"><span class="pre">window_hanning()</span></code></a> is another window algorithm.</dd>
</dl>
</div>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>

      <div class="clearer"></div>
    </div>
    <div class="footer">
        &copy; Copyright 2002 - 2012 John Hunter, Darren Dale, Eric Firing, Michael Droettboom and the Matplotlib development team; 2012 - 2018 The Matplotlib development team.
        <br />
      Last updated on Feb 28, 2019.
	Created using
	<a href="http://sphinx-doc.org/">Sphinx</a> 1.8.4.
	Doc version v3.0.3-2-gfc177a9cd.
    </div>

</body>
<footer>
</footer>
</html>