<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>matplotlib.dates &mdash; Matplotlib 2.2.3 documentation</title>
    
    <link rel="stylesheet" href="../../_static/mpl.css"
type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css"
type="text/css" />
    <link rel="stylesheet" href="../../_static/gallery.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '2.2.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Matplotlib 2.2.3 documentation"
          href="../../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html"
/>
    <link rel="search" title="Search" href="../../search.html"
/>
    <link rel="top" title="Matplotlib 2.2.3 documentation" href="../../index.html" />
    <link rel="up" title="matplotlib" href="../matplotlib.html" />
  <link rel="canonical" href="https://matplotlib.org/3.4.3/_modules/matplotlib/dates.html" />



  </head>
  <body>
<div id="unreleased-message"> You are reading an old version of the documentation (v2.2.3).  For the latest version see <a href="/stable/">https://matplotlib.org/stable/</a> </div>



<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px; position: relative;">
<a href="../../index.html">
    <div style="float: left; position: absolute; width: 496px; bottom: 0; padding-bottom: 24px"><span style="float: right; color: #789; background: white">Version 2.2.3</span></div>
    <img src="../../_static/logo2.png" height="125px" border="0" alt="matplotlib"/></a>

<!-- The "Fork me on github" ribbon -->
<div id="forkongithub"><a href="https://github.com/matplotlib/matplotlib">Fork me on GitHub</a></div>
</div>




    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>

        <li><a href="../../index.html">home</a>|&nbsp;</li>
        <li><a href="../../gallery/index.html">examples</a>|&nbsp;</li>
        <li><a href="../../tutorials/index.html">tutorials</a>|&nbsp;</li>
        <li><a href="../../api/pyplot_summary.html">pyplot</a>|&nbsp;</li>
        <li><a href="../../contents.html">docs</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li>
          <li><a href="../matplotlib.html" accesskey="U">matplotlib</a> &raquo;</li> 
      </ul>
    </div>

  
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../contents.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  <li><a href="../matplotlib.html">matplotlib</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
        </div>
      </div>
    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for matplotlib.dates</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Matplotlib provides sophisticated date plotting capabilities, standing on the</span>
<span class="sd">shoulders of python :mod:`datetime`, the add-on modules :mod:`pytz` and</span>
<span class="sd">:mod:`dateutil`.</span>


<span class="sd">.. _date-format:</span>

<span class="sd">Matplotlib date format</span>
<span class="sd">----------------------</span>
<span class="sd">Matplotlib represents dates using floating point numbers specifying the number</span>
<span class="sd">of days since 0001-01-01 UTC, plus 1.  For example, 0001-01-01, 06:00 is 1.25,</span>
<span class="sd">not 0.25. Values &lt; 1, i.e. dates before 0001-01-01 UTC are not supported.</span>

<span class="sd">There are a number of helper functions to convert between :mod:`datetime`</span>
<span class="sd">objects and Matplotlib dates:</span>

<span class="sd">.. currentmodule:: matplotlib.dates</span>

<span class="sd">.. autosummary::</span>
<span class="sd">   :nosignatures:</span>

<span class="sd">   date2num</span>
<span class="sd">   num2date</span>
<span class="sd">   num2timedelta</span>
<span class="sd">   epoch2num</span>
<span class="sd">   num2epoch</span>
<span class="sd">   mx2num</span>
<span class="sd">   drange</span>

<span class="sd">.. note::</span>

<span class="sd">   Like Python&#39;s datetime, mpl uses the Gregorian calendar for all</span>
<span class="sd">   conversions between dates and floating point numbers. This practice</span>
<span class="sd">   is not universal, and calendar differences can cause confusing</span>
<span class="sd">   differences between what Python and mpl give as the number of days</span>
<span class="sd">   since 0001-01-01 and what other software and databases yield.  For</span>
<span class="sd">   example, the US Naval Observatory uses a calendar that switches</span>
<span class="sd">   from Julian to Gregorian in October, 1582.  Hence, using their</span>
<span class="sd">   calculator, the number of days between 0001-01-01 and 2006-04-01 is</span>
<span class="sd">   732403, whereas using the Gregorian calendar via the datetime</span>
<span class="sd">   module we find::</span>

<span class="sd">     In [1]: date(2006, 4, 1).toordinal() - date(1, 1, 1).toordinal()</span>
<span class="sd">     Out[1]: 732401</span>

<span class="sd">All the Matplotlib date converters, tickers and formatters are timezone aware.</span>
<span class="sd">If no explicit timezone is provided, the rcParam ``timezone`` is assumend.  If</span>
<span class="sd">you want to use a custom time zone, pass a :class:`pytz.timezone` instance</span>
<span class="sd">with the tz keyword argument to :func:`num2date`, :func:`.plot_date`, and any</span>
<span class="sd">custom date tickers or locators you create.</span>
<span class="sd">See `pytz &lt;http://pythonhosted.org/pytz/&gt;`_ for information on :mod:`pytz` and</span>
<span class="sd">timezone handling.</span>

<span class="sd">A wide range of specific and general purpose date tick locators and</span>
<span class="sd">formatters are provided in this module.  See</span>
<span class="sd">:mod:`matplotlib.ticker` for general information on tick locators</span>
<span class="sd">and formatters.  These are described below.</span>


<span class="sd">The `dateutil module &lt;https://dateutil.readthedocs.io/en/stable/&gt;`_ provides</span>
<span class="sd">additional code to handle date ticking, making it easy to place ticks</span>
<span class="sd">on any kinds of dates.  See examples below.</span>

<span class="sd">Date tickers</span>
<span class="sd">------------</span>

<span class="sd">Most of the date tickers can locate single or multiple values.  For</span>
<span class="sd">example::</span>

<span class="sd">    # import constants for the days of the week</span>
<span class="sd">    from matplotlib.dates import MO, TU, WE, TH, FR, SA, SU</span>

<span class="sd">    # tick on mondays every week</span>
<span class="sd">    loc = WeekdayLocator(byweekday=MO, tz=tz)</span>

<span class="sd">    # tick on mondays and saturdays</span>
<span class="sd">    loc = WeekdayLocator(byweekday=(MO, SA))</span>

<span class="sd">In addition, most of the constructors take an interval argument::</span>

<span class="sd">    # tick on mondays every second week</span>
<span class="sd">    loc = WeekdayLocator(byweekday=MO, interval=2)</span>

<span class="sd">The rrule locator allows completely general date ticking::</span>

<span class="sd">    # tick every 5th easter</span>
<span class="sd">    rule = rrulewrapper(YEARLY, byeaster=1, interval=5)</span>
<span class="sd">    loc = RRuleLocator(rule)</span>

<span class="sd">Here are all the date tickers:</span>

<span class="sd">    * :class:`MicrosecondLocator`: locate microseconds</span>

<span class="sd">    * :class:`SecondLocator`: locate seconds</span>

<span class="sd">    * :class:`MinuteLocator`: locate minutes</span>

<span class="sd">    * :class:`HourLocator`: locate hours</span>

<span class="sd">    * :class:`DayLocator`: locate specified days of the month</span>

<span class="sd">    * :class:`WeekdayLocator`: Locate days of the week, e.g., MO, TU</span>

<span class="sd">    * :class:`MonthLocator`: locate months, e.g., 7 for july</span>

<span class="sd">    * :class:`YearLocator`: locate years that are multiples of base</span>

<span class="sd">    * :class:`RRuleLocator`: locate using a</span>
<span class="sd">      :class:`matplotlib.dates.rrulewrapper`.  The</span>
<span class="sd">      :class:`rrulewrapper` is a simple wrapper around a</span>
<span class="sd">      :class:`dateutil.rrule` (`dateutil</span>
<span class="sd">      &lt;https://dateutil.readthedocs.io/en/stable/&gt;`_) which allow almost</span>
<span class="sd">      arbitrary date tick specifications.  See `rrule example</span>
<span class="sd">      &lt;../gallery/ticks_and_spines/date_demo_rrule.html&gt;`_.</span>

<span class="sd">    * :class:`AutoDateLocator`: On autoscale, this class picks the best</span>
<span class="sd">      :class:`DateLocator` (e.g., :class:`RRuleLocator`)</span>
<span class="sd">      to set the view limits and the tick</span>
<span class="sd">      locations.  If called with ``interval_multiples=True`` it will</span>
<span class="sd">      make ticks line up with sensible multiples of the tick intervals.  E.g.</span>
<span class="sd">      if the interval is 4 hours, it will pick hours 0, 4, 8, etc as ticks.</span>
<span class="sd">      This behaviour is not guaranteed by default.</span>

<span class="sd">Date formatters</span>
<span class="sd">---------------</span>

<span class="sd">Here all all the date formatters:</span>

<span class="sd">    * :class:`AutoDateFormatter`: attempts to figure out the best format</span>
<span class="sd">      to use.  This is most useful when used with the :class:`AutoDateLocator`.</span>

<span class="sd">    * :class:`DateFormatter`: use :func:`strftime` format strings</span>

<span class="sd">    * :class:`IndexDateFormatter`: date plots with implicit *x*</span>
<span class="sd">      indexing.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span>
                        <span class="n">unicode_literals</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="nb">zip</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">functools</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">from</span> <span class="nn">dateutil.rrule</span> <span class="k">import</span> <span class="p">(</span><span class="n">rrule</span><span class="p">,</span> <span class="n">MO</span><span class="p">,</span> <span class="n">TU</span><span class="p">,</span> <span class="n">WE</span><span class="p">,</span> <span class="n">TH</span><span class="p">,</span> <span class="n">FR</span><span class="p">,</span> <span class="n">SA</span><span class="p">,</span> <span class="n">SU</span><span class="p">,</span> <span class="n">YEARLY</span><span class="p">,</span>
                            <span class="n">MONTHLY</span><span class="p">,</span> <span class="n">WEEKLY</span><span class="p">,</span> <span class="n">DAILY</span><span class="p">,</span> <span class="n">HOURLY</span><span class="p">,</span> <span class="n">MINUTELY</span><span class="p">,</span>
                            <span class="n">SECONDLY</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">dateutil.relativedelta</span> <span class="k">import</span> <span class="n">relativedelta</span>
<span class="kn">import</span> <span class="nn">dateutil.parser</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="k">import</span> <span class="n">rcParams</span>
<span class="kn">import</span> <span class="nn">matplotlib.units</span> <span class="k">as</span> <span class="nn">units</span>
<span class="kn">import</span> <span class="nn">matplotlib.cbook</span> <span class="k">as</span> <span class="nn">cbook</span>
<span class="kn">import</span> <span class="nn">matplotlib.ticker</span> <span class="k">as</span> <span class="nn">ticker</span>

<span class="n">_log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;date2num&#39;</span><span class="p">,</span> <span class="s1">&#39;num2date&#39;</span><span class="p">,</span> <span class="s1">&#39;num2timedelta&#39;</span><span class="p">,</span> <span class="s1">&#39;drange&#39;</span><span class="p">,</span> <span class="s1">&#39;epoch2num&#39;</span><span class="p">,</span>
           <span class="s1">&#39;num2epoch&#39;</span><span class="p">,</span> <span class="s1">&#39;mx2num&#39;</span><span class="p">,</span> <span class="s1">&#39;DateFormatter&#39;</span><span class="p">,</span>
           <span class="s1">&#39;IndexDateFormatter&#39;</span><span class="p">,</span> <span class="s1">&#39;AutoDateFormatter&#39;</span><span class="p">,</span> <span class="s1">&#39;DateLocator&#39;</span><span class="p">,</span>
           <span class="s1">&#39;RRuleLocator&#39;</span><span class="p">,</span> <span class="s1">&#39;AutoDateLocator&#39;</span><span class="p">,</span> <span class="s1">&#39;YearLocator&#39;</span><span class="p">,</span>
           <span class="s1">&#39;MonthLocator&#39;</span><span class="p">,</span> <span class="s1">&#39;WeekdayLocator&#39;</span><span class="p">,</span>
           <span class="s1">&#39;DayLocator&#39;</span><span class="p">,</span> <span class="s1">&#39;HourLocator&#39;</span><span class="p">,</span> <span class="s1">&#39;MinuteLocator&#39;</span><span class="p">,</span>
           <span class="s1">&#39;SecondLocator&#39;</span><span class="p">,</span> <span class="s1">&#39;MicrosecondLocator&#39;</span><span class="p">,</span>
           <span class="s1">&#39;rrule&#39;</span><span class="p">,</span> <span class="s1">&#39;MO&#39;</span><span class="p">,</span> <span class="s1">&#39;TU&#39;</span><span class="p">,</span> <span class="s1">&#39;WE&#39;</span><span class="p">,</span> <span class="s1">&#39;TH&#39;</span><span class="p">,</span> <span class="s1">&#39;FR&#39;</span><span class="p">,</span> <span class="s1">&#39;SA&#39;</span><span class="p">,</span> <span class="s1">&#39;SU&#39;</span><span class="p">,</span>
           <span class="s1">&#39;YEARLY&#39;</span><span class="p">,</span> <span class="s1">&#39;MONTHLY&#39;</span><span class="p">,</span> <span class="s1">&#39;WEEKLY&#39;</span><span class="p">,</span> <span class="s1">&#39;DAILY&#39;</span><span class="p">,</span>
           <span class="s1">&#39;HOURLY&#39;</span><span class="p">,</span> <span class="s1">&#39;MINUTELY&#39;</span><span class="p">,</span> <span class="s1">&#39;SECONDLY&#39;</span><span class="p">,</span> <span class="s1">&#39;MICROSECONDLY&#39;</span><span class="p">,</span> <span class="s1">&#39;relativedelta&#39;</span><span class="p">,</span>
           <span class="s1">&#39;seconds&#39;</span><span class="p">,</span> <span class="s1">&#39;minutes&#39;</span><span class="p">,</span> <span class="s1">&#39;hours&#39;</span><span class="p">,</span> <span class="s1">&#39;weeks&#39;</span><span class="p">)</span>


<span class="n">_log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="c1"># Make a simple UTC instance so we don&#39;t always have to import</span>
<span class="c1"># pytz.  From the python datetime library docs:</span>

<span class="k">class</span> <span class="nc">_UTC</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">tzinfo</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;UTC&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">utcoffset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tzname</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="s2">&quot;UTC&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>


<span class="n">UTC</span> <span class="o">=</span> <span class="n">_UTC</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_get_rc_timezone</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieve the preferred timeszone from the rcParams dictionary.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;timezone&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s1">&#39;UTC&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">UTC</span>
    <span class="kn">import</span> <span class="nn">pytz</span>
    <span class="k">return</span> <span class="n">pytz</span><span class="o">.</span><span class="n">timezone</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Time-related constants.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">EPOCH_OFFSET</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">1970</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">toordinal</span><span class="p">())</span>
<span class="n">JULIAN_OFFSET</span> <span class="o">=</span> <span class="mf">1721424.5</span>                         <span class="c1"># Julian date at 0001-01-01</span>
<span class="n">MICROSECONDLY</span> <span class="o">=</span> <span class="n">SECONDLY</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">HOURS_PER_DAY</span> <span class="o">=</span> <span class="mf">24.</span>
<span class="n">MIN_PER_HOUR</span> <span class="o">=</span> <span class="mf">60.</span>
<span class="n">SEC_PER_MIN</span> <span class="o">=</span> <span class="mf">60.</span>
<span class="n">MONTHS_PER_YEAR</span> <span class="o">=</span> <span class="mf">12.</span>

<span class="n">DAYS_PER_WEEK</span> <span class="o">=</span> <span class="mf">7.</span>
<span class="n">DAYS_PER_MONTH</span> <span class="o">=</span> <span class="mf">30.</span>
<span class="n">DAYS_PER_YEAR</span> <span class="o">=</span> <span class="mf">365.0</span>

<span class="n">MINUTES_PER_DAY</span> <span class="o">=</span> <span class="n">MIN_PER_HOUR</span> <span class="o">*</span> <span class="n">HOURS_PER_DAY</span>

<span class="n">SEC_PER_HOUR</span> <span class="o">=</span> <span class="n">SEC_PER_MIN</span> <span class="o">*</span> <span class="n">MIN_PER_HOUR</span>
<span class="n">SEC_PER_DAY</span> <span class="o">=</span> <span class="n">SEC_PER_HOUR</span> <span class="o">*</span> <span class="n">HOURS_PER_DAY</span>
<span class="n">SEC_PER_WEEK</span> <span class="o">=</span> <span class="n">SEC_PER_DAY</span> <span class="o">*</span> <span class="n">DAYS_PER_WEEK</span>

<span class="n">MUSECONDS_PER_DAY</span> <span class="o">=</span> <span class="mf">1e6</span> <span class="o">*</span> <span class="n">SEC_PER_DAY</span>

<span class="n">MONDAY</span><span class="p">,</span> <span class="n">TUESDAY</span><span class="p">,</span> <span class="n">WEDNESDAY</span><span class="p">,</span> <span class="n">THURSDAY</span><span class="p">,</span> <span class="n">FRIDAY</span><span class="p">,</span> <span class="n">SATURDAY</span><span class="p">,</span> <span class="n">SUNDAY</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">MO</span><span class="p">,</span> <span class="n">TU</span><span class="p">,</span> <span class="n">WE</span><span class="p">,</span> <span class="n">TH</span><span class="p">,</span> <span class="n">FR</span><span class="p">,</span> <span class="n">SA</span><span class="p">,</span> <span class="n">SU</span><span class="p">)</span>
<span class="n">WEEKDAYS</span> <span class="o">=</span> <span class="p">(</span><span class="n">MONDAY</span><span class="p">,</span> <span class="n">TUESDAY</span><span class="p">,</span> <span class="n">WEDNESDAY</span><span class="p">,</span> <span class="n">THURSDAY</span><span class="p">,</span> <span class="n">FRIDAY</span><span class="p">,</span> <span class="n">SATURDAY</span><span class="p">,</span> <span class="n">SUNDAY</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_to_ordinalf</span><span class="p">(</span><span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert :mod:`datetime` or :mod:`date` to the Gregorian date as UTC float</span>
<span class="sd">    days, preserving hours, minutes, seconds and microseconds.  Return value</span>
<span class="sd">    is a :func:`float`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert to UTC</span>
    <span class="n">tzi</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="s1">&#39;tzinfo&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tzi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">astimezone</span><span class="p">(</span><span class="n">UTC</span><span class="p">)</span>
        <span class="n">tzi</span> <span class="o">=</span> <span class="n">UTC</span>

    <span class="n">base</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">toordinal</span><span class="p">())</span>

    <span class="c1"># If it&#39;s sufficiently datetime-like, it will have a `date()` method</span>
    <span class="n">cdate</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="s1">&#39;date&#39;</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="kc">None</span><span class="p">)()</span>
    <span class="k">if</span> <span class="n">cdate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Get a datetime object at midnight UTC</span>
        <span class="n">midnight_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="n">tzi</span><span class="p">)</span>

        <span class="n">rdt</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">cdate</span><span class="p">,</span> <span class="n">midnight_time</span><span class="p">)</span>

        <span class="c1"># Append the seconds as a fraction of a day</span>
        <span class="n">base</span> <span class="o">+=</span> <span class="p">(</span><span class="n">dt</span> <span class="o">-</span> <span class="n">rdt</span><span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">/</span> <span class="n">SEC_PER_DAY</span>

    <span class="k">return</span> <span class="n">base</span>


<span class="c1"># a version of _to_ordinalf that can operate on numpy arrays</span>
<span class="n">_to_ordinalf_np_vectorized</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">_to_ordinalf</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_dt64_to_ordinalf</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert `numpy.datetime64` or an ndarray of those types to Gregorian</span>
<span class="sd">    date as UTC float.  Roundoff is via float64 precision.  Practically:</span>
<span class="sd">    microseconds for dates between 290301 BC, 294241 AD, milliseconds for</span>
<span class="sd">    larger dates (see `numpy.datetime64`).  Nanoseconds aren&#39;t possible</span>
<span class="sd">    because we do times compared to ``0001-01-01T00:00:00`` (plus one day).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># the &quot;extra&quot; ensures that we at least allow the dynamic range out to</span>
    <span class="c1"># seconds.  That should get out to +/-2e11 years.</span>
    <span class="n">extra</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[s]&#39;</span><span class="p">)</span>
    <span class="n">extra</span> <span class="o">=</span> <span class="n">extra</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;timedelta64[ns]&#39;</span><span class="p">)</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;0001-01-01T00:00:00&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[s]&#39;</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[s]&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">+=</span> <span class="n">extra</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1.0e9</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">/</span> <span class="n">SEC_PER_DAY</span> <span class="o">+</span> <span class="mf">1.0</span>

    <span class="n">NaT_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;NaT&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">d_int</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">dt</span><span class="p">[</span><span class="n">d_int</span> <span class="o">==</span> <span class="n">NaT_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">d_int</span> <span class="o">==</span> <span class="n">NaT_int</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">return</span> <span class="n">dt</span>


<span class="k">def</span> <span class="nf">_from_ordinalf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert Gregorian float of the date, preserving hours, minutes,</span>
<span class="sd">    seconds and microseconds.  Return value is a `.datetime`.</span>

<span class="sd">    The input date *x* is a float in ordinal days at UTC, and the output will</span>
<span class="sd">    be the specified `.datetime` object corresponding to that time in</span>
<span class="sd">    timezone *tz*, or if *tz* is ``None``, in the timezone specified in</span>
<span class="sd">    :rc:`timezone`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tz</span> <span class="o">=</span> <span class="n">_get_rc_timezone</span><span class="p">()</span>

    <span class="n">ix</span><span class="p">,</span> <span class="n">remainder</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">ix</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ix</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot convert </span><span class="si">{}</span><span class="s1"> to a date.  This often happens if &#39;</span>
                         <span class="s1">&#39;non-datetime values are passed to an axis that &#39;</span>
                         <span class="s1">&#39;expects datetime objects.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ix</span><span class="p">))</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">fromordinal</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="n">UTC</span><span class="p">)</span>

    <span class="c1"># Since the input date `x` float is unable to preserve microsecond</span>
    <span class="c1"># precision of time representation in non-antique years, the</span>
    <span class="c1"># resulting datetime is rounded to the nearest multiple of</span>
    <span class="c1"># `musec_prec`. A value of 20 is appropriate for current dates.</span>
    <span class="n">musec_prec</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="n">remainder_musec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">remainder</span> <span class="o">*</span> <span class="n">MUSECONDS_PER_DAY</span> <span class="o">/</span> <span class="n">musec_prec</span><span class="p">)</span>
                          <span class="o">*</span> <span class="n">musec_prec</span><span class="p">)</span>

    <span class="c1"># For people trying to plot with full microsecond precision, enable</span>
    <span class="c1"># an early-year workaround</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">30</span> <span class="o">*</span> <span class="mi">365</span><span class="p">:</span>
        <span class="n">remainder_musec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">remainder</span> <span class="o">*</span> <span class="n">MUSECONDS_PER_DAY</span><span class="p">))</span>

    <span class="c1"># add hours, minutes, seconds, microseconds</span>
    <span class="n">dt</span> <span class="o">+=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">microseconds</span><span class="o">=</span><span class="n">remainder_musec</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dt</span><span class="o">.</span><span class="n">astimezone</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>


<span class="c1"># a version of _from_ordinalf that can operate on numpy arrays</span>
<span class="n">_from_ordinalf_np_vectorized</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">_from_ordinalf</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">strpdate2num</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use this class to parse date strings to matplotlib datenums when</span>
<span class="sd">    you know the date format string of the date you are parsing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; fmt: any valid strptime format is supported &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;s : string to be converted</span>
<span class="sd">           return value: a date2num float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">date2num</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="o">*</span><span class="n">time</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span><span class="p">)[:</span><span class="mi">6</span><span class="p">]))</span>


<span class="k">class</span> <span class="nc">bytespdate2num</span><span class="p">(</span><span class="n">strpdate2num</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use this class to parse date strings to matplotlib datenums when</span>
<span class="sd">    you know the date format string of the date you are parsing.  See</span>
<span class="sd">    :file:`examples/misc/load_converter.py`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            fmt: any valid strptime format is supported</span>
<span class="sd">            encoding: encoding to use on byte input (default: &#39;utf-8&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">bytespdate2num</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fmt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">encoding</span> <span class="o">=</span> <span class="n">encoding</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            b: byte input to be converted</span>
<span class="sd">        Returns:</span>
<span class="sd">            A date2num float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">encoding</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">bytespdate2num</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__call__</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>


<span class="c1"># a version of dateutil.parser.parse that can operate on nump0y arrays</span>
<span class="n">_dateutil_parser_parse_np_vectorized</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">dateutil</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">datestr2num</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a date string to a datenum using</span>
<span class="sd">    :func:`dateutil.parser.parse`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d : string or sequence of strings</span>
<span class="sd">        The dates to convert.</span>

<span class="sd">    default : datetime instance, optional</span>
<span class="sd">        The default date to use when fields are missing in *d*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">dateutil</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">date2num</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="n">dateutil</span><span class="o">.</span><span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">d</span><span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span>
        <span class="k">return</span> <span class="n">date2num</span><span class="p">(</span><span class="n">_dateutil_parser_parse_np_vectorized</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>


<div class="viewcode-block" id="date2num"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.date2num">[docs]</a><span class="k">def</span> <span class="nf">date2num</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert datetime objects to Matplotlib dates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    d : `datetime.datetime` or `numpy.datetime64` or sequences of these</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or sequence of floats</span>
<span class="sd">        Number of days (fraction part represents hours, minutes, seconds, ms)</span>
<span class="sd">        since 0001-01-01 00:00:00 UTC, plus one.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The addition of one here is a historical artifact. Also, note that the</span>
<span class="sd">    Gregorian calendar is assumed; this is not universal practice.</span>
<span class="sd">    For details see the module docstring.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s2">&quot;values&quot;</span><span class="p">):</span>
        <span class="c1"># this unpacks pandas series or dataframes...</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">values</span>

    <span class="k">if</span> <span class="p">((</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">))</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">_dt64_to_ordinalf</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cbook</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_to_ordinalf</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span>
        <span class="k">return</span> <span class="n">_to_ordinalf_np_vectorized</span><span class="p">(</span><span class="n">d</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">julian2num</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a Julian date (or sequence) to a Matplotlib date (or sequence).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    j : float or sequence of floats</span>
<span class="sd">        Julian date(s)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or sequence of floats</span>
<span class="sd">        Matplotlib date(s)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cbook</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">j</span> <span class="o">-</span> <span class="n">JULIAN_OFFSET</span>


<span class="k">def</span> <span class="nf">num2julian</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a Matplotlib date (or sequence) to a Julian date (or sequence).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : float or sequence of floats</span>
<span class="sd">        Matplotlib date(s)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float or sequence of floats</span>
<span class="sd">        Julian date(s)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cbook</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="n">JULIAN_OFFSET</span>


<div class="viewcode-block" id="num2date"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.num2date">[docs]</a><span class="k">def</span> <span class="nf">num2date</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert Matplotlib dates to `~datetime.datetime` objects.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : float or sequence of floats</span>
<span class="sd">        Number of days (fraction part represents hours, minutes, seconds)</span>
<span class="sd">        since 0001-01-01 00:00:00 UTC, plus one.</span>
<span class="sd">    tz : string, optional</span>
<span class="sd">        Timezone of *x* (defaults to rcparams ``timezone``).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `~datetime.datetime` or sequence of `~datetime.datetime`</span>
<span class="sd">        Dates are returned in timezone *tz*.</span>

<span class="sd">        If *x* is a sequence, a sequence of :class:`datetime` objects will</span>
<span class="sd">        be returned.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The addition of one here is a historical artifact. Also, note that the</span>
<span class="sd">    Gregorian calendar is assumed; this is not universal practice.</span>
<span class="sd">    For details, see the module docstring.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tz</span> <span class="o">=</span> <span class="n">_get_rc_timezone</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cbook</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_from_ordinalf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">return</span> <span class="n">_from_ordinalf_np_vectorized</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span></div>


<span class="k">def</span> <span class="nf">_ordinalf_to_timedelta</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>


<span class="n">_ordinalf_to_timedelta_np_vectorized</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">_ordinalf_to_timedelta</span><span class="p">)</span>


<div class="viewcode-block" id="num2timedelta"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.num2timedelta">[docs]</a><span class="k">def</span> <span class="nf">num2timedelta</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert number of days to a `~datetime.timedelta` object.</span>

<span class="sd">    If *x* is a sequence, a sequence of `~datetime.timedelta` objects will</span>
<span class="sd">    be returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : float, sequence of floats</span>
<span class="sd">        Number of days. The fraction part represents hours, minutes, seconds.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    `datetime.timedelta` or list[`datetime.timedelta`]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cbook</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_ordinalf_to_timedelta</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">return</span> <span class="n">_ordinalf_to_timedelta_np_vectorized</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span></div>


<div class="viewcode-block" id="drange"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.drange">[docs]</a><span class="k">def</span> <span class="nf">drange</span><span class="p">(</span><span class="n">dstart</span><span class="p">,</span> <span class="n">dend</span><span class="p">,</span> <span class="n">delta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a sequence of equally spaced Matplotlib dates.</span>

<span class="sd">    The dates start at *dstart* and reach up to, but not including *dend*.</span>
<span class="sd">    They are spaced by *delta*.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dstart, dend : `~datetime.datetime`</span>
<span class="sd">        The date limits.</span>
<span class="sd">    delta : `datetime.timedelta`</span>
<span class="sd">        Spacing of the dates.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    drange : `numpy.array`</span>
<span class="sd">        A list floats representing Matplotlib dates.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f1</span> <span class="o">=</span> <span class="n">date2num</span><span class="p">(</span><span class="n">dstart</span><span class="p">)</span>
    <span class="n">f2</span> <span class="o">=</span> <span class="n">date2num</span><span class="p">(</span><span class="n">dend</span><span class="p">)</span>
    <span class="n">step</span> <span class="o">=</span> <span class="n">delta</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">/</span> <span class="n">SEC_PER_DAY</span>

    <span class="c1"># calculate the difference between dend and dstart in times of delta</span>
    <span class="n">num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">f2</span> <span class="o">-</span> <span class="n">f1</span><span class="p">)</span> <span class="o">/</span> <span class="n">step</span><span class="p">))</span>

    <span class="c1"># calculate end of the interval which will be generated</span>
    <span class="n">dinterval_end</span> <span class="o">=</span> <span class="n">dstart</span> <span class="o">+</span> <span class="n">num</span> <span class="o">*</span> <span class="n">delta</span>

    <span class="c1"># ensure, that an half open interval will be generated [dstart, dend)</span>
    <span class="k">if</span> <span class="n">dinterval_end</span> <span class="o">&gt;=</span> <span class="n">dend</span><span class="p">:</span>
        <span class="c1"># if the endpoint is greated than dend, just subtract one delta</span>
        <span class="n">dinterval_end</span> <span class="o">-=</span> <span class="n">delta</span>
        <span class="n">num</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="n">f2</span> <span class="o">=</span> <span class="n">date2num</span><span class="p">(</span><span class="n">dinterval_end</span><span class="p">)</span>  <span class="c1"># new float-endpoint</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>

<span class="c1">### date tickers and formatters ###</span>


<div class="viewcode-block" id="DateFormatter"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.DateFormatter">[docs]</a><span class="k">class</span> <span class="nc">DateFormatter</span><span class="p">(</span><span class="n">ticker</span><span class="o">.</span><span class="n">Formatter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tick location is seconds since the epoch.  Use a :func:`strftime`</span>
<span class="sd">    format string.</span>

<span class="sd">    Python only supports :mod:`datetime` :func:`strftime` formatting</span>
<span class="sd">    for years greater than 1900.  Thanks to Andrew Dalke, Dalke</span>
<span class="sd">    Scientific Software who contributed the :func:`strftime` code</span>
<span class="sd">    below to include dates earlier than this year.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">illegal_s</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;((^|[^%])(</span><span class="si">%%</span><span class="s2">)*</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *fmt* is a :func:`strftime` format string; *tz* is the</span>
<span class="sd">         :class:`tzinfo` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tz</span> <span class="o">=</span> <span class="n">_get_rc_timezone</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="o">=</span> <span class="n">tz</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;DateFormatter found a value of x=0, which is &#39;</span>
                             <span class="s1">&#39;an illegal date.  This usually occurs because &#39;</span>
                             <span class="s1">&#39;you have not informed the axis that it is &#39;</span>
                             <span class="s1">&#39;plotting dates, e.g., with ax.xaxis_date()&#39;</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">num2date</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span><span class="p">)</span>

<div class="viewcode-block" id="DateFormatter.set_tzinfo"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.DateFormatter.set_tzinfo">[docs]</a>    <span class="k">def</span> <span class="nf">set_tzinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="o">=</span> <span class="n">tz</span></div>

    <span class="k">def</span> <span class="nf">_replace_common_substr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">sub1</span><span class="p">,</span> <span class="n">sub2</span><span class="p">,</span> <span class="n">replacement</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Helper function for replacing substrings sub1 and sub2</span>
<span class="sd">        located at the same indexes in strings s1 and s2 respectively,</span>
<span class="sd">        with the string replacement.  It is expected that sub1 and sub2</span>
<span class="sd">        have the same length.  Returns the pair s1, s2 after the</span>
<span class="sd">        substitutions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find common indexes of substrings sub1 in s1 and sub2 in s2</span>
        <span class="c1"># and make substitutions inplace. Because this is inplace,</span>
        <span class="c1"># it is okay if len(replacement) != len(sub1), len(sub2).</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">sub1</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">s2</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">j</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub2</span><span class="p">)]</span> <span class="o">!=</span> <span class="n">sub2</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">s1</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[:</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">replacement</span> <span class="o">+</span> <span class="n">s1</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub1</span><span class="p">):]</span>
            <span class="n">s2</span> <span class="o">=</span> <span class="n">s2</span><span class="p">[:</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">replacement</span> <span class="o">+</span> <span class="n">s2</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub2</span><span class="p">):]</span>

        <span class="k">return</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span>

<div class="viewcode-block" id="DateFormatter.strftime_pre_1900"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.DateFormatter.strftime_pre_1900">[docs]</a>    <span class="k">def</span> <span class="nf">strftime_pre_1900</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Call time.strftime for years before 1900 by rolling</span>
<span class="sd">        forward a multiple of 28 years.</span>

<span class="sd">        *fmt* is a :func:`strftime` format string.</span>

<span class="sd">        Dalke: I hope I did this math right.  Every 28 years the</span>
<span class="sd">        calendar repeats, except through century leap years excepting</span>
<span class="sd">        the 400 year leap years.  But only if you&#39;re using the Gregorian</span>
<span class="sd">        calendar.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fmt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span>

        <span class="c1"># Since python&#39;s time module&#39;s strftime implementation does not</span>
        <span class="c1"># support %f microsecond (but the datetime module does), use a</span>
        <span class="c1"># regular expression substitution to replace instances of %f.</span>
        <span class="c1"># Note that this can be useful since python&#39;s floating-point</span>
        <span class="c1"># precision representation for datetime causes precision to be</span>
        <span class="c1"># more accurate closer to year 0 (around the year 2000, precision</span>
        <span class="c1"># can be at 10s of microseconds).</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;((^|[^%])(</span><span class="si">%%</span><span class="s1">)*)</span><span class="si">%f</span><span class="s1">&#39;</span><span class="p">,</span>
                     <span class="sa">r</span><span class="s1">&#39;\g&lt;1&gt;</span><span class="si">{0:06d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">microsecond</span><span class="p">),</span> <span class="n">fmt</span><span class="p">)</span>

        <span class="n">year</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">year</span>
        <span class="c1"># For every non-leap year century, advance by</span>
        <span class="c1"># 6 years to get into the 28-year repeat cycle</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="mi">2000</span> <span class="o">-</span> <span class="n">year</span>
        <span class="n">off</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">*</span> <span class="p">(</span><span class="n">delta</span> <span class="o">//</span> <span class="mi">100</span> <span class="o">+</span> <span class="n">delta</span> <span class="o">//</span> <span class="mi">400</span><span class="p">)</span>
        <span class="n">year</span> <span class="o">=</span> <span class="n">year</span> <span class="o">+</span> <span class="n">off</span>

        <span class="c1"># Move to between the years 1973 and 2000</span>
        <span class="n">year1</span> <span class="o">=</span> <span class="n">year</span> <span class="o">+</span> <span class="p">((</span><span class="mi">2000</span> <span class="o">-</span> <span class="n">year</span><span class="p">)</span> <span class="o">//</span> <span class="mi">28</span><span class="p">)</span> <span class="o">*</span> <span class="mi">28</span>
        <span class="n">year2</span> <span class="o">=</span> <span class="n">year1</span> <span class="o">+</span> <span class="mi">28</span>
        <span class="n">timetuple</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">timetuple</span><span class="p">()</span>
        <span class="c1"># Generate timestamp string for year and year+28</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="p">(</span><span class="n">year1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">timetuple</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="p">(</span><span class="n">year2</span><span class="p">,)</span> <span class="o">+</span> <span class="n">timetuple</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="c1"># Replace instances of respective years (both 2-digit and 4-digit)</span>
        <span class="c1"># that are located at the same indexes of s1, s2 with dt&#39;s year.</span>
        <span class="c1"># Note that C++&#39;s strftime implementation does not use padded</span>
        <span class="c1"># zeros or padded whitespace for %y or %Y for years before 100, but</span>
        <span class="c1"># uses padded zeros for %x. (For example, try the runnable examples</span>
        <span class="c1"># with .tm_year in the interval [-1900, -1800] on</span>
        <span class="c1"># http://en.cppreference.com/w/c/chrono/strftime.) For ease of</span>
        <span class="c1"># implementation, we always use padded zeros for %y, %Y, and %x.</span>
        <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_common_substr</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span>
                                             <span class="s2">&quot;</span><span class="si">{0:04d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">year1</span><span class="p">),</span>
                                             <span class="s2">&quot;</span><span class="si">{0:04d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">year2</span><span class="p">),</span>
                                             <span class="s2">&quot;</span><span class="si">{0:04d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span><span class="p">))</span>
        <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_common_substr</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span>
                                             <span class="s2">&quot;</span><span class="si">{0:02d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">year1</span> <span class="o">%</span> <span class="mi">100</span><span class="p">),</span>
                                             <span class="s2">&quot;</span><span class="si">{0:02d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">year2</span> <span class="o">%</span> <span class="mi">100</span><span class="p">),</span>
                                             <span class="s2">&quot;</span><span class="si">{0:02d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">year</span> <span class="o">%</span> <span class="mi">100</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">cbook</span><span class="o">.</span><span class="n">unicode_safe</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span></div>

<div class="viewcode-block" id="DateFormatter.strftime"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.DateFormatter.strftime">[docs]</a>    <span class="k">def</span> <span class="nf">strftime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Refer to documentation for :meth:`datetime.datetime.strftime`</span>

<span class="sd">        *fmt* is a :meth:`datetime.datetime.strftime` format string.</span>

<span class="sd">        Warning: For years before 1900, depending upon the current</span>
<span class="sd">        locale it is possible that the year displayed with %x might</span>
<span class="sd">        be incorrect. For years before 100, %y and %Y will yield</span>
<span class="sd">        zero-padded strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fmt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">illegal_s</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\1&quot;</span><span class="p">,</span> <span class="n">fmt</span><span class="p">)</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dt</span><span class="o">.</span><span class="n">year</span> <span class="o">&gt;=</span> <span class="mi">1900</span><span class="p">:</span>
            <span class="c1"># Note: in python 3.3 this is okay for years &gt;= 1000,</span>
            <span class="c1"># refer to http://bugs.python.org/issue1777412</span>
            <span class="k">return</span> <span class="n">cbook</span><span class="o">.</span><span class="n">unicode_safe</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">fmt</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strftime_pre_1900</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">fmt</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="IndexDateFormatter"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.IndexDateFormatter">[docs]</a><span class="k">class</span> <span class="nc">IndexDateFormatter</span><span class="p">(</span><span class="n">ticker</span><span class="o">.</span><span class="n">Formatter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use with :class:`~matplotlib.ticker.IndexLocator` to cycle format</span>
<span class="sd">    strings by index.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *t* is a sequence of dates (floating point days).  *fmt* is a</span>
<span class="sd">        :func:`strftime` format string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tz</span> <span class="o">=</span> <span class="n">_get_rc_timezone</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">t</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="o">=</span> <span class="n">tz</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="s1">&#39;Return the label for time *x* at position *pos*&#39;</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">ind</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">)</span> <span class="ow">or</span> <span class="n">ind</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&#39;</span>

        <span class="n">dt</span> <span class="o">=</span> <span class="n">num2date</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cbook</span><span class="o">.</span><span class="n">unicode_safe</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fmt</span><span class="p">))</span></div>


<div class="viewcode-block" id="AutoDateFormatter"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.AutoDateFormatter">[docs]</a><span class="k">class</span> <span class="nc">AutoDateFormatter</span><span class="p">(</span><span class="n">ticker</span><span class="o">.</span><span class="n">Formatter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class attempts to figure out the best format to use.  This is</span>
<span class="sd">    most useful when used with the :class:`AutoDateLocator`.</span>


<span class="sd">    The AutoDateFormatter has a scale dictionary that maps the scale</span>
<span class="sd">    of the tick (the distance in days between one major tick) and a</span>
<span class="sd">    format string.  The default looks like this::</span>

<span class="sd">        self.scaled = {</span>
<span class="sd">            DAYS_PER_YEAR: rcParams[&#39;date.autoformat.year&#39;],</span>
<span class="sd">            DAYS_PER_MONTH: rcParams[&#39;date.autoformat.month&#39;],</span>
<span class="sd">            1.0: rcParams[&#39;date.autoformat.day&#39;],</span>
<span class="sd">            1. / HOURS_PER_DAY: rcParams[&#39;date.autoformat.hour&#39;],</span>
<span class="sd">            1. / (MINUTES_PER_DAY): rcParams[&#39;date.autoformat.minute&#39;],</span>
<span class="sd">            1. / (SEC_PER_DAY): rcParams[&#39;date.autoformat.second&#39;],</span>
<span class="sd">            1. / (MUSECONDS_PER_DAY): rcParams[&#39;date.autoformat.microsecond&#39;],</span>
<span class="sd">            }</span>


<span class="sd">    The algorithm picks the key in the dictionary that is &gt;= the</span>
<span class="sd">    current scale and uses that format string.  You can customize this</span>
<span class="sd">    dictionary by doing::</span>


<span class="sd">    &gt;&gt;&gt; locator = AutoDateLocator()</span>
<span class="sd">    &gt;&gt;&gt; formatter = AutoDateFormatter(locator)</span>
<span class="sd">    &gt;&gt;&gt; formatter.scaled[1/(24.*60.)] = &#39;%M:%S&#39; # only show min and sec</span>

<span class="sd">    A custom :class:`~matplotlib.ticker.FuncFormatter` can also be used.</span>
<span class="sd">    The following example shows how to use a custom format function to strip</span>
<span class="sd">    trailing zeros from decimal seconds and adds the date to the first</span>
<span class="sd">    ticklabel::</span>

<span class="sd">        &gt;&gt;&gt; def my_format_function(x, pos=None):</span>
<span class="sd">        ...     x = matplotlib.dates.num2date(x)</span>
<span class="sd">        ...     if pos == 0:</span>
<span class="sd">        ...         fmt = &#39;%D %H:%M:%S.%f&#39;</span>
<span class="sd">        ...     else:</span>
<span class="sd">        ...         fmt = &#39;%H:%M:%S.%f&#39;</span>
<span class="sd">        ...     label = x.strftime(fmt)</span>
<span class="sd">        ...     label = label.rstrip(&quot;0&quot;)</span>
<span class="sd">        ...     label = label.rstrip(&quot;.&quot;)</span>
<span class="sd">        ...     return label</span>
<span class="sd">        &gt;&gt;&gt; from matplotlib.ticker import FuncFormatter</span>
<span class="sd">        &gt;&gt;&gt; formatter.scaled[1/(24.*60.)] = FuncFormatter(my_format_function)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># This can be improved by providing some user-level direction on</span>
    <span class="c1"># how to choose the best format (precedence, etc...)</span>

    <span class="c1"># Perhaps a &#39;struct&#39; that has a field for each time-type where a</span>
    <span class="c1"># zero would indicate &quot;don&#39;t show&quot; and a number would indicate</span>
    <span class="c1"># &quot;show&quot; with some sort of priority.  Same priorities could mean</span>
    <span class="c1"># show all with the same priority.</span>

    <span class="c1"># Or more simply, perhaps just a format string for each</span>
    <span class="c1"># possibility...</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locator</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">defaultfmt</span><span class="o">=</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Autoformat the date labels.  The default format is the one to use</span>
<span class="sd">        if none of the values in ``self.scaled`` are greater than the unit</span>
<span class="sd">        returned by ``locator._get_unit()``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locator</span> <span class="o">=</span> <span class="n">locator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tz</span> <span class="o">=</span> <span class="n">tz</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defaultfmt</span> <span class="o">=</span> <span class="n">defaultfmt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_formatter</span> <span class="o">=</span> <span class="n">DateFormatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defaultfmt</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scaled</span> <span class="o">=</span> <span class="p">{</span><span class="n">DAYS_PER_YEAR</span><span class="p">:</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;date.autoformatter.year&#39;</span><span class="p">],</span>
                       <span class="n">DAYS_PER_MONTH</span><span class="p">:</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;date.autoformatter.month&#39;</span><span class="p">],</span>
                       <span class="mf">1.0</span><span class="p">:</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;date.autoformatter.day&#39;</span><span class="p">],</span>
                       <span class="mf">1.</span> <span class="o">/</span> <span class="n">HOURS_PER_DAY</span><span class="p">:</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;date.autoformatter.hour&#39;</span><span class="p">],</span>
                       <span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="n">MINUTES_PER_DAY</span><span class="p">):</span>
                           <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;date.autoformatter.minute&#39;</span><span class="p">],</span>
                       <span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="n">SEC_PER_DAY</span><span class="p">):</span>
                           <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;date.autoformatter.second&#39;</span><span class="p">],</span>
                       <span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="n">MUSECONDS_PER_DAY</span><span class="p">):</span>
                           <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;date.autoformatter.microsecond&#39;</span><span class="p">]}</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">locator_unit_scale</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_locator</span><span class="o">.</span><span class="n">_get_unit</span><span class="p">())</span>
        <span class="c1"># Pick the first scale which is greater than the locator unit.</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">fmt</span> <span class="k">for</span> <span class="n">scale</span><span class="p">,</span> <span class="n">fmt</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scaled</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
                    <span class="k">if</span> <span class="n">scale</span> <span class="o">&gt;=</span> <span class="n">locator_unit_scale</span><span class="p">),</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">defaultfmt</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_formatter</span> <span class="o">=</span> <span class="n">DateFormatter</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tz</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_formatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">fmt</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">fmt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unexpected type passed to </span><span class="si">{0!r}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">result</span></div>


<span class="k">class</span> <span class="nc">rrulewrapper</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">tzinfo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;freq&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base_tzinfo</span> <span class="o">=</span> <span class="n">tzinfo</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_rrule</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_rrule</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_construct</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_rrule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">tzinfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_tzinfo</span>

        <span class="c1"># rrule does not play nicely with time zones - especially pytz time</span>
        <span class="c1"># zones, it&#39;s best to use naive zones and attach timezones once the</span>
        <span class="c1"># datetimes are returned</span>
        <span class="k">if</span> <span class="s1">&#39;dtstart&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">dtstart</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dtstart&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dtstart</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tzinfo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">tzinfo</span> <span class="o">=</span> <span class="n">dtstart</span><span class="o">.</span><span class="n">tzinfo</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dtstart</span> <span class="o">=</span> <span class="n">dtstart</span><span class="o">.</span><span class="n">astimezone</span><span class="p">(</span><span class="n">tzinfo</span><span class="p">)</span>

                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dtstart&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dtstart</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;until&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">until</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;until&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">until</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">until</span> <span class="o">=</span> <span class="n">until</span><span class="o">.</span><span class="n">astimezone</span><span class="p">(</span><span class="n">tzinfo</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;until cannot be aware if dtstart &#39;</span>
                                     <span class="s1">&#39;is naive and tzinfo is None&#39;</span><span class="p">)</span>

                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;until&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">until</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_construct</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tzinfo</span> <span class="o">=</span> <span class="n">tzinfo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rrule</span> <span class="o">=</span> <span class="n">rrule</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_construct</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_attach_tzinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">tzinfo</span><span class="p">):</span>
        <span class="c1"># pytz zones are attached by &quot;localizing&quot; the datetime</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tzinfo</span><span class="p">,</span> <span class="s1">&#39;localize&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">tzinfo</span><span class="o">.</span><span class="n">localize</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">is_dst</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dt</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="n">tzinfo</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_aware_return_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">returns_list</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Decorator function that allows rrule methods to handle tzinfo.&quot;&quot;&quot;</span>
        <span class="c1"># This is only necessary if we&#39;re actually attaching a tzinfo</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tzinfo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">f</span>

        <span class="c1"># All datetime arguments must be naive. If they are not naive, they are</span>
        <span class="c1"># converted to the _tzinfo zone before dropping the zone.</span>
        <span class="k">def</span> <span class="nf">normalize_arg</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arg</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">tzinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tzinfo</span><span class="p">:</span>
                    <span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">astimezone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tzinfo</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">arg</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">tzinfo</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">arg</span>

        <span class="k">def</span> <span class="nf">normalize_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">normalize_arg</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">kw</span><span class="p">:</span> <span class="n">normalize_arg</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">kw</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

            <span class="k">return</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span>

        <span class="c1"># There are two kinds of functions we care about - ones that return</span>
        <span class="c1"># dates and ones that return lists of dates.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">returns_list</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">inner_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">normalize_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attach_tzinfo</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tzinfo</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">inner_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">normalize_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
                <span class="n">dts</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_attach_tzinfo</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tzinfo</span><span class="p">)</span> <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dts</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)(</span><span class="n">inner_func</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="n">f</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rrule</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;after&#39;</span><span class="p">,</span> <span class="s1">&#39;before&#39;</span><span class="p">}:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aware_return_wrapper</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;xafter&#39;</span><span class="p">,</span> <span class="s1">&#39;xbefore&#39;</span><span class="p">,</span> <span class="s1">&#39;between&#39;</span><span class="p">}:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aware_return_wrapper</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">returns_list</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">f</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>


<div class="viewcode-block" id="DateLocator"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.DateLocator">[docs]</a><span class="k">class</span> <span class="nc">DateLocator</span><span class="p">(</span><span class="n">ticker</span><span class="o">.</span><span class="n">Locator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines the tick locations when plotting dates.</span>

<span class="sd">    This class is subclassed by other Locators and</span>
<span class="sd">    is not meant to be used on its own.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">hms0d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;byhour&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;byminute&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;bysecond&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *tz* is a :class:`tzinfo` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tz</span> <span class="o">=</span> <span class="n">_get_rc_timezone</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="o">=</span> <span class="n">tz</span>

<div class="viewcode-block" id="DateLocator.set_tzinfo"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.DateLocator.set_tzinfo">[docs]</a>    <span class="k">def</span> <span class="nf">set_tzinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set time zone info.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="o">=</span> <span class="n">tz</span></div>

<div class="viewcode-block" id="DateLocator.datalim_to_dt"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.DateLocator.datalim_to_dt">[docs]</a>    <span class="k">def</span> <span class="nf">datalim_to_dt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert axis data interval to datetime objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">get_data_interval</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">dmin</span> <span class="o">&gt;</span> <span class="n">dmax</span><span class="p">:</span>
            <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">=</span> <span class="n">dmax</span><span class="p">,</span> <span class="n">dmin</span>
        <span class="k">if</span> <span class="n">dmin</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;datalim minimum </span><span class="si">{}</span><span class="s1"> is less than 1 and &#39;</span>
                             <span class="s1">&#39;is an invalid Matplotlib date value. This often &#39;</span>
                             <span class="s1">&#39;happens if you pass a non-datetime &#39;</span>
                             <span class="s1">&#39;value to an axis that has datetime units&#39;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dmin</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">num2date</span><span class="p">(</span><span class="n">dmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">),</span> <span class="n">num2date</span><span class="p">(</span><span class="n">dmax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span></div>

<div class="viewcode-block" id="DateLocator.viewlim_to_dt"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.DateLocator.viewlim_to_dt">[docs]</a>    <span class="k">def</span> <span class="nf">viewlim_to_dt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the view interval to datetime objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">get_view_interval</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">vmin</span> <span class="o">&gt;</span> <span class="n">vmax</span><span class="p">:</span>
            <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">vmax</span><span class="p">,</span> <span class="n">vmin</span>
        <span class="k">if</span> <span class="n">vmin</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;view limit minimum </span><span class="si">{}</span><span class="s1"> is less than 1 and &#39;</span>
                             <span class="s1">&#39;is an invalid Matplotlib date value. This &#39;</span>
                             <span class="s1">&#39;often happens if you pass a non-datetime &#39;</span>
                             <span class="s1">&#39;value to an axis that has datetime units&#39;</span>
                             <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vmin</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">num2date</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">),</span> <span class="n">num2date</span><span class="p">(</span><span class="n">vmax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return how many days a unit of the locator is; used for</span>
<span class="sd">        intelligent autoscaling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_get_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of units for each tick.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span>

<div class="viewcode-block" id="DateLocator.nonsingular"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.DateLocator.nonsingular">[docs]</a>    <span class="k">def</span> <span class="nf">nonsingular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the proposed upper and lower extent, adjust the range</span>
<span class="sd">        if it is too close to being singular (i.e. a range of ~0).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_unit</span><span class="p">()</span>
        <span class="n">interval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_interval</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">vmax</span> <span class="o">-</span> <span class="n">vmin</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-6</span><span class="p">:</span>
            <span class="n">vmin</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">unit</span> <span class="o">*</span> <span class="n">interval</span>
            <span class="n">vmax</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">unit</span> <span class="o">*</span> <span class="n">interval</span>
        <span class="k">return</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span></div></div>


<div class="viewcode-block" id="RRuleLocator"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.RRuleLocator">[docs]</a><span class="k">class</span> <span class="nc">RRuleLocator</span><span class="p">(</span><span class="n">DateLocator</span><span class="p">):</span>
    <span class="c1"># use the dateutil rrule instance</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">DateLocator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rule</span> <span class="o">=</span> <span class="n">o</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># if no data have been set, this will tank with a ValueError</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">viewlim_to_dt</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tick_values</span><span class="p">(</span><span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span><span class="p">)</span>

<div class="viewcode-block" id="RRuleLocator.tick_values"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.RRuleLocator.tick_values">[docs]</a>    <span class="k">def</span> <span class="nf">tick_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">):</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">relativedelta</span><span class="p">(</span><span class="n">vmax</span><span class="p">,</span> <span class="n">vmin</span><span class="p">)</span>

        <span class="c1"># We need to cap at the endpoints of valid datetime</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">vmin</span> <span class="o">-</span> <span class="n">delta</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">OverflowError</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">_from_ordinalf</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">vmax</span> <span class="o">+</span> <span class="n">delta</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">OverflowError</span><span class="p">):</span>
            <span class="c1"># The magic number!</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">_from_ordinalf</span><span class="p">(</span><span class="mf">3652059.9999999</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rule</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">dtstart</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">until</span><span class="o">=</span><span class="n">stop</span><span class="p">)</span>

        <span class="n">dates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule</span><span class="o">.</span><span class="n">between</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dates</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">date2num</span><span class="p">([</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">raise_if_exceeds</span><span class="p">(</span><span class="n">date2num</span><span class="p">(</span><span class="n">dates</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_get_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return how many days a unit of the locator is; used for</span>
<span class="sd">        intelligent autoscaling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule</span><span class="o">.</span><span class="n">_rrule</span><span class="o">.</span><span class="n">_freq</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unit_generic</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>

<div class="viewcode-block" id="RRuleLocator.get_unit_generic"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.RRuleLocator.get_unit_generic">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_unit_generic</span><span class="p">(</span><span class="n">freq</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">freq</span> <span class="o">==</span> <span class="n">YEARLY</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">DAYS_PER_YEAR</span>
        <span class="k">elif</span> <span class="n">freq</span> <span class="o">==</span> <span class="n">MONTHLY</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">DAYS_PER_MONTH</span>
        <span class="k">elif</span> <span class="n">freq</span> <span class="o">==</span> <span class="n">WEEKLY</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">DAYS_PER_WEEK</span>
        <span class="k">elif</span> <span class="n">freq</span> <span class="o">==</span> <span class="n">DAILY</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span>
        <span class="k">elif</span> <span class="n">freq</span> <span class="o">==</span> <span class="n">HOURLY</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">HOURS_PER_DAY</span>
        <span class="k">elif</span> <span class="n">freq</span> <span class="o">==</span> <span class="n">MINUTELY</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">MINUTES_PER_DAY</span>
        <span class="k">elif</span> <span class="n">freq</span> <span class="o">==</span> <span class="n">SECONDLY</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">SEC_PER_DAY</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># error</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>   <span class="c1"># or should this just return &#39;1&#39;?</span></div>

    <span class="k">def</span> <span class="nf">_get_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule</span><span class="o">.</span><span class="n">_rrule</span><span class="o">.</span><span class="n">_interval</span>

<div class="viewcode-block" id="RRuleLocator.autoscale"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.RRuleLocator.autoscale">[docs]</a>    <span class="k">def</span> <span class="nf">autoscale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the view limits to include the data range.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datalim_to_dt</span><span class="p">()</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">relativedelta</span><span class="p">(</span><span class="n">dmax</span><span class="p">,</span> <span class="n">dmin</span><span class="p">)</span>

        <span class="c1"># We need to cap at the endpoints of valid datetime</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">dmin</span> <span class="o">-</span> <span class="n">delta</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">_from_ordinalf</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">dmax</span> <span class="o">+</span> <span class="n">delta</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># The magic number!</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">_from_ordinalf</span><span class="p">(</span><span class="mf">3652059.9999999</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rule</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">dtstart</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">until</span><span class="o">=</span><span class="n">stop</span><span class="p">)</span>
        <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datalim_to_dt</span><span class="p">()</span>

        <span class="n">vmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule</span><span class="o">.</span><span class="n">before</span><span class="p">(</span><span class="n">dmin</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">vmin</span><span class="p">:</span>
            <span class="n">vmin</span> <span class="o">=</span> <span class="n">dmin</span>

        <span class="n">vmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rule</span><span class="o">.</span><span class="n">after</span><span class="p">(</span><span class="n">dmax</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">vmax</span><span class="p">:</span>
            <span class="n">vmax</span> <span class="o">=</span> <span class="n">dmax</span>

        <span class="n">vmin</span> <span class="o">=</span> <span class="n">date2num</span><span class="p">(</span><span class="n">vmin</span><span class="p">)</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">date2num</span><span class="p">(</span><span class="n">vmax</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonsingular</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="AutoDateLocator"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.AutoDateLocator">[docs]</a><span class="k">class</span> <span class="nc">AutoDateLocator</span><span class="p">(</span><span class="n">DateLocator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    On autoscale, this class picks the best</span>
<span class="sd">    :class:`DateLocator` to set the view limits and the tick</span>
<span class="sd">    locations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minticks</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">maxticks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">interval_multiples</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *minticks* is the minimum number of ticks desired, which is used to</span>
<span class="sd">        select the type of ticking (yearly, monthly, etc.).</span>

<span class="sd">        *maxticks* is the maximum number of ticks desired, which controls</span>
<span class="sd">        any interval between ticks (ticking every other, every 3, etc.).</span>
<span class="sd">        For really fine-grained control, this can be a dictionary mapping</span>
<span class="sd">        individual rrule frequency constants (YEARLY, MONTHLY, etc.)</span>
<span class="sd">        to their own maximum number of ticks.  This can be used to keep</span>
<span class="sd">        the number of ticks appropriate to the format chosen in</span>
<span class="sd">        :class:`AutoDateFormatter`. Any frequency not specified in this</span>
<span class="sd">        dictionary is given a default value.</span>

<span class="sd">        *tz* is a :class:`tzinfo` instance.</span>

<span class="sd">        *interval_multiples* is a boolean that indicates whether ticks</span>
<span class="sd">        should be chosen to be multiple of the interval. This will lock</span>
<span class="sd">        ticks to &#39;nicer&#39; locations. For example, this will force the</span>
<span class="sd">        ticks to be at hours 0,6,12,18 when hourly ticking is done at</span>
<span class="sd">        6 hour intervals.</span>

<span class="sd">        The AutoDateLocator has an interval dictionary that maps the</span>
<span class="sd">        frequency of the tick (a constant from dateutil.rrule) and a</span>
<span class="sd">        multiple allowed for that ticking.  The default looks like this::</span>

<span class="sd">          self.intervald = {</span>
<span class="sd">            YEARLY  : [1, 2, 4, 5, 10, 20, 40, 50, 100, 200, 400, 500,</span>
<span class="sd">                      1000, 2000, 4000, 5000, 10000],</span>
<span class="sd">            MONTHLY : [1, 2, 3, 4, 6],</span>
<span class="sd">            DAILY   : [1, 2, 3, 7, 14],</span>
<span class="sd">            HOURLY  : [1, 2, 3, 4, 6, 12],</span>
<span class="sd">            MINUTELY: [1, 5, 10, 15, 30],</span>
<span class="sd">            SECONDLY: [1, 5, 10, 15, 30],</span>
<span class="sd">            MICROSECONDLY: [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000,</span>
<span class="sd">                           5000, 10000, 20000, 50000, 100000, 200000, 500000,</span>
<span class="sd">                           1000000],</span>
<span class="sd">            }</span>

<span class="sd">        The interval is used to specify multiples that are appropriate for</span>
<span class="sd">        the frequency of ticking. For instance, every 7 days is sensible</span>
<span class="sd">        for daily ticks, but for minutes/seconds, 15 or 30 make sense.</span>
<span class="sd">        You can customize this dictionary by doing::</span>

<span class="sd">          locator = AutoDateLocator()</span>
<span class="sd">          locator.intervald[HOURLY] = [3] # only show every 3 hours</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">DateLocator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locator</span> <span class="o">=</span> <span class="n">YearLocator</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span> <span class="o">=</span> <span class="n">YEARLY</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_freqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">YEARLY</span><span class="p">,</span> <span class="n">MONTHLY</span><span class="p">,</span> <span class="n">DAILY</span><span class="p">,</span> <span class="n">HOURLY</span><span class="p">,</span> <span class="n">MINUTELY</span><span class="p">,</span>
                       <span class="n">SECONDLY</span><span class="p">,</span> <span class="n">MICROSECONDLY</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minticks</span> <span class="o">=</span> <span class="n">minticks</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">maxticks</span> <span class="o">=</span> <span class="p">{</span><span class="n">YEARLY</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="n">MONTHLY</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="n">DAILY</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="n">HOURLY</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span>
                         <span class="n">MINUTELY</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="n">SECONDLY</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="n">MICROSECONDLY</span><span class="p">:</span> <span class="mi">8</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">maxticks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">maxticks</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">maxticks</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># Assume we were given an integer. Use this as the maximum</span>
                <span class="c1"># number of ticks for every frequency and create a</span>
                <span class="c1"># dictionary for this</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">maxticks</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_freqs</span><span class="p">,</span> <span class="n">maxticks</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interval_multiples</span> <span class="o">=</span> <span class="n">interval_multiples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intervald</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">YEARLY</span><span class="p">:</span>   <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span>
                       <span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">4000</span><span class="p">,</span> <span class="mi">5000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">],</span>
            <span class="n">MONTHLY</span><span class="p">:</span>  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
            <span class="n">DAILY</span><span class="p">:</span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">21</span><span class="p">],</span>
            <span class="n">HOURLY</span><span class="p">:</span>   <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span>
            <span class="n">MINUTELY</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span>
            <span class="n">SECONDLY</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span>
            <span class="n">MICROSECONDLY</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span>
                            <span class="mi">5000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="mi">20000</span><span class="p">,</span> <span class="mi">50000</span><span class="p">,</span> <span class="mi">100000</span><span class="p">,</span> <span class="mi">200000</span><span class="p">,</span> <span class="mi">500000</span><span class="p">,</span>
                            <span class="mi">1000000</span><span class="p">]}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_byranges</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">13</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span>
                          <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">24</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span> <span class="kc">None</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s1">&#39;Return the locations of the ticks&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locator</span><span class="p">()</span>

<div class="viewcode-block" id="AutoDateLocator.tick_values"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.AutoDateLocator.tick_values">[docs]</a>    <span class="k">def</span> <span class="nf">tick_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_locator</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span><span class="o">.</span><span class="n">tick_values</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span></div>

<div class="viewcode-block" id="AutoDateLocator.nonsingular"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.AutoDateLocator.nonsingular">[docs]</a>    <span class="k">def</span> <span class="nf">nonsingular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">):</span>
        <span class="c1"># whatever is thrown at us, we can scale the unit.</span>
        <span class="c1"># But default nonsingular date plots at an ~4 year period.</span>
        <span class="k">if</span> <span class="n">vmin</span> <span class="o">==</span> <span class="n">vmax</span><span class="p">:</span>
            <span class="n">vmin</span> <span class="o">=</span> <span class="n">vmin</span> <span class="o">-</span> <span class="n">DAYS_PER_YEAR</span> <span class="o">*</span> <span class="mi">2</span>
            <span class="n">vmax</span> <span class="o">=</span> <span class="n">vmax</span> <span class="o">+</span> <span class="n">DAYS_PER_YEAR</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span></div>

<div class="viewcode-block" id="AutoDateLocator.set_axis"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.AutoDateLocator.set_axis">[docs]</a>    <span class="k">def</span> <span class="nf">set_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="n">DateLocator</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locator</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span></div>

<div class="viewcode-block" id="AutoDateLocator.refresh"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.AutoDateLocator.refresh">[docs]</a>    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s1">&#39;Refresh internal information based on current limits.&#39;</span>
        <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">viewlim_to_dt</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_locator</span><span class="p">(</span><span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span> <span class="ow">in</span> <span class="p">[</span><span class="n">MICROSECONDLY</span><span class="p">]:</span>
            <span class="k">return</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">MUSECONDS_PER_DAY</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">RRuleLocator</span><span class="o">.</span><span class="n">get_unit_generic</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">)</span>

<div class="viewcode-block" id="AutoDateLocator.autoscale"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.AutoDateLocator.autoscale">[docs]</a>    <span class="k">def</span> <span class="nf">autoscale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s1">&#39;Try to choose the view limits intelligently.&#39;</span>
        <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datalim_to_dt</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_locator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_locator</span><span class="p">(</span><span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_locator</span><span class="o">.</span><span class="n">autoscale</span><span class="p">()</span></div>

<div class="viewcode-block" id="AutoDateLocator.get_locator"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.AutoDateLocator.get_locator">[docs]</a>    <span class="k">def</span> <span class="nf">get_locator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span><span class="p">):</span>
        <span class="s1">&#39;Pick the best locator based on a distance.&#39;</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">relativedelta</span><span class="p">(</span><span class="n">dmax</span><span class="p">,</span> <span class="n">dmin</span><span class="p">)</span>
        <span class="n">tdelta</span> <span class="o">=</span> <span class="n">dmax</span> <span class="o">-</span> <span class="n">dmin</span>

        <span class="c1"># take absolute difference</span>
        <span class="k">if</span> <span class="n">dmin</span> <span class="o">&gt;</span> <span class="n">dmax</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="o">-</span><span class="n">delta</span>
            <span class="n">tdelta</span> <span class="o">=</span> <span class="o">-</span><span class="n">tdelta</span>

        <span class="c1"># The following uses a mix of calls to relativedelta and timedelta</span>
        <span class="c1"># methods because there is incomplete overlap in the functionality of</span>
        <span class="c1"># these similar functions, and it&#39;s best to avoid doing our own math</span>
        <span class="c1"># whenever possible.</span>
        <span class="n">numYears</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">delta</span><span class="o">.</span><span class="n">years</span><span class="p">)</span>
        <span class="n">numMonths</span> <span class="o">=</span> <span class="n">numYears</span> <span class="o">*</span> <span class="n">MONTHS_PER_YEAR</span> <span class="o">+</span> <span class="n">delta</span><span class="o">.</span><span class="n">months</span>
        <span class="n">numDays</span> <span class="o">=</span> <span class="n">tdelta</span><span class="o">.</span><span class="n">days</span>   <span class="c1"># Avoids estimates of days/month, days/year</span>
        <span class="n">numHours</span> <span class="o">=</span> <span class="n">numDays</span> <span class="o">*</span> <span class="n">HOURS_PER_DAY</span> <span class="o">+</span> <span class="n">delta</span><span class="o">.</span><span class="n">hours</span>
        <span class="n">numMinutes</span> <span class="o">=</span> <span class="n">numHours</span> <span class="o">*</span> <span class="n">MIN_PER_HOUR</span> <span class="o">+</span> <span class="n">delta</span><span class="o">.</span><span class="n">minutes</span>
        <span class="n">numSeconds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">tdelta</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">())</span>
        <span class="n">numMicroseconds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">tdelta</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">*</span> <span class="mf">1e6</span><span class="p">)</span>

        <span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="n">numYears</span><span class="p">,</span> <span class="n">numMonths</span><span class="p">,</span> <span class="n">numDays</span><span class="p">,</span> <span class="n">numHours</span><span class="p">,</span> <span class="n">numMinutes</span><span class="p">,</span>
                <span class="n">numSeconds</span><span class="p">,</span> <span class="n">numMicroseconds</span><span class="p">]</span>

        <span class="n">use_rrule_locator</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="mi">6</span> <span class="o">+</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span>

        <span class="c1"># Default setting of bymonth, etc. to pass to rrule</span>
        <span class="c1"># [unused (for year), bymonth, bymonthday, byhour, byminute,</span>
        <span class="c1">#  bysecond, unused (for microseconds)]</span>
        <span class="n">byranges</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="c1"># Loop over all the frequencies and try to find one that gives at</span>
        <span class="c1"># least a minticks tick positions.  Once this is found, look for</span>
        <span class="c1"># an interval from an list specific to that frequency that gives no</span>
        <span class="c1"># more than maxticks tick positions. Also, set up some ranges</span>
        <span class="c1"># (bymonth, etc.) as appropriate to be passed to rrulewrapper.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_freqs</span><span class="p">,</span> <span class="n">nums</span><span class="p">)):</span>
            <span class="c1"># If this particular frequency doesn&#39;t give enough ticks, continue</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minticks</span><span class="p">:</span>
                <span class="c1"># Since we&#39;re not using this particular frequency, set</span>
                <span class="c1"># the corresponding by_ to None so the rrule can act as</span>
                <span class="c1"># appropriate</span>
                <span class="n">byranges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">continue</span>

            <span class="c1"># Find the first available interval that doesn&#39;t give too many</span>
            <span class="c1"># ticks</span>
            <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervald</span><span class="p">[</span><span class="n">freq</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;=</span> <span class="n">interval</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxticks</span><span class="p">[</span><span class="n">freq</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># We went through the whole loop without breaking, default to</span>
                <span class="c1"># the last interval in the list and raise a warning</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;AutoDateLocator was unable to pick an &#39;</span>
                              <span class="s1">&#39;appropriate interval for this date range. &#39;</span>
                              <span class="s1">&#39;It may be necessary to add an interval value &#39;</span>
                              <span class="s2">&quot;to the AutoDateLocator&#39;s intervald dictionary.&quot;</span>
                              <span class="s1">&#39; Defaulting to </span><span class="si">{0}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">interval</span><span class="p">))</span>

            <span class="c1"># Set some parameters as appropriate</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span> <span class="o">=</span> <span class="n">freq</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_byranges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">interval_multiples</span><span class="p">:</span>
                <span class="n">byranges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_byranges</span><span class="p">[</span><span class="n">i</span><span class="p">][::</span><span class="n">interval</span><span class="p">]</span>
                <span class="n">interval</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">byranges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_byranges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No sensible date limit could be found in the &#39;</span>
                             <span class="s1">&#39;AutoDateLocator.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">freq</span> <span class="o">==</span> <span class="n">YEARLY</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">interval_multiples</span><span class="p">:</span>
            <span class="n">locator</span> <span class="o">=</span> <span class="n">YearLocator</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">use_rrule_locator</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">bymonth</span><span class="p">,</span> <span class="n">bymonthday</span><span class="p">,</span> <span class="n">byhour</span><span class="p">,</span> <span class="n">byminute</span><span class="p">,</span> <span class="n">bysecond</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">byranges</span>
            <span class="n">rrule</span> <span class="o">=</span> <span class="n">rrulewrapper</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">,</span>
                                 <span class="n">dtstart</span><span class="o">=</span><span class="n">dmin</span><span class="p">,</span> <span class="n">until</span><span class="o">=</span><span class="n">dmax</span><span class="p">,</span>
                                 <span class="n">bymonth</span><span class="o">=</span><span class="n">bymonth</span><span class="p">,</span> <span class="n">bymonthday</span><span class="o">=</span><span class="n">bymonthday</span><span class="p">,</span>
                                 <span class="n">byhour</span><span class="o">=</span><span class="n">byhour</span><span class="p">,</span> <span class="n">byminute</span><span class="o">=</span><span class="n">byminute</span><span class="p">,</span>
                                 <span class="n">bysecond</span><span class="o">=</span><span class="n">bysecond</span><span class="p">)</span>

            <span class="n">locator</span> <span class="o">=</span> <span class="n">RRuleLocator</span><span class="p">(</span><span class="n">rrule</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">locator</span> <span class="o">=</span> <span class="n">MicrosecondLocator</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tz</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dmin</span><span class="o">.</span><span class="n">year</span> <span class="o">&gt;</span> <span class="mi">20</span> <span class="ow">and</span> <span class="n">interval</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">:</span>
                <span class="n">_log</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Plotting microsecond time intervals is not&#39;</span>
                          <span class="s1">&#39; well supported. Please see the&#39;</span>
                          <span class="s1">&#39; MicrosecondLocator documentation&#39;</span>
                          <span class="s1">&#39; for details.&#39;</span><span class="p">)</span>

        <span class="n">locator</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">locator</span><span class="o">.</span><span class="n">set_view_interval</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">get_view_interval</span><span class="p">())</span>
            <span class="n">locator</span><span class="o">.</span><span class="n">set_data_interval</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">get_data_interval</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">locator</span></div></div>


<div class="viewcode-block" id="YearLocator"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.YearLocator">[docs]</a><span class="k">class</span> <span class="nc">YearLocator</span><span class="p">(</span><span class="n">DateLocator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make ticks on a given day of each year that is a multiple of base.</span>

<span class="sd">    Examples::</span>

<span class="sd">      # Tick every year on Jan 1st</span>
<span class="sd">      locator = YearLocator()</span>

<span class="sd">      # Tick every 5 years on July 4th</span>
<span class="sd">      locator = YearLocator(5, month=7, day=4)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">month</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mark years that are multiple of base on a given month and day</span>
<span class="sd">        (default jan 1).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">DateLocator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base</span> <span class="o">=</span> <span class="n">ticker</span><span class="o">.</span><span class="n">Base</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replaced</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;month&#39;</span><span class="p">:</span>  <span class="n">month</span><span class="p">,</span>
                         <span class="s1">&#39;day&#39;</span><span class="p">:</span>    <span class="n">day</span><span class="p">,</span>
                         <span class="s1">&#39;hour&#39;</span><span class="p">:</span>   <span class="mi">0</span><span class="p">,</span>
                         <span class="s1">&#39;minute&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                         <span class="s1">&#39;second&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                         <span class="s1">&#39;tzinfo&#39;</span><span class="p">:</span> <span class="n">tz</span>
                         <span class="p">}</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># if no data have been set, this will tank with a ValueError</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">viewlim_to_dt</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tick_values</span><span class="p">(</span><span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span><span class="p">)</span>

<div class="viewcode-block" id="YearLocator.tick_values"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.YearLocator.tick_values">[docs]</a>    <span class="k">def</span> <span class="nf">tick_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">):</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">le</span><span class="p">(</span><span class="n">vmin</span><span class="o">.</span><span class="n">year</span><span class="p">)</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ge</span><span class="p">(</span><span class="n">vmax</span><span class="o">.</span><span class="n">year</span><span class="p">)</span>

        <span class="n">ticks</span> <span class="o">=</span> <span class="p">[</span><span class="n">vmin</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="n">ymin</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">replaced</span><span class="p">)]</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">ticks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dt</span><span class="o">.</span><span class="n">year</span> <span class="o">&gt;=</span> <span class="n">ymax</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">date2num</span><span class="p">(</span><span class="n">ticks</span><span class="p">)</span>
            <span class="n">year</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">year</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">get_base</span><span class="p">()</span>
            <span class="n">ticks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="n">year</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">replaced</span><span class="p">))</span></div>

<div class="viewcode-block" id="YearLocator.autoscale"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.YearLocator.autoscale">[docs]</a>    <span class="k">def</span> <span class="nf">autoscale</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the view limits to include the data range.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">datalim_to_dt</span><span class="p">()</span>

        <span class="n">ymin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">le</span><span class="p">(</span><span class="n">dmin</span><span class="o">.</span><span class="n">year</span><span class="p">)</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">ge</span><span class="p">(</span><span class="n">dmax</span><span class="o">.</span><span class="n">year</span><span class="p">)</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="n">dmin</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="n">ymin</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">replaced</span><span class="p">)</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">dmax</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="n">ymax</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">replaced</span><span class="p">)</span>

        <span class="n">vmin</span> <span class="o">=</span> <span class="n">date2num</span><span class="p">(</span><span class="n">vmin</span><span class="p">)</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">date2num</span><span class="p">(</span><span class="n">vmax</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonsingular</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="MonthLocator"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.MonthLocator">[docs]</a><span class="k">class</span> <span class="nc">MonthLocator</span><span class="p">(</span><span class="n">RRuleLocator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make ticks on occurrences of each month, e.g., 1, 3, 12.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bymonth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bymonthday</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mark every month in *bymonth*; *bymonth* can be an int or</span>
<span class="sd">        sequence.  Default is ``range(1,13)``, i.e. every month.</span>

<span class="sd">        *interval* is the interval between each iteration.  For</span>
<span class="sd">        example, if ``interval=2``, mark every second occurrence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bymonth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bymonth</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bymonth</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="c1"># This fixes a bug in dateutil &lt;= 2.3 which prevents the use of</span>
            <span class="c1"># numpy arrays in (among other things) the bymonthday, byweekday</span>
            <span class="c1"># and bymonth parameters.</span>
            <span class="n">bymonth</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bymonth</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>

        <span class="n">rule</span> <span class="o">=</span> <span class="n">rrulewrapper</span><span class="p">(</span><span class="n">MONTHLY</span><span class="p">,</span> <span class="n">bymonth</span><span class="o">=</span><span class="n">bymonth</span><span class="p">,</span> <span class="n">bymonthday</span><span class="o">=</span><span class="n">bymonthday</span><span class="p">,</span>
                            <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">hms0d</span><span class="p">)</span>
        <span class="n">RRuleLocator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span></div>


<div class="viewcode-block" id="WeekdayLocator"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.WeekdayLocator">[docs]</a><span class="k">class</span> <span class="nc">WeekdayLocator</span><span class="p">(</span><span class="n">RRuleLocator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make ticks on occurrences of each weekday.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">byweekday</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mark every weekday in *byweekday*; *byweekday* can be a number or</span>
<span class="sd">        sequence.</span>

<span class="sd">        Elements of *byweekday* must be one of MO, TU, WE, TH, FR, SA,</span>
<span class="sd">        SU, the constants from :mod:`dateutil.rrule`, which have been</span>
<span class="sd">        imported into the :mod:`matplotlib.dates` namespace.</span>

<span class="sd">        *interval* specifies the number of weeks to skip.  For example,</span>
<span class="sd">        ``interval=2`` plots every second week.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">byweekday</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="c1"># This fixes a bug in dateutil &lt;= 2.3 which prevents the use of</span>
            <span class="c1"># numpy arrays in (among other things) the bymonthday, byweekday</span>
            <span class="c1"># and bymonth parameters.</span>
            <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">byweekday</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>

        <span class="n">rule</span> <span class="o">=</span> <span class="n">rrulewrapper</span><span class="p">(</span><span class="n">DAILY</span><span class="p">,</span> <span class="n">byweekday</span><span class="o">=</span><span class="n">byweekday</span><span class="p">,</span>
                            <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">hms0d</span><span class="p">)</span>
        <span class="n">RRuleLocator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span></div>


<div class="viewcode-block" id="DayLocator"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.DayLocator">[docs]</a><span class="k">class</span> <span class="nc">DayLocator</span><span class="p">(</span><span class="n">RRuleLocator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make ticks on occurrences of each day of the month.  For example,</span>
<span class="sd">    1, 15, 30.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bymonthday</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mark every day in *bymonthday*; *bymonthday* can be an int or</span>
<span class="sd">        sequence.</span>

<span class="sd">        Default is to tick every day of the month: ``bymonthday=range(1,32)``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">interval</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span> <span class="ow">or</span> <span class="n">interval</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;interval must be an integer greater than 0&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bymonthday</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bymonthday</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bymonthday</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="c1"># This fixes a bug in dateutil &lt;= 2.3 which prevents the use of</span>
            <span class="c1"># numpy arrays in (among other things) the bymonthday, byweekday</span>
            <span class="c1"># and bymonth parameters.</span>
            <span class="n">bymonthday</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bymonthday</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>

        <span class="n">rule</span> <span class="o">=</span> <span class="n">rrulewrapper</span><span class="p">(</span><span class="n">DAILY</span><span class="p">,</span> <span class="n">bymonthday</span><span class="o">=</span><span class="n">bymonthday</span><span class="p">,</span>
                            <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">hms0d</span><span class="p">)</span>
        <span class="n">RRuleLocator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span></div>


<div class="viewcode-block" id="HourLocator"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.HourLocator">[docs]</a><span class="k">class</span> <span class="nc">HourLocator</span><span class="p">(</span><span class="n">RRuleLocator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make ticks on occurrences of each hour.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">byhour</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mark every hour in *byhour*; *byhour* can be an int or sequence.</span>
<span class="sd">        Default is to tick every hour: ``byhour=range(24)``</span>

<span class="sd">        *interval* is the interval between each iteration.  For</span>
<span class="sd">        example, if ``interval=2``, mark every second occurrence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">byhour</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">byhour</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>

        <span class="n">rule</span> <span class="o">=</span> <span class="n">rrulewrapper</span><span class="p">(</span><span class="n">HOURLY</span><span class="p">,</span> <span class="n">byhour</span><span class="o">=</span><span class="n">byhour</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">,</span>
                            <span class="n">byminute</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bysecond</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">RRuleLocator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span></div>


<div class="viewcode-block" id="MinuteLocator"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.MinuteLocator">[docs]</a><span class="k">class</span> <span class="nc">MinuteLocator</span><span class="p">(</span><span class="n">RRuleLocator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make ticks on occurrences of each minute.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">byminute</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mark every minute in *byminute*; *byminute* can be an int or</span>
<span class="sd">        sequence.  Default is to tick every minute: ``byminute=range(60)``</span>

<span class="sd">        *interval* is the interval between each iteration.  For</span>
<span class="sd">        example, if ``interval=2``, mark every second occurrence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">byminute</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">byminute</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>

        <span class="n">rule</span> <span class="o">=</span> <span class="n">rrulewrapper</span><span class="p">(</span><span class="n">MINUTELY</span><span class="p">,</span> <span class="n">byminute</span><span class="o">=</span><span class="n">byminute</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">,</span>
                            <span class="n">bysecond</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">RRuleLocator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span></div>


<div class="viewcode-block" id="SecondLocator"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.SecondLocator">[docs]</a><span class="k">class</span> <span class="nc">SecondLocator</span><span class="p">(</span><span class="n">RRuleLocator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make ticks on occurrences of each second.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bysecond</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mark every second in *bysecond*; *bysecond* can be an int or</span>
<span class="sd">        sequence.  Default is to tick every second: ``bysecond = range(60)``</span>

<span class="sd">        *interval* is the interval between each iteration.  For</span>
<span class="sd">        example, if ``interval=2``, mark every second occurrence.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bysecond</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bysecond</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>

        <span class="n">rule</span> <span class="o">=</span> <span class="n">rrulewrapper</span><span class="p">(</span><span class="n">SECONDLY</span><span class="p">,</span> <span class="n">bysecond</span><span class="o">=</span><span class="n">bysecond</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">)</span>
        <span class="n">RRuleLocator</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rule</span><span class="p">,</span> <span class="n">tz</span><span class="p">)</span></div>


<div class="viewcode-block" id="MicrosecondLocator"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.MicrosecondLocator">[docs]</a><span class="k">class</span> <span class="nc">MicrosecondLocator</span><span class="p">(</span><span class="n">DateLocator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make ticks on regular intervals of one or more microsecond(s).</span>

<span class="sd">    .. note::</span>

<span class="sd">        Due to the floating point representation of time in days since</span>
<span class="sd">        0001-01-01 UTC (plus 1), plotting data with microsecond time</span>
<span class="sd">        resolution does not work well with current dates.</span>

<span class="sd">        If you want microsecond resolution time plots, it is strongly</span>
<span class="sd">        recommended to use floating point seconds, not datetime-like</span>
<span class="sd">        time representation.</span>

<span class="sd">        If you really must use datetime.datetime() or similar and still</span>
<span class="sd">        need microsecond precision, your only chance is to use very</span>
<span class="sd">        early years; using year 0001 is recommended.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *interval* is the interval between each iteration.  For</span>
<span class="sd">        example, if ``interval=2``, mark every second microsecond.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_interval</span> <span class="o">=</span> <span class="n">interval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_locator</span> <span class="o">=</span> <span class="n">ticker</span><span class="o">.</span><span class="n">MultipleLocator</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tz</span> <span class="o">=</span> <span class="n">tz</span>

<div class="viewcode-block" id="MicrosecondLocator.set_axis"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.MicrosecondLocator.set_axis">[docs]</a>    <span class="k">def</span> <span class="nf">set_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_locator</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DateLocator</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span></div>

<div class="viewcode-block" id="MicrosecondLocator.set_view_interval"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.MicrosecondLocator.set_view_interval">[docs]</a>    <span class="k">def</span> <span class="nf">set_view_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_locator</span><span class="o">.</span><span class="n">set_view_interval</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DateLocator</span><span class="o">.</span><span class="n">set_view_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span></div>

<div class="viewcode-block" id="MicrosecondLocator.set_data_interval"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.MicrosecondLocator.set_data_interval">[docs]</a>    <span class="k">def</span> <span class="nf">set_data_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_locator</span><span class="o">.</span><span class="n">set_data_interval</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DateLocator</span><span class="o">.</span><span class="n">set_data_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># if no data have been set, this will tank with a ValueError</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">viewlim_to_dt</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tick_values</span><span class="p">(</span><span class="n">dmin</span><span class="p">,</span> <span class="n">dmax</span><span class="p">)</span>

<div class="viewcode-block" id="MicrosecondLocator.tick_values"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.MicrosecondLocator.tick_values">[docs]</a>    <span class="k">def</span> <span class="nf">tick_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">):</span>
        <span class="n">nmin</span><span class="p">,</span> <span class="n">nmax</span> <span class="o">=</span> <span class="n">date2num</span><span class="p">((</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">))</span>
        <span class="n">nmin</span> <span class="o">*=</span> <span class="n">MUSECONDS_PER_DAY</span>
        <span class="n">nmax</span> <span class="o">*=</span> <span class="n">MUSECONDS_PER_DAY</span>
        <span class="n">ticks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped_locator</span><span class="o">.</span><span class="n">tick_values</span><span class="p">(</span><span class="n">nmin</span><span class="p">,</span> <span class="n">nmax</span><span class="p">)</span>
        <span class="n">ticks</span> <span class="o">=</span> <span class="p">[</span><span class="n">tick</span> <span class="o">/</span> <span class="n">MUSECONDS_PER_DAY</span> <span class="k">for</span> <span class="n">tick</span> <span class="ow">in</span> <span class="n">ticks</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ticks</span></div>

    <span class="k">def</span> <span class="nf">_get_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return how many days a unit of the locator is; used for</span>
<span class="sd">        intelligent autoscaling.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">MUSECONDS_PER_DAY</span>

    <span class="k">def</span> <span class="nf">_get_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of units for each tick.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interval</span></div>


<span class="k">def</span> <span class="nf">_close_to_dt</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assert that datetimes *d1* and *d2* are within *epsilon* microseconds.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">d2</span> <span class="o">-</span> <span class="n">d1</span>
    <span class="n">mus</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">delta</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">*</span> <span class="mf">1e6</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">mus</span> <span class="o">&lt;</span> <span class="n">epsilon</span>


<span class="k">def</span> <span class="nf">_close_to_num</span><span class="p">(</span><span class="n">o1</span><span class="p">,</span> <span class="n">o2</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assert that float ordinals *o1* and *o2* are within *epsilon*</span>
<span class="sd">    microseconds.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">((</span><span class="n">o2</span> <span class="o">-</span> <span class="n">o1</span><span class="p">)</span> <span class="o">*</span> <span class="n">MUSECONDS_PER_DAY</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">delta</span> <span class="o">&lt;</span> <span class="n">epsilon</span>


<div class="viewcode-block" id="epoch2num"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.epoch2num">[docs]</a><span class="k">def</span> <span class="nf">epoch2num</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert an epoch or sequence of epochs to the new date format,</span>
<span class="sd">    that is days since 0001.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">EPOCH_OFFSET</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">/</span> <span class="n">SEC_PER_DAY</span></div>


<div class="viewcode-block" id="num2epoch"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.num2epoch">[docs]</a><span class="k">def</span> <span class="nf">num2epoch</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert days since 0001 to epoch.  *d* can be a number or sequence.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">-</span> <span class="n">EPOCH_OFFSET</span><span class="p">)</span> <span class="o">*</span> <span class="n">SEC_PER_DAY</span></div>


<div class="viewcode-block" id="mx2num"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.mx2num">[docs]</a><span class="k">def</span> <span class="nf">mx2num</span><span class="p">(</span><span class="n">mxdates</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert mx :class:`datetime` instance (or sequence of mx</span>
<span class="sd">    instances) to the new date format.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">scalar</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">cbook</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">mxdates</span><span class="p">):</span>
        <span class="n">scalar</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">mxdates</span> <span class="o">=</span> <span class="p">[</span><span class="n">mxdates</span><span class="p">]</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">epoch2num</span><span class="p">([</span><span class="n">m</span><span class="o">.</span><span class="n">ticks</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mxdates</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">scalar</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ret</span></div>


<span class="k">def</span> <span class="nf">date_ticker_factory</span><span class="p">(</span><span class="n">span</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">numticks</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a date locator with *numticks* (approx) and a date formatter</span>
<span class="sd">    for *span* in days.  Return value is (locator, formatter).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">span</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">span</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">HOURS_PER_DAY</span>

    <span class="n">mins</span> <span class="o">=</span> <span class="n">span</span> <span class="o">*</span> <span class="n">MINUTES_PER_DAY</span>
    <span class="n">hrs</span> <span class="o">=</span> <span class="n">span</span> <span class="o">*</span> <span class="n">HOURS_PER_DAY</span>
    <span class="n">days</span> <span class="o">=</span> <span class="n">span</span>
    <span class="n">wks</span> <span class="o">=</span> <span class="n">span</span> <span class="o">/</span> <span class="n">DAYS_PER_WEEK</span>
    <span class="n">months</span> <span class="o">=</span> <span class="n">span</span> <span class="o">/</span> <span class="n">DAYS_PER_MONTH</span>      <span class="c1"># Approx</span>
    <span class="n">years</span> <span class="o">=</span> <span class="n">span</span> <span class="o">/</span> <span class="n">DAYS_PER_YEAR</span>        <span class="c1"># Approx</span>

    <span class="k">if</span> <span class="n">years</span> <span class="o">&gt;</span> <span class="n">numticks</span><span class="p">:</span>
        <span class="n">locator</span> <span class="o">=</span> <span class="n">YearLocator</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">years</span> <span class="o">/</span> <span class="n">numticks</span><span class="p">),</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>  <span class="c1"># define</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;%Y&#39;</span>
    <span class="k">elif</span> <span class="n">months</span> <span class="o">&gt;</span> <span class="n">numticks</span><span class="p">:</span>
        <span class="n">locator</span> <span class="o">=</span> <span class="n">MonthLocator</span><span class="p">(</span><span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;%b %Y&#39;</span>
    <span class="k">elif</span> <span class="n">wks</span> <span class="o">&gt;</span> <span class="n">numticks</span><span class="p">:</span>
        <span class="n">locator</span> <span class="o">=</span> <span class="n">WeekdayLocator</span><span class="p">(</span><span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;%a, %b </span><span class="si">%d</span><span class="s1">&#39;</span>
    <span class="k">elif</span> <span class="n">days</span> <span class="o">&gt;</span> <span class="n">numticks</span><span class="p">:</span>
        <span class="n">locator</span> <span class="o">=</span> <span class="n">DayLocator</span><span class="p">(</span><span class="n">interval</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">days</span> <span class="o">/</span> <span class="n">numticks</span><span class="p">)),</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;%b </span><span class="si">%d</span><span class="s1">&#39;</span>
    <span class="k">elif</span> <span class="n">hrs</span> <span class="o">&gt;</span> <span class="n">numticks</span><span class="p">:</span>
        <span class="n">locator</span> <span class="o">=</span> <span class="n">HourLocator</span><span class="p">(</span><span class="n">interval</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">hrs</span> <span class="o">/</span> <span class="n">numticks</span><span class="p">)),</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;%H:%M</span><span class="se">\n</span><span class="s1">%b </span><span class="si">%d</span><span class="s1">&#39;</span>
    <span class="k">elif</span> <span class="n">mins</span> <span class="o">&gt;</span> <span class="n">numticks</span><span class="p">:</span>
        <span class="n">locator</span> <span class="o">=</span> <span class="n">MinuteLocator</span><span class="p">(</span><span class="n">interval</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">mins</span> <span class="o">/</span> <span class="n">numticks</span><span class="p">)),</span>
                                <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;%H:%M:%S&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">locator</span> <span class="o">=</span> <span class="n">MinuteLocator</span><span class="p">(</span><span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;%H:%M:%S&#39;</span>

    <span class="n">formatter</span> <span class="o">=</span> <span class="n">DateFormatter</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">locator</span><span class="p">,</span> <span class="n">formatter</span>


<div class="viewcode-block" id="seconds"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.seconds">[docs]</a><span class="k">def</span> <span class="nf">seconds</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return seconds as days.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">s</span> <span class="o">/</span> <span class="n">SEC_PER_DAY</span></div>


<div class="viewcode-block" id="minutes"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.minutes">[docs]</a><span class="k">def</span> <span class="nf">minutes</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return minutes as days.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">m</span> <span class="o">/</span> <span class="n">MINUTES_PER_DAY</span></div>


<div class="viewcode-block" id="hours"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.hours">[docs]</a><span class="k">def</span> <span class="nf">hours</span><span class="p">(</span><span class="n">h</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return hours as days.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">h</span> <span class="o">/</span> <span class="n">HOURS_PER_DAY</span></div>


<div class="viewcode-block" id="weeks"><a class="viewcode-back" href="../../api/dates_api.html#matplotlib.dates.weeks">[docs]</a><span class="k">def</span> <span class="nf">weeks</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return weeks as days.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">w</span> <span class="o">*</span> <span class="n">DAYS_PER_WEEK</span></div>


<span class="k">class</span> <span class="nc">DateConverter</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">ConversionInterface</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converter for datetime.date and datetime.datetime data,</span>
<span class="sd">    or for date/time data represented as it would be converted</span>
<span class="sd">    by :func:`date2num`.</span>

<span class="sd">    The &#39;unit&#39; tag for such data is None or a tzinfo instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">axisinfo</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the :class:`~matplotlib.units.AxisInfo` for *unit*.</span>

<span class="sd">        *unit* is a tzinfo instance or None.</span>
<span class="sd">        The *axis* argument is required but not used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tz</span> <span class="o">=</span> <span class="n">unit</span>

        <span class="n">majloc</span> <span class="o">=</span> <span class="n">AutoDateLocator</span><span class="p">(</span><span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
        <span class="n">majfmt</span> <span class="o">=</span> <span class="n">AutoDateFormatter</span><span class="p">(</span><span class="n">majloc</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="n">tz</span><span class="p">)</span>
        <span class="n">datemin</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2000</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">datemax</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2010</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">units</span><span class="o">.</span><span class="n">AxisInfo</span><span class="p">(</span><span class="n">majloc</span><span class="o">=</span><span class="n">majloc</span><span class="p">,</span> <span class="n">majfmt</span><span class="o">=</span><span class="n">majfmt</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                              <span class="n">default_limits</span><span class="o">=</span><span class="p">(</span><span class="n">datemin</span><span class="p">,</span> <span class="n">datemax</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">unit</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If *value* is not already a number or sequence of numbers,</span>
<span class="sd">        convert it with :func:`date2num`.</span>

<span class="sd">        The *unit* and *axis* arguments are not used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">date2num</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">default_units</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the tzinfo instance of *x* or of its first element, or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safe_first_element</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">StopIteration</span><span class="p">):</span>
            <span class="k">pass</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">tzinfo</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="kc">None</span>


<span class="n">units</span><span class="o">.</span><span class="n">registry</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">]</span> <span class="o">=</span> <span class="n">DateConverter</span><span class="p">()</span>
<span class="n">units</span><span class="o">.</span><span class="n">registry</span><span class="p">[</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">]</span> <span class="o">=</span> <span class="n">DateConverter</span><span class="p">()</span>
<span class="n">units</span><span class="o">.</span><span class="n">registry</span><span class="p">[</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">]</span> <span class="o">=</span> <span class="n">DateConverter</span><span class="p">()</span>
</pre></div>

          </div>
        </div>
      </div>

      <div class="clearer"></div>
    </div>
    <div class="footer">
        &copy; Copyright 2002 - 2012 John Hunter, Darren Dale, Eric Firing, Michael Droettboom and the Matplotlib development team; 2012 - 2018 The Matplotlib development team.
        <br />
      Last updated on Aug 11, 2018.
	Created using
	<ahref="http://sphinx-doc.org/">Sphinx</a> 1.7.6.
	Doc version v2.2.3-1-gd47e15e7a.
    </div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-55954603-1', 'auto');
  ga('send', 'pageview');

</script>
</body>
<footer>
</footer>
</html>