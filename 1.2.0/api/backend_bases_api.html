

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>matplotlib.backend_bases &mdash; Matplotlib 1.2.0rc2 documentation</title>
    
    <link rel="stylesheet" href="../_static/mpl.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.2.0rc2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Matplotlib 1.2.0rc2 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="top" title="Matplotlib 1.2.0rc2 documentation" href="../index.html" />
    <link rel="up" title="backends" href="index_backend_api.html" />
    <link rel="next" title="matplotlib.backends.backend_gtkagg" href="backend_gtkagg_api.html" />
    <link rel="prev" title="backends" href="index_backend_api.html" /> 
  </head>
  <body>
<!-- Piwik -->
<script type="text/javascript">
if ("matplotlib.sourceforge.net" == document.location.hostname ||
    "matplotlib.sf.net" == document.location.hostname) {
  var pkBaseURL = (("https:" == document.location.protocol) ? "https://apps.sourceforge.net/piwik/matplotlib/" : "http://apps.sourceforge.net/piwik/matplotlib/");
  document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
}
</script>
<script type="text/javascript">
if ("matplotlib.sourceforge.net" == document.location.hostname ||
    "matplotlib.sf.net" == document.location.hostname) {
  piwik_action_name = '';
  piwik_idsite = 1;
  piwik_url = pkBaseURL + "piwik.php";
  piwik_log(piwik_action_name, piwik_idsite, piwik_url);
  document.write(unescape('%3Cobject%3E%3Cnoscript%3E%3Cp%3E%3Cimg src="http://apps.sourceforge.net/piwik/matplotlib/piwik.php?idsite=1" alt="piwik"/%3E%3C/p%3E%3C/noscript%3E%3C/object%3E'));
}
</script>
<!-- End Piwik Tag -->
<link rel="shortcut icon" href="_static/favicon.ico">

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../index.html"><img src="../_static/logo2.png" border="0" alt="matplotlib"/></a>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="backend_gtkagg_api.html" title="matplotlib.backends.backend_gtkagg"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index_backend_api.html" title="backends"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">home</a>|&nbsp;</li>
        <li><a href="../search.html">search</a>|&nbsp;</li>
        <li><a href="../examples/index.html">examples</a>|&nbsp;</li>
        <li><a href="../gallery.html">gallery</a>|&nbsp;</li>
        <li><a href="../contents.html">docs</a> &raquo;</li>

          <li><a href="index.html" >The Matplotlib API</a> &raquo;</li>
          <li><a href="index_backend_api.html" accesskey="U">backends</a> &raquo;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="index_backend_api.html"
                        title="previous chapter">backends</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="backend_gtkagg_api.html"
                        title="next chapter"><tt class="docutils literal"><span class="pre">matplotlib.backends.backend_gtkagg</span></tt></a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/api/backend_bases_api.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-matplotlib.backend_bases">
<span id="matplotlib-backend-bases"></span><h1><a class="reference internal" href="#module-matplotlib.backend_bases" title="matplotlib.backend_bases"><tt class="xref py py-mod docutils literal"><span class="pre">matplotlib.backend_bases</span></tt></a><a class="headerlink" href="#module-matplotlib.backend_bases" title="Permalink to this headline">¶</a></h1>
<p>Abstract base classes define the primitives that renderers and
graphics contexts must implement to serve as a matplotlib backend</p>
<dl class="docutils">
<dt><a class="reference internal" href="#matplotlib.backend_bases.RendererBase" title="matplotlib.backend_bases.RendererBase"><tt class="xref py py-class docutils literal"><span class="pre">RendererBase</span></tt></a></dt>
<dd>An abstract base class to handle drawing/rendering operations.</dd>
<dt><a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase" title="matplotlib.backend_bases.FigureCanvasBase"><tt class="xref py py-class docutils literal"><span class="pre">FigureCanvasBase</span></tt></a></dt>
<dd>The abstraction layer that separates the
<a class="reference internal" href="figure_api.html#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.figure.Figure</span></tt></a> from the backend specific
details like a user interface drawing area</dd>
<dt><a class="reference internal" href="#matplotlib.backend_bases.GraphicsContextBase" title="matplotlib.backend_bases.GraphicsContextBase"><tt class="xref py py-class docutils literal"><span class="pre">GraphicsContextBase</span></tt></a></dt>
<dd>An abstract base class that provides color, line styles, etc...</dd>
<dt><a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><tt class="xref py py-class docutils literal"><span class="pre">Event</span></tt></a></dt>
<dd>The base class for all of the matplotlib event
handling.  Derived classes suh as <a class="reference internal" href="#matplotlib.backend_bases.KeyEvent" title="matplotlib.backend_bases.KeyEvent"><tt class="xref py py-class docutils literal"><span class="pre">KeyEvent</span></tt></a> and
<a class="reference internal" href="#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><tt class="xref py py-class docutils literal"><span class="pre">MouseEvent</span></tt></a> store the meta data like keys and buttons
pressed, x and y locations in pixel and
<a class="reference internal" href="axes_api.html#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><tt class="xref py py-class docutils literal"><span class="pre">Axes</span></tt></a> coordinates.</dd>
<dt><a class="reference internal" href="#matplotlib.backend_bases.ShowBase" title="matplotlib.backend_bases.ShowBase"><tt class="xref py py-class docutils literal"><span class="pre">ShowBase</span></tt></a></dt>
<dd>The base class for the Show class of each interactive backend;
the &#8216;show&#8217; callable is then set to Show.__call__, inherited from
ShowBase.</dd>
</dl>
<dl class="class">
<dt id="matplotlib.backend_bases.CloseEvent">
<em class="property">class </em><tt class="descclassname">matplotlib.backend_bases.</tt><tt class="descname">CloseEvent</tt><big>(</big><em>name</em>, <em>canvas</em>, <em>guiEvent=None</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.CloseEvent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.backend_bases.Event</span></tt></a></p>
<p>An event triggered by a figure being closed</p>
<p>In addition to the <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><tt class="xref py py-class docutils literal"><span class="pre">Event</span></tt></a> attributes, the following event attributes are defined:</p>
</dd></dl>

<dl class="class">
<dt id="matplotlib.backend_bases.Cursors">
<em class="property">class </em><tt class="descclassname">matplotlib.backend_bases.</tt><tt class="descname">Cursors</tt><a class="headerlink" href="#matplotlib.backend_bases.Cursors" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="matplotlib.backend_bases.Cursors.HAND">
<tt class="descname">HAND</tt><em class="property"> = 0</em><a class="headerlink" href="#matplotlib.backend_bases.Cursors.HAND" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.backend_bases.Cursors.MOVE">
<tt class="descname">MOVE</tt><em class="property"> = 3</em><a class="headerlink" href="#matplotlib.backend_bases.Cursors.MOVE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.backend_bases.Cursors.POINTER">
<tt class="descname">POINTER</tt><em class="property"> = 1</em><a class="headerlink" href="#matplotlib.backend_bases.Cursors.POINTER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.backend_bases.Cursors.SELECT_REGION">
<tt class="descname">SELECT_REGION</tt><em class="property"> = 2</em><a class="headerlink" href="#matplotlib.backend_bases.Cursors.SELECT_REGION" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.backend_bases.DrawEvent">
<em class="property">class </em><tt class="descclassname">matplotlib.backend_bases.</tt><tt class="descname">DrawEvent</tt><big>(</big><em>name</em>, <em>canvas</em>, <em>renderer</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.DrawEvent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.backend_bases.Event</span></tt></a></p>
<p>An event triggered by a draw operation on the canvas</p>
<p>In addition to the <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><tt class="xref py py-class docutils literal"><span class="pre">Event</span></tt></a> attributes, the following event attributes are defined:</p>
<dl class="docutils">
<dt><em>renderer</em></dt>
<dd>the <a class="reference internal" href="#matplotlib.backend_bases.RendererBase" title="matplotlib.backend_bases.RendererBase"><tt class="xref py py-class docutils literal"><span class="pre">RendererBase</span></tt></a> instance for the draw event</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="matplotlib.backend_bases.Event">
<em class="property">class </em><tt class="descclassname">matplotlib.backend_bases.</tt><tt class="descname">Event</tt><big>(</big><em>name</em>, <em>canvas</em>, <em>guiEvent=None</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.Event" title="Permalink to this definition">¶</a></dt>
<dd><p>A matplotlib event.  Attach additional attributes as defined in
<a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase.mpl_connect" title="matplotlib.backend_bases.FigureCanvasBase.mpl_connect"><tt class="xref py py-meth docutils literal"><span class="pre">FigureCanvasBase.mpl_connect()</span></tt></a>.  The following attributes
are defined and shown with their default values</p>
<dl class="docutils">
<dt><em>name</em></dt>
<dd>the event name</dd>
<dt><em>canvas</em></dt>
<dd>the FigureCanvas instance generating the event</dd>
<dt><em>guiEvent</em></dt>
<dd>the GUI event that triggered the matplotlib event</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="matplotlib.backend_bases.FigureCanvasBase">
<em class="property">class </em><tt class="descclassname">matplotlib.backend_bases.</tt><tt class="descname">FigureCanvasBase</tt><big>(</big><em>figure</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>The canvas the figure renders into.</p>
<p>Public attributes</p>
<blockquote>
<div><dl class="docutils">
<dt><em>figure</em></dt>
<dd>A <a class="reference internal" href="figure_api.html#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.figure.Figure</span></tt></a> instance</dd>
</dl>
</div></blockquote>
<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.blit">
<tt class="descname">blit</tt><big>(</big><em>bbox=None</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.blit" title="Permalink to this definition">¶</a></dt>
<dd><p>blit the canvas in bbox (default entire canvas)</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.button_press_event">
<tt class="descname">button_press_event</tt><big>(</big><em>x</em>, <em>y</em>, <em>button</em>, <em>dblclick=False</em>, <em>guiEvent=None</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.button_press_event" title="Permalink to this definition">¶</a></dt>
<dd><p>Backend derived classes should call this function on any mouse
button press.  x,y are the canvas coords: 0,0 is lower, left.
button and key are as defined in <a class="reference internal" href="#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><tt class="xref py py-class docutils literal"><span class="pre">MouseEvent</span></tt></a>.</p>
<p>This method will be call all functions connected to the
&#8216;button_press_event&#8217; with a <a class="reference internal" href="#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><tt class="xref py py-class docutils literal"><span class="pre">MouseEvent</span></tt></a> instance.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.button_release_event">
<tt class="descname">button_release_event</tt><big>(</big><em>x</em>, <em>y</em>, <em>button</em>, <em>guiEvent=None</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.button_release_event" title="Permalink to this definition">¶</a></dt>
<dd><p>Backend derived classes should call this function on any mouse
button release.</p>
<dl class="docutils">
<dt><em>x</em></dt>
<dd>the canvas coordinates where 0=left</dd>
<dt><em>y</em></dt>
<dd>the canvas coordinates where 0=bottom</dd>
<dt><em>guiEvent</em></dt>
<dd>the native UI event that generated the mpl event</dd>
</dl>
<p>This method will be call all functions connected to the
&#8216;button_release_event&#8217; with a <a class="reference internal" href="#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><tt class="xref py py-class docutils literal"><span class="pre">MouseEvent</span></tt></a> instance.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.close_event">
<tt class="descname">close_event</tt><big>(</big><em>guiEvent=None</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.close_event" title="Permalink to this definition">¶</a></dt>
<dd><p>This method will be called by all functions connected to the
&#8216;close_event&#8217; with a <a class="reference internal" href="#matplotlib.backend_bases.CloseEvent" title="matplotlib.backend_bases.CloseEvent"><tt class="xref py py-class docutils literal"><span class="pre">CloseEvent</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.draw">
<tt class="descname">draw</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Render the <a class="reference internal" href="figure_api.html#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><tt class="xref py py-class docutils literal"><span class="pre">Figure</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.draw_cursor">
<tt class="descname">draw_cursor</tt><big>(</big><em>event</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.draw_cursor" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a cursor in the event.axes if inaxes is not None.  Use
native GUI drawing for efficiency if possible</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.draw_event">
<tt class="descname">draw_event</tt><big>(</big><em>renderer</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.draw_event" title="Permalink to this definition">¶</a></dt>
<dd><p>This method will be call all functions connected to the
&#8216;draw_event&#8217; with a <a class="reference internal" href="#matplotlib.backend_bases.DrawEvent" title="matplotlib.backend_bases.DrawEvent"><tt class="xref py py-class docutils literal"><span class="pre">DrawEvent</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.draw_idle">
<tt class="descname">draw_idle</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.draw_idle" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase.draw" title="matplotlib.backend_bases.FigureCanvasBase.draw"><tt class="xref py py-meth docutils literal"><span class="pre">draw()</span></tt></a> only if idle; defaults to draw but backends can overrride</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.enter_notify_event">
<tt class="descname">enter_notify_event</tt><big>(</big><em>guiEvent=None</em>, <em>xy=None</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.enter_notify_event" title="Permalink to this definition">¶</a></dt>
<dd><p>Backend derived classes should call this function when entering
canvas</p>
<dl class="docutils">
<dt><em>guiEvent</em></dt>
<dd>the native UI event that generated the mpl event</dd>
<dt><em>xy</em></dt>
<dd>the coordinate location of the pointer when the canvas is
entered</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.backend_bases.FigureCanvasBase.events">
<tt class="descname">events</tt><em class="property"> = ['resize_event', 'draw_event', 'key_press_event', 'key_release_event', 'button_press_event', 'button_release_event', 'scroll_event', 'motion_notify_event', 'pick_event', 'idle_event', 'figure_enter_event', 'figure_leave_event', 'axes_enter_event', 'axes_leave_event', 'close_event']</em><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.events" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.backend_bases.FigureCanvasBase.filetypes">
<tt class="descname">filetypes</tt><em class="property"> = {'pgf': 'LaTeX PGF Figure', 'svgz': 'Scalable Vector Graphics', 'tiff': 'Tagged Image File Format', 'jpg': 'Joint Photographic Experts Group', 'raw': 'Raw RGBA bitmap', 'jpeg': 'Joint Photographic Experts Group', 'png': 'Portable Network Graphics', 'ps': 'Postscript', 'emf': 'Enhanced Metafile', 'svg': 'Scalable Vector Graphics', 'eps': 'Encapsulated Postscript', 'rgba': 'Raw RGBA bitmap', 'pdf': 'Portable Document Format', 'tif': 'Tagged Image File Format'}</em><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.filetypes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.flush_events">
<tt class="descname">flush_events</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.flush_events" title="Permalink to this definition">¶</a></dt>
<dd><p>Flush the GUI events for the figure. Implemented only for
backends with GUIs.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.get_default_filename">
<tt class="descname">get_default_filename</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.get_default_filename" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a string, which includes extension, suitable for use as
a default filename.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.get_default_filetype">
<tt class="descname">get_default_filetype</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.get_default_filetype" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the default savefig file format as specified in rcParam
<tt class="docutils literal"><span class="pre">savefig.format</span></tt>. Returned string excludes period. Overridden
in backends that only support a single file type.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.get_supported_filetypes">
<tt class="descname">get_supported_filetypes</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.get_supported_filetypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return dict of savefig file formats supported by this backend</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.get_supported_filetypes_grouped">
<tt class="descname">get_supported_filetypes_grouped</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.get_supported_filetypes_grouped" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dict of savefig file formats supported by this backend,
where the keys are a file type name, such as &#8216;Joint Photographic
Experts Group&#8217;, and the values are a list of filename extensions used
for that filetype, such as [&#8216;jpg&#8217;, &#8216;jpeg&#8217;].</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.get_width_height">
<tt class="descname">get_width_height</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.get_width_height" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the figure width and height in points or pixels
(depending on the backend), truncated to integers</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.get_window_title">
<tt class="descname">get_window_title</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.get_window_title" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the title text of the window containing the figure.
Return None if there is no window (eg, a PS backend).</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.grab_mouse">
<tt class="descname">grab_mouse</tt><big>(</big><em>ax</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.grab_mouse" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the child axes which are currently grabbing the mouse events.
Usually called by the widgets themselves.
It is an error to call this if the mouse is already grabbed by
another axes.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.idle_event">
<tt class="descname">idle_event</tt><big>(</big><em>guiEvent=None</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.idle_event" title="Permalink to this definition">¶</a></dt>
<dd><p>Called when GUI is idle.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.key_press_event">
<tt class="descname">key_press_event</tt><big>(</big><em>key</em>, <em>guiEvent=None</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.key_press_event" title="Permalink to this definition">¶</a></dt>
<dd><p>This method will be call all functions connected to the
&#8216;key_press_event&#8217; with a <a class="reference internal" href="#matplotlib.backend_bases.KeyEvent" title="matplotlib.backend_bases.KeyEvent"><tt class="xref py py-class docutils literal"><span class="pre">KeyEvent</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.key_release_event">
<tt class="descname">key_release_event</tt><big>(</big><em>key</em>, <em>guiEvent=None</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.key_release_event" title="Permalink to this definition">¶</a></dt>
<dd><p>This method will be call all functions connected to the
&#8216;key_release_event&#8217; with a <a class="reference internal" href="#matplotlib.backend_bases.KeyEvent" title="matplotlib.backend_bases.KeyEvent"><tt class="xref py py-class docutils literal"><span class="pre">KeyEvent</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.leave_notify_event">
<tt class="descname">leave_notify_event</tt><big>(</big><em>guiEvent=None</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.leave_notify_event" title="Permalink to this definition">¶</a></dt>
<dd><p>Backend derived classes should call this function when leaving
canvas</p>
<dl class="docutils">
<dt><em>guiEvent</em></dt>
<dd>the native UI event that generated the mpl event</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.motion_notify_event">
<tt class="descname">motion_notify_event</tt><big>(</big><em>x</em>, <em>y</em>, <em>guiEvent=None</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.motion_notify_event" title="Permalink to this definition">¶</a></dt>
<dd><p>Backend derived classes should call this function on any
motion-notify-event.</p>
<dl class="docutils">
<dt><em>x</em></dt>
<dd>the canvas coordinates where 0=left</dd>
<dt><em>y</em></dt>
<dd>the canvas coordinates where 0=bottom</dd>
<dt><em>guiEvent</em></dt>
<dd>the native UI event that generated the mpl event</dd>
</dl>
<p>This method will be call all functions connected to the
&#8216;motion_notify_event&#8217; with a <a class="reference internal" href="#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><tt class="xref py py-class docutils literal"><span class="pre">MouseEvent</span></tt></a> instance.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.mpl_connect">
<tt class="descname">mpl_connect</tt><big>(</big><em>s</em>, <em>func</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.mpl_connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Connect event with string <em>s</em> to <em>func</em>.  The signature of <em>func</em> is:</p>
<div class="highlight-python"><pre>def func(event)</pre>
</div>
<p>where event is a <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.backend_bases.Event</span></tt></a>.  The
following events are recognized</p>
<ul class="simple">
<li>&#8216;button_press_event&#8217;</li>
<li>&#8216;button_release_event&#8217;</li>
<li>&#8216;draw_event&#8217;</li>
<li>&#8216;key_press_event&#8217;</li>
<li>&#8216;key_release_event&#8217;</li>
<li>&#8216;motion_notify_event&#8217;</li>
<li>&#8216;pick_event&#8217;</li>
<li>&#8216;resize_event&#8217;</li>
<li>&#8216;scroll_event&#8217;</li>
<li>&#8216;figure_enter_event&#8217;,</li>
<li>&#8216;figure_leave_event&#8217;,</li>
<li>&#8216;axes_enter_event&#8217;,</li>
<li>&#8216;axes_leave_event&#8217;</li>
<li>&#8216;close_event&#8217;</li>
</ul>
<p>For the location events (button and key press/release), if the
mouse is over the axes, the variable <tt class="docutils literal"><span class="pre">event.inaxes</span></tt> will be
set to the <a class="reference internal" href="axes_api.html#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><tt class="xref py py-class docutils literal"><span class="pre">Axes</span></tt></a> the event occurs is
over, and additionally, the variables <tt class="docutils literal"><span class="pre">event.xdata</span></tt> and
<tt class="docutils literal"><span class="pre">event.ydata</span></tt> will be defined.  This is the mouse location
in data coords.  See
<a class="reference internal" href="#matplotlib.backend_bases.KeyEvent" title="matplotlib.backend_bases.KeyEvent"><tt class="xref py py-class docutils literal"><span class="pre">KeyEvent</span></tt></a> and
<a class="reference internal" href="#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><tt class="xref py py-class docutils literal"><span class="pre">MouseEvent</span></tt></a> for more info.</p>
<p>Return value is a connection id that can be used with
<tt class="xref py py-meth docutils literal"><span class="pre">mpl_disconnect()</span></tt>.</p>
<p>Example usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">on_press</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;you pressed&#39;</span><span class="p">,</span> <span class="n">event</span><span class="o">.</span><span class="n">button</span><span class="p">,</span> <span class="n">event</span><span class="o">.</span><span class="n">xdata</span><span class="p">,</span> <span class="n">event</span><span class="o">.</span><span class="n">ydata</span><span class="p">)</span>

<span class="n">cid</span> <span class="o">=</span> <span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s">&#39;button_press_event&#39;</span><span class="p">,</span> <span class="n">on_press</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.mpl_disconnect">
<tt class="descname">mpl_disconnect</tt><big>(</big><em>cid</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.mpl_disconnect" title="Permalink to this definition">¶</a></dt>
<dd><p>Disconnect callback id cid</p>
<p>Example usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">cid</span> <span class="o">=</span> <span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s">&#39;button_press_event&#39;</span><span class="p">,</span> <span class="n">on_press</span><span class="p">)</span>
<span class="c">#...later</span>
<span class="n">canvas</span><span class="o">.</span><span class="n">mpl_disconnect</span><span class="p">(</span><span class="n">cid</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.new_timer">
<tt class="descname">new_timer</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.new_timer" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new backend-specific subclass of <tt class="xref py py-class docutils literal"><span class="pre">backend_bases.Timer</span></tt>.
This is useful for getting periodic events through the backend&#8217;s native
event loop. Implemented only for backends with GUIs.</p>
<p>optional arguments:</p>
<dl class="docutils">
<dt><em>interval</em></dt>
<dd>Timer interval in milliseconds</dd>
<dt><em>callbacks</em></dt>
<dd>Sequence of (func, args, kwargs) where func(<em>args, **kwargs) will
be executed by the timer every *interval</em>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.onHilite">
<tt class="descname">onHilite</tt><big>(</big><em>ev</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.onHilite" title="Permalink to this definition">¶</a></dt>
<dd><p>Mouse event processor which highlights the artists
under the cursor.  Connect this to the &#8216;motion_notify_event&#8217;
using:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s">&#39;motion_notify_event&#39;</span><span class="p">,</span><span class="n">canvas</span><span class="o">.</span><span class="n">onHilite</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.onRemove">
<tt class="descname">onRemove</tt><big>(</big><em>ev</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.onRemove" title="Permalink to this definition">¶</a></dt>
<dd><p>Mouse event processor which removes the top artist
under the cursor.  Connect this to the &#8216;mouse_press_event&#8217;
using:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s">&#39;mouse_press_event&#39;</span><span class="p">,</span><span class="n">canvas</span><span class="o">.</span><span class="n">onRemove</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.pick">
<tt class="descname">pick</tt><big>(</big><em>mouseevent</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.pick" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.pick_event">
<tt class="descname">pick_event</tt><big>(</big><em>mouseevent</em>, <em>artist</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.pick_event" title="Permalink to this definition">¶</a></dt>
<dd><p>This method will be called by artists who are picked and will
fire off <a class="reference internal" href="#matplotlib.backend_bases.PickEvent" title="matplotlib.backend_bases.PickEvent"><tt class="xref py py-class docutils literal"><span class="pre">PickEvent</span></tt></a> callbacks registered listeners</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.print_bmp">
<tt class="descname">print_bmp</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.print_bmp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.print_emf">
<tt class="descname">print_emf</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.print_emf" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.print_eps">
<tt class="descname">print_eps</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.print_eps" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.print_figure">
<tt class="descname">print_figure</tt><big>(</big><em>filename</em>, <em>dpi=None</em>, <em>facecolor='w'</em>, <em>edgecolor='w'</em>, <em>orientation='portrait'</em>, <em>format=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.print_figure" title="Permalink to this definition">¶</a></dt>
<dd><p>Render the figure to hardcopy. Set the figure patch face and edge
colors.  This is useful because some of the GUIs have a gray figure
face color background and you&#8217;ll probably want to override this on
hardcopy.</p>
<p>Arguments are:</p>
<dl class="docutils">
<dt><em>filename</em></dt>
<dd>can also be a file object on image backends</dd>
<dt><em>orientation</em></dt>
<dd>only currently applies to PostScript printing.</dd>
<dt><em>dpi</em></dt>
<dd>the dots per inch to save the figure in; if None, use savefig.dpi</dd>
<dt><em>facecolor</em></dt>
<dd>the facecolor of the figure</dd>
<dt><em>edgecolor</em></dt>
<dd>the edgecolor of the figure</dd>
<dt><em>orientation</em></dt>
<dd>landscape&#8217; | &#8216;portrait&#8217; (not supported on all backends)</dd>
<dt><em>format</em></dt>
<dd>when set, forcibly set the file format to save to</dd>
<dt><em>bbox_inches</em></dt>
<dd>Bbox in inches. Only the given portion of the figure is
saved. If &#8216;tight&#8217;, try to figure out the tight bbox of
the figure. If None, use savefig.bbox</dd>
<dt><em>pad_inches</em></dt>
<dd>Amount of padding around the figure when bbox_inches is
&#8216;tight&#8217;. If None, use savefig.pad_inches</dd>
<dt><em>bbox_extra_artists</em></dt>
<dd>A list of extra artists that will be considered when the
tight bbox is calculated.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.print_jpeg">
<tt class="descname">print_jpeg</tt><big>(</big><em>filename_or_obj</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.print_jpeg" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported kwargs:</p>
<dl class="docutils">
<dt><em>quality</em>: The image quality, on a scale from 1 (worst) to</dt>
<dd>95 (best). The default is 75. Values above 95 should
be avoided; 100 completely disables the JPEG
quantization stage.</dd>
<dt><em>optimize</em>: If present, indicates that the encoder should</dt>
<dd>make an extra pass over the image in order to select
optimal encoder settings.</dd>
<dt><em>progressive</em>: If present, indicates that this image</dt>
<dd>should be stored as a progressive JPEG file.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.print_jpg">
<tt class="descname">print_jpg</tt><big>(</big><em>filename_or_obj</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.print_jpg" title="Permalink to this definition">¶</a></dt>
<dd><p>Supported kwargs:</p>
<dl class="docutils">
<dt><em>quality</em>: The image quality, on a scale from 1 (worst) to</dt>
<dd>95 (best). The default is 75. Values above 95 should
be avoided; 100 completely disables the JPEG
quantization stage.</dd>
<dt><em>optimize</em>: If present, indicates that the encoder should</dt>
<dd>make an extra pass over the image in order to select
optimal encoder settings.</dd>
<dt><em>progressive</em>: If present, indicates that this image</dt>
<dd>should be stored as a progressive JPEG file.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.print_pdf">
<tt class="descname">print_pdf</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.print_pdf" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.print_pgf">
<tt class="descname">print_pgf</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.print_pgf" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.print_png">
<tt class="descname">print_png</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.print_png" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.print_ps">
<tt class="descname">print_ps</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.print_ps" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.print_raw">
<tt class="descname">print_raw</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.print_raw" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.print_rgb">
<tt class="descname">print_rgb</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.print_rgb" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.print_svg">
<tt class="descname">print_svg</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.print_svg" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.print_svgz">
<tt class="descname">print_svgz</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.print_svgz" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.print_tif">
<tt class="descname">print_tif</tt><big>(</big><em>filename_or_obj</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.print_tif" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.print_tiff">
<tt class="descname">print_tiff</tt><big>(</big><em>filename_or_obj</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.print_tiff" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.release_mouse">
<tt class="descname">release_mouse</tt><big>(</big><em>ax</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.release_mouse" title="Permalink to this definition">¶</a></dt>
<dd><p>Release the mouse grab held by the axes, ax.
Usually called by the widgets.
It is ok to call this even if you ax doesn&#8217;t have the mouse grab currently.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.resize">
<tt class="descname">resize</tt><big>(</big><em>w</em>, <em>h</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.resize" title="Permalink to this definition">¶</a></dt>
<dd><p>set the canvas size in pixels</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.resize_event">
<tt class="descname">resize_event</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.resize_event" title="Permalink to this definition">¶</a></dt>
<dd><p>This method will be call all functions connected to the
&#8216;resize_event&#8217; with a <a class="reference internal" href="#matplotlib.backend_bases.ResizeEvent" title="matplotlib.backend_bases.ResizeEvent"><tt class="xref py py-class docutils literal"><span class="pre">ResizeEvent</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.scroll_event">
<tt class="descname">scroll_event</tt><big>(</big><em>x</em>, <em>y</em>, <em>step</em>, <em>guiEvent=None</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.scroll_event" title="Permalink to this definition">¶</a></dt>
<dd><p>Backend derived classes should call this function on any
scroll wheel event.  x,y are the canvas coords: 0,0 is lower,
left.  button and key are as defined in MouseEvent.</p>
<p>This method will be call all functions connected to the
&#8216;scroll_event&#8217; with a <a class="reference internal" href="#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><tt class="xref py py-class docutils literal"><span class="pre">MouseEvent</span></tt></a> instance.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.set_window_title">
<tt class="descname">set_window_title</tt><big>(</big><em>title</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.set_window_title" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the title text of the window containing the figure.  Note that
this has no effect if there is no window (eg, a PS backend).</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.start_event_loop">
<tt class="descname">start_event_loop</tt><big>(</big><em>timeout</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.start_event_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Start an event loop.  This is used to start a blocking event
loop so that interactive functions, such as ginput and
waitforbuttonpress, can wait for events.  This should not be
confused with the main GUI event loop, which is always running
and has nothing to do with this.</p>
<p>This is implemented only for backends with GUIs.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.start_event_loop_default">
<tt class="descname">start_event_loop_default</tt><big>(</big><em>timeout=0</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.start_event_loop_default" title="Permalink to this definition">¶</a></dt>
<dd><p>Start an event loop.  This is used to start a blocking event
loop so that interactive functions, such as ginput and
waitforbuttonpress, can wait for events.  This should not be
confused with the main GUI event loop, which is always running
and has nothing to do with this.</p>
<p>This function provides default event loop functionality based
on time.sleep that is meant to be used until event loop
functions for each of the GUI backends can be written.  As
such, it throws a deprecated warning.</p>
<p>Call signature:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">start_event_loop_default</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">timeout</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>This call blocks until a callback function triggers
stop_event_loop() or <em>timeout</em> is reached.  If <em>timeout</em> is
&lt;=0, never timeout.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.stop_event_loop">
<tt class="descname">stop_event_loop</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.stop_event_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop an event loop.  This is used to stop a blocking event
loop so that interactive functions, such as ginput and
waitforbuttonpress, can wait for events.</p>
<p>This is implemented only for backends with GUIs.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.stop_event_loop_default">
<tt class="descname">stop_event_loop_default</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.stop_event_loop_default" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop an event loop.  This is used to stop a blocking event
loop so that interactive functions, such as ginput and
waitforbuttonpress, can wait for events.</p>
<p>Call signature:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">stop_event_loop_default</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureCanvasBase.switch_backends">
<tt class="descname">switch_backends</tt><big>(</big><em>FigureCanvasClass</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureCanvasBase.switch_backends" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiate an instance of FigureCanvasClass</p>
<p>This is used for backend switching, eg, to instantiate a
FigureCanvasPS from a FigureCanvasGTK.  Note, deep copying is
not done, so any changes to one of the instances (eg, setting
figure size or line props), will be reflected in the other</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.backend_bases.FigureManagerBase">
<em class="property">class </em><tt class="descclassname">matplotlib.backend_bases.</tt><tt class="descname">FigureManagerBase</tt><big>(</big><em>canvas</em>, <em>num</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureManagerBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper class for pyplot mode, wraps everything up into a neat bundle</p>
<p>Public attibutes:</p>
<dl class="docutils">
<dt><em>canvas</em></dt>
<dd>A <a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase" title="matplotlib.backend_bases.FigureCanvasBase"><tt class="xref py py-class docutils literal"><span class="pre">FigureCanvasBase</span></tt></a> instance</dd>
<dt><em>num</em></dt>
<dd>The figure number</dd>
</dl>
<dl class="method">
<dt id="matplotlib.backend_bases.FigureManagerBase.destroy">
<tt class="descname">destroy</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureManagerBase.destroy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureManagerBase.full_screen_toggle">
<tt class="descname">full_screen_toggle</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureManagerBase.full_screen_toggle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureManagerBase.get_window_title">
<tt class="descname">get_window_title</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureManagerBase.get_window_title" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the title text of the window containing the figure.
Return None for non-GUI backends (eg, a PS backend).</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureManagerBase.key_press">
<tt class="descname">key_press</tt><big>(</big><em>event</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureManagerBase.key_press" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the default mpl key bindings defined at
<a class="reference internal" href="../users/navigation_toolbar.html#key-event-handling"><em>Navigation Keyboard Shortcuts</em></a></p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.backend_bases.FigureManagerBase.key_press_handler_id">
<tt class="descname">key_press_handler_id</tt><em class="property"> = None</em><a class="headerlink" href="#matplotlib.backend_bases.FigureManagerBase.key_press_handler_id" title="Permalink to this definition">¶</a></dt>
<dd><p>The returned id from connecting the default key handler via <tt class="xref py py-meth docutils literal"><span class="pre">FigureCanvasBase.mpl_connnect()</span></tt>.</p>
<p>To disable default key press handling:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">manager</span><span class="p">,</span> <span class="n">canvas</span> <span class="o">=</span> <span class="n">figure</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">manager</span><span class="p">,</span> <span class="n">figure</span><span class="o">.</span><span class="n">canvas</span>
<span class="n">canvas</span><span class="o">.</span><span class="n">mpl_disconnect</span><span class="p">(</span><span class="n">manager</span><span class="o">.</span><span class="n">key_press_handler_id</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureManagerBase.resize">
<tt class="descname">resize</tt><big>(</big><em>w</em>, <em>h</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureManagerBase.resize" title="Permalink to this definition">¶</a></dt>
<dd><p>&#8220;For gui backends, resize the window (in pixels).</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureManagerBase.set_window_title">
<tt class="descname">set_window_title</tt><big>(</big><em>title</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureManagerBase.set_window_title" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the title text of the window containing the figure.  Note that
this has no effect for non-GUI backends (eg, a PS backend).</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureManagerBase.show">
<tt class="descname">show</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureManagerBase.show" title="Permalink to this definition">¶</a></dt>
<dd><p>For GUI backends, show the figure window and redraw.
For non-GUI backends, raise an exception to be caught
by <a class="reference internal" href="figure_api.html#matplotlib.figure.Figure.show" title="matplotlib.figure.Figure.show"><tt class="xref py py-meth docutils literal"><span class="pre">show()</span></tt></a>, for an
optional warning.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.FigureManagerBase.show_popup">
<tt class="descname">show_popup</tt><big>(</big><em>msg</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.FigureManagerBase.show_popup" title="Permalink to this definition">¶</a></dt>
<dd><p>Display message in a popup &#8211; GUI only</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.backend_bases.GraphicsContextBase">
<em class="property">class </em><tt class="descclassname">matplotlib.backend_bases.</tt><tt class="descname">GraphicsContextBase</tt><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract base class that provides color, line styles, etc...</p>
<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.copy_properties">
<tt class="descname">copy_properties</tt><big>(</big><em>gc</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.copy_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy properties from gc to self</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.backend_bases.GraphicsContextBase.dashd">
<tt class="descname">dashd</tt><em class="property"> = {'solid': (None, None), 'dashed': (0, (6.0, 6.0)), 'dotted': (0, (1.0, 3.0)), 'dashdot': (0, (3.0, 5.0, 1.0, 5.0))}</em><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.dashd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.get_alpha">
<tt class="descname">get_alpha</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.get_alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the alpha value used for blending - not supported on
all backends</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.get_antialiased">
<tt class="descname">get_antialiased</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.get_antialiased" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if the object should try to do antialiased rendering</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.get_capstyle">
<tt class="descname">get_capstyle</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.get_capstyle" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the capstyle as a string in (&#8216;butt&#8217;, &#8216;round&#8217;, &#8216;projecting&#8217;)</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.get_clip_path">
<tt class="descname">get_clip_path</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.get_clip_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the clip path in the form (path, transform), where path
is a <a class="reference internal" href="path_api.html#matplotlib.path.Path" title="matplotlib.path.Path"><tt class="xref py py-class docutils literal"><span class="pre">Path</span></tt></a> instance, and transform is
an affine transform to apply to the path before clipping.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.get_clip_rectangle">
<tt class="descname">get_clip_rectangle</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.get_clip_rectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the clip rectangle as a <a class="reference internal" href="../devel/transformations.html#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><tt class="xref py py-class docutils literal"><span class="pre">Bbox</span></tt></a> instance</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.get_dashes">
<tt class="descname">get_dashes</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.get_dashes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dash information as an offset dashlist tuple.</p>
<p>The dash list is a even size list that gives the ink on, ink
off in pixels.</p>
<p>See p107 of to PostScript <a class="reference external" href="http://www-cdf.fnal.gov/offline/PostScript/BLUEBOOK.PDF">BLUEBOOK</a>
for more info.</p>
<p>Default value is None</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.get_gid">
<tt class="descname">get_gid</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.get_gid" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the object identifier if one is set, None otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.get_hatch">
<tt class="descname">get_hatch</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.get_hatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the current hatch style</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.get_hatch_path">
<tt class="descname">get_hatch_path</tt><big>(</big><em>density=6.0</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.get_hatch_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Path for the current hatch.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.get_joinstyle">
<tt class="descname">get_joinstyle</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.get_joinstyle" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the line join style as one of (&#8216;miter&#8217;, &#8216;round&#8217;, &#8216;bevel&#8217;)</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.get_linestyle">
<tt class="descname">get_linestyle</tt><big>(</big><em>style</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.get_linestyle" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the linestyle: one of (&#8216;solid&#8217;, &#8216;dashed&#8217;, &#8216;dashdot&#8217;,
&#8216;dotted&#8217;).</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.get_linewidth">
<tt class="descname">get_linewidth</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.get_linewidth" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the line width in points as a scalar</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.get_rgb">
<tt class="descname">get_rgb</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.get_rgb" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a tuple of three or four floats from 0-1.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.get_snap">
<tt class="descname">get_snap</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.get_snap" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the snap setting which may be:</p>
<ul class="simple">
<li>True: snap vertices to the nearest pixel center</li>
<li>False: leave vertices as-is</li>
<li>None: (auto) If the path contains only rectilinear line
segments, round to the nearest pixel center</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.get_url">
<tt class="descname">get_url</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.get_url" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a url if one is set, None otherwise</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.restore">
<tt class="descname">restore</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.restore" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore the graphics context from the stack - needed only
for backends that save graphics contexts on a stack</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.set_alpha">
<tt class="descname">set_alpha</tt><big>(</big><em>alpha</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.set_alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the alpha value used for blending - not supported on
all backends</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.set_antialiased">
<tt class="descname">set_antialiased</tt><big>(</big><em>b</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.set_antialiased" title="Permalink to this definition">¶</a></dt>
<dd><p>True if object should be drawn with antialiased rendering</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.set_capstyle">
<tt class="descname">set_capstyle</tt><big>(</big><em>cs</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.set_capstyle" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the capstyle as a string in (&#8216;butt&#8217;, &#8216;round&#8217;, &#8216;projecting&#8217;)</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.set_clip_path">
<tt class="descname">set_clip_path</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.set_clip_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the clip path and transformation.  Path should be a
<a class="reference internal" href="../devel/transformations.html#matplotlib.transforms.TransformedPath" title="matplotlib.transforms.TransformedPath"><tt class="xref py py-class docutils literal"><span class="pre">TransformedPath</span></tt></a> instance.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.set_clip_rectangle">
<tt class="descname">set_clip_rectangle</tt><big>(</big><em>rectangle</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.set_clip_rectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the clip rectangle with sequence (left, bottom, width, height)</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.set_dashes">
<tt class="descname">set_dashes</tt><big>(</big><em>dash_offset</em>, <em>dash_list</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.set_dashes" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the dash style for the gc.</p>
<dl class="docutils">
<dt><em>dash_offset</em></dt>
<dd>is the offset (usually 0).</dd>
<dt><em>dash_list</em></dt>
<dd>specifies the on-off sequence as points.  <tt class="docutils literal"><span class="pre">(None,</span> <span class="pre">None)</span></tt> specifies a solid line</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.set_foreground">
<tt class="descname">set_foreground</tt><big>(</big><em>fg</em>, <em>isRGB=False</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.set_foreground" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the foreground color.  fg can be a MATLAB format string, a
html hex color string, an rgb or rgba unit tuple, or a float between 0
and 1.  In the latter case, grayscale is used.</p>
<p>If you know fg is rgb or rgba, set <tt class="docutils literal"><span class="pre">isRGB=True</span></tt> for
efficiency.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.set_gid">
<tt class="descname">set_gid</tt><big>(</big><em>id</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.set_gid" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the id.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.set_graylevel">
<tt class="descname">set_graylevel</tt><big>(</big><em>frac</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.set_graylevel" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the foreground color to be a gray level with <em>frac</em></p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.set_hatch">
<tt class="descname">set_hatch</tt><big>(</big><em>hatch</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.set_hatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the hatch style for filling</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.set_joinstyle">
<tt class="descname">set_joinstyle</tt><big>(</big><em>js</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.set_joinstyle" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the join style to be one of (&#8216;miter&#8217;, &#8216;round&#8217;, &#8216;bevel&#8217;)</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.set_linestyle">
<tt class="descname">set_linestyle</tt><big>(</big><em>style</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.set_linestyle" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the linestyle to be one of (&#8216;solid&#8217;, &#8216;dashed&#8217;, &#8216;dashdot&#8217;,
&#8216;dotted&#8217;). One may specify customized dash styles by providing
a tuple of (offset, dash pairs). For example, the predefiend
linestyles have following values.:</p>
<blockquote>
<div>&#8216;dashed&#8217;  : (0, (6.0, 6.0)),
&#8216;dashdot&#8217; : (0, (3.0, 5.0, 1.0, 5.0)),
&#8216;dotted&#8217;  : (0, (1.0, 3.0)),</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.set_linewidth">
<tt class="descname">set_linewidth</tt><big>(</big><em>w</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.set_linewidth" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the linewidth in points</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.set_snap">
<tt class="descname">set_snap</tt><big>(</big><em>snap</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.set_snap" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the snap setting which may be:</p>
<ul class="simple">
<li>True: snap vertices to the nearest pixel center</li>
<li>False: leave vertices as-is</li>
<li>None: (auto) If the path contains only rectilinear line
segments, round to the nearest pixel center</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.GraphicsContextBase.set_url">
<tt class="descname">set_url</tt><big>(</big><em>url</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.GraphicsContextBase.set_url" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the url for links in compatible backends</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.backend_bases.IdleEvent">
<em class="property">class </em><tt class="descclassname">matplotlib.backend_bases.</tt><tt class="descname">IdleEvent</tt><big>(</big><em>name</em>, <em>canvas</em>, <em>guiEvent=None</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.IdleEvent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.backend_bases.Event</span></tt></a></p>
<p>An event triggered by the GUI backend when it is idle &#8211; useful
for passive animation</p>
</dd></dl>

<dl class="class">
<dt id="matplotlib.backend_bases.KeyEvent">
<em class="property">class </em><tt class="descclassname">matplotlib.backend_bases.</tt><tt class="descname">KeyEvent</tt><big>(</big><em>name</em>, <em>canvas</em>, <em>key</em>, <em>x=0</em>, <em>y=0</em>, <em>guiEvent=None</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.KeyEvent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.backend_bases.LocationEvent" title="matplotlib.backend_bases.LocationEvent"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.backend_bases.LocationEvent</span></tt></a></p>
<p>A key event (key press, key release).</p>
<p>Attach additional attributes as defined in
<a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase.mpl_connect" title="matplotlib.backend_bases.FigureCanvasBase.mpl_connect"><tt class="xref py py-meth docutils literal"><span class="pre">FigureCanvasBase.mpl_connect()</span></tt></a>.</p>
<p>In addition to the <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><tt class="xref py py-class docutils literal"><span class="pre">Event</span></tt></a> and <a class="reference internal" href="#matplotlib.backend_bases.LocationEvent" title="matplotlib.backend_bases.LocationEvent"><tt class="xref py py-class docutils literal"><span class="pre">LocationEvent</span></tt></a>
attributes, the following attributes are defined:</p>
<dl class="docutils">
<dt><em>key</em></dt>
<dd>the key(s) pressed. Could be <strong>None</strong>, a single case sensitive ascii
character (&#8220;g&#8221;, &#8220;G&#8221;, &#8220;#&#8221;, etc.), a special key
(&#8220;control&#8221;, &#8220;shift&#8221;, &#8220;f1&#8221;, &#8220;up&#8221;, etc.) or a
combination of the above (e.g. &#8220;ctrl+alt+g&#8221;, &#8220;ctrl+alt+G&#8221;).</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Modifier keys will be prefixed to the pressed key and will be in the
order &#8220;ctrl&#8221;, &#8220;alt&#8221;, &#8220;super&#8221;. The exception to this rule is when the
pressed key is itself a modifier key, therefore &#8220;ctrl+alt&#8221; and
&#8220;alt+control&#8221; can both be valid key values.</p>
</div>
<p>Example usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">on_key</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;you pressed&#39;</span><span class="p">,</span> <span class="n">event</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">event</span><span class="o">.</span><span class="n">xdata</span><span class="p">,</span> <span class="n">event</span><span class="o">.</span><span class="n">ydata</span><span class="p">)</span>

<span class="n">cid</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s">&#39;key_press_event&#39;</span><span class="p">,</span> <span class="n">on_key</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="matplotlib.backend_bases.LocationEvent">
<em class="property">class </em><tt class="descclassname">matplotlib.backend_bases.</tt><tt class="descname">LocationEvent</tt><big>(</big><em>name</em>, <em>canvas</em>, <em>x</em>, <em>y</em>, <em>guiEvent=None</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.LocationEvent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.backend_bases.Event</span></tt></a></p>
<p>An event that has a screen location</p>
<p>The following additional attributes are defined and shown with
their default values.</p>
<p>In addition to the <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><tt class="xref py py-class docutils literal"><span class="pre">Event</span></tt></a> attributes, the following
event attributes are defined:</p>
<dl class="docutils">
<dt><em>x</em></dt>
<dd>x position - pixels from left of canvas</dd>
<dt><em>y</em></dt>
<dd>y position - pixels from bottom of canvas</dd>
<dt><em>inaxes</em></dt>
<dd>the <a class="reference internal" href="axes_api.html#matplotlib.axes.Axes" title="matplotlib.axes.Axes"><tt class="xref py py-class docutils literal"><span class="pre">Axes</span></tt></a> instance if mouse is over axes</dd>
<dt><em>xdata</em></dt>
<dd>x coord of mouse in data coords</dd>
<dt><em>ydata</em></dt>
<dd>y coord of mouse in data coords</dd>
</dl>
<p><em>x</em>, <em>y</em> in figure coords, 0,0 = bottom, left</p>
<dl class="attribute">
<dt id="matplotlib.backend_bases.LocationEvent.inaxes">
<tt class="descname">inaxes</tt><em class="property"> = None</em><a class="headerlink" href="#matplotlib.backend_bases.LocationEvent.inaxes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.backend_bases.LocationEvent.lastevent">
<tt class="descname">lastevent</tt><em class="property"> = None</em><a class="headerlink" href="#matplotlib.backend_bases.LocationEvent.lastevent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.backend_bases.LocationEvent.x">
<tt class="descname">x</tt><em class="property"> = None</em><a class="headerlink" href="#matplotlib.backend_bases.LocationEvent.x" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.backend_bases.LocationEvent.xdata">
<tt class="descname">xdata</tt><em class="property"> = None</em><a class="headerlink" href="#matplotlib.backend_bases.LocationEvent.xdata" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.backend_bases.LocationEvent.y">
<tt class="descname">y</tt><em class="property"> = None</em><a class="headerlink" href="#matplotlib.backend_bases.LocationEvent.y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.backend_bases.LocationEvent.ydata">
<tt class="descname">ydata</tt><em class="property"> = None</em><a class="headerlink" href="#matplotlib.backend_bases.LocationEvent.ydata" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.backend_bases.MouseEvent">
<em class="property">class </em><tt class="descclassname">matplotlib.backend_bases.</tt><tt class="descname">MouseEvent</tt><big>(</big><em>name</em>, <em>canvas</em>, <em>x</em>, <em>y</em>, <em>button=None</em>, <em>key=None</em>, <em>step=0</em>, <em>dblclick=False</em>, <em>guiEvent=None</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.MouseEvent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.backend_bases.LocationEvent" title="matplotlib.backend_bases.LocationEvent"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.backend_bases.LocationEvent</span></tt></a></p>
<p>A mouse event (&#8216;button_press_event&#8217;, &#8216;button_release_event&#8217;, &#8216;scroll_event&#8217;,
&#8216;motion_notify_event&#8217;).</p>
<p>In addition to the <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><tt class="xref py py-class docutils literal"><span class="pre">Event</span></tt></a> and <a class="reference internal" href="#matplotlib.backend_bases.LocationEvent" title="matplotlib.backend_bases.LocationEvent"><tt class="xref py py-class docutils literal"><span class="pre">LocationEvent</span></tt></a>
attributes, the following attributes are defined:</p>
<dl class="docutils">
<dt><em>button</em></dt>
<dd>button pressed None, 1, 2, 3, &#8216;up&#8217;, &#8216;down&#8217; (up and down are used
for scroll events)</dd>
<dt><em>key</em></dt>
<dd>the key depressed when the mouse event triggered (see
<a class="reference internal" href="#matplotlib.backend_bases.KeyEvent" title="matplotlib.backend_bases.KeyEvent"><tt class="xref py py-class docutils literal"><span class="pre">KeyEvent</span></tt></a>)</dd>
<dt><em>step</em></dt>
<dd>number of scroll steps (positive for &#8216;up&#8217;, negative for &#8216;down&#8217;)</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">on_press</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;you pressed&#39;</span><span class="p">,</span> <span class="n">event</span><span class="o">.</span><span class="n">button</span><span class="p">,</span> <span class="n">event</span><span class="o">.</span><span class="n">xdata</span><span class="p">,</span> <span class="n">event</span><span class="o">.</span><span class="n">ydata</span><span class="p">)</span>

<span class="n">cid</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s">&#39;button_press_event&#39;</span><span class="p">,</span> <span class="n">on_press</span><span class="p">)</span>
</pre></div>
</div>
<p>x, y in figure coords, 0,0 = bottom, left
button pressed None, 1, 2, 3, &#8216;up&#8217;, &#8216;down&#8217;</p>
<dl class="attribute">
<dt id="matplotlib.backend_bases.MouseEvent.button">
<tt class="descname">button</tt><em class="property"> = None</em><a class="headerlink" href="#matplotlib.backend_bases.MouseEvent.button" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.backend_bases.MouseEvent.dblclick">
<tt class="descname">dblclick</tt><em class="property"> = None</em><a class="headerlink" href="#matplotlib.backend_bases.MouseEvent.dblclick" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.backend_bases.MouseEvent.inaxes">
<tt class="descname">inaxes</tt><em class="property"> = None</em><a class="headerlink" href="#matplotlib.backend_bases.MouseEvent.inaxes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.backend_bases.MouseEvent.step">
<tt class="descname">step</tt><em class="property"> = None</em><a class="headerlink" href="#matplotlib.backend_bases.MouseEvent.step" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.backend_bases.MouseEvent.x">
<tt class="descname">x</tt><em class="property"> = None</em><a class="headerlink" href="#matplotlib.backend_bases.MouseEvent.x" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.backend_bases.MouseEvent.xdata">
<tt class="descname">xdata</tt><em class="property"> = None</em><a class="headerlink" href="#matplotlib.backend_bases.MouseEvent.xdata" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.backend_bases.MouseEvent.y">
<tt class="descname">y</tt><em class="property"> = None</em><a class="headerlink" href="#matplotlib.backend_bases.MouseEvent.y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.backend_bases.MouseEvent.ydata">
<tt class="descname">ydata</tt><em class="property"> = None</em><a class="headerlink" href="#matplotlib.backend_bases.MouseEvent.ydata" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.backend_bases.NavigationToolbar2">
<em class="property">class </em><tt class="descclassname">matplotlib.backend_bases.</tt><tt class="descname">NavigationToolbar2</tt><big>(</big><em>canvas</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.NavigationToolbar2" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Base class for the navigation cursor, version 2</p>
<p>backends must implement a canvas that handles connections for
&#8216;button_press_event&#8217; and &#8216;button_release_event&#8217;.  See
<a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase.mpl_connect" title="matplotlib.backend_bases.FigureCanvasBase.mpl_connect"><tt class="xref py py-meth docutils literal"><span class="pre">FigureCanvasBase.mpl_connect()</span></tt></a> for more information</p>
<p>They must also define</p>
<blockquote>
<div><dl class="docutils">
<dt><a class="reference internal" href="#matplotlib.backend_bases.NavigationToolbar2.save_figure" title="matplotlib.backend_bases.NavigationToolbar2.save_figure"><tt class="xref py py-meth docutils literal"><span class="pre">save_figure()</span></tt></a></dt>
<dd>save the current figure</dd>
<dt><a class="reference internal" href="#matplotlib.backend_bases.NavigationToolbar2.set_cursor" title="matplotlib.backend_bases.NavigationToolbar2.set_cursor"><tt class="xref py py-meth docutils literal"><span class="pre">set_cursor()</span></tt></a></dt>
<dd>if you want the pointer icon to change</dd>
<dt><tt class="xref py py-meth docutils literal"><span class="pre">_init_toolbar()</span></tt></dt>
<dd>create your toolbar widget</dd>
<dt><a class="reference internal" href="#matplotlib.backend_bases.NavigationToolbar2.draw_rubberband" title="matplotlib.backend_bases.NavigationToolbar2.draw_rubberband"><tt class="xref py py-meth docutils literal"><span class="pre">draw_rubberband()</span></tt></a> (optional)</dt>
<dd>draw the zoom to rect &#8220;rubberband&#8221; rectangle</dd>
<dt><a class="reference internal" href="#matplotlib.backend_bases.NavigationToolbar2.press" title="matplotlib.backend_bases.NavigationToolbar2.press"><tt class="xref py py-meth docutils literal"><span class="pre">press()</span></tt></a>  (optional)</dt>
<dd>whenever a mouse button is pressed, you&#8217;ll be notified with
the event</dd>
<dt><a class="reference internal" href="#matplotlib.backend_bases.NavigationToolbar2.release" title="matplotlib.backend_bases.NavigationToolbar2.release"><tt class="xref py py-meth docutils literal"><span class="pre">release()</span></tt></a> (optional)</dt>
<dd>whenever a mouse button is released, you&#8217;ll be notified with
the event</dd>
<dt><a class="reference internal" href="#matplotlib.backend_bases.NavigationToolbar2.dynamic_update" title="matplotlib.backend_bases.NavigationToolbar2.dynamic_update"><tt class="xref py py-meth docutils literal"><span class="pre">dynamic_update()</span></tt></a> (optional)</dt>
<dd>dynamically update the window while navigating</dd>
<dt><a class="reference internal" href="#matplotlib.backend_bases.NavigationToolbar2.set_message" title="matplotlib.backend_bases.NavigationToolbar2.set_message"><tt class="xref py py-meth docutils literal"><span class="pre">set_message()</span></tt></a> (optional)</dt>
<dd>display message</dd>
<dt><a class="reference internal" href="#matplotlib.backend_bases.NavigationToolbar2.set_history_buttons" title="matplotlib.backend_bases.NavigationToolbar2.set_history_buttons"><tt class="xref py py-meth docutils literal"><span class="pre">set_history_buttons()</span></tt></a> (optional)</dt>
<dd>you can change the history back / forward buttons to
indicate disabled / enabled state.</dd>
</dl>
</div></blockquote>
<p>That&#8217;s it, we&#8217;ll do the rest!</p>
<dl class="method">
<dt id="matplotlib.backend_bases.NavigationToolbar2.back">
<tt class="descname">back</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.NavigationToolbar2.back" title="Permalink to this definition">¶</a></dt>
<dd><p>move back up the view lim stack</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.NavigationToolbar2.drag_pan">
<tt class="descname">drag_pan</tt><big>(</big><em>event</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.NavigationToolbar2.drag_pan" title="Permalink to this definition">¶</a></dt>
<dd><p>the drag callback in pan/zoom mode</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.NavigationToolbar2.drag_zoom">
<tt class="descname">drag_zoom</tt><big>(</big><em>event</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.NavigationToolbar2.drag_zoom" title="Permalink to this definition">¶</a></dt>
<dd><p>the drag callback in zoom mode</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.NavigationToolbar2.draw">
<tt class="descname">draw</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.NavigationToolbar2.draw" title="Permalink to this definition">¶</a></dt>
<dd><p>Redraw the canvases, update the locators</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.NavigationToolbar2.draw_rubberband">
<tt class="descname">draw_rubberband</tt><big>(</big><em>event</em>, <em>x0</em>, <em>y0</em>, <em>x1</em>, <em>y1</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.NavigationToolbar2.draw_rubberband" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a rectangle rubberband to indicate zoom limits</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.NavigationToolbar2.dynamic_update">
<tt class="descname">dynamic_update</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.NavigationToolbar2.dynamic_update" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.NavigationToolbar2.forward">
<tt class="descname">forward</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.NavigationToolbar2.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Move forward in the view lim stack</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.NavigationToolbar2.home">
<tt class="descname">home</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.NavigationToolbar2.home" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore the original view</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.NavigationToolbar2.mouse_move">
<tt class="descname">mouse_move</tt><big>(</big><em>event</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.NavigationToolbar2.mouse_move" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.NavigationToolbar2.pan">
<tt class="descname">pan</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.NavigationToolbar2.pan" title="Permalink to this definition">¶</a></dt>
<dd><p>Activate the pan/zoom tool. pan with left button, zoom with right</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.NavigationToolbar2.press">
<tt class="descname">press</tt><big>(</big><em>event</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.NavigationToolbar2.press" title="Permalink to this definition">¶</a></dt>
<dd><p>Called whenver a mouse button is pressed.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.NavigationToolbar2.press_pan">
<tt class="descname">press_pan</tt><big>(</big><em>event</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.NavigationToolbar2.press_pan" title="Permalink to this definition">¶</a></dt>
<dd><p>the press mouse button in pan/zoom mode callback</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.NavigationToolbar2.press_zoom">
<tt class="descname">press_zoom</tt><big>(</big><em>event</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.NavigationToolbar2.press_zoom" title="Permalink to this definition">¶</a></dt>
<dd><p>the press mouse button in zoom to rect mode callback</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.NavigationToolbar2.push_current">
<tt class="descname">push_current</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.NavigationToolbar2.push_current" title="Permalink to this definition">¶</a></dt>
<dd><p>push the current view limits and position onto the stack</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.NavigationToolbar2.release">
<tt class="descname">release</tt><big>(</big><em>event</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.NavigationToolbar2.release" title="Permalink to this definition">¶</a></dt>
<dd><p>this will be called whenever mouse button is released</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.NavigationToolbar2.release_pan">
<tt class="descname">release_pan</tt><big>(</big><em>event</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.NavigationToolbar2.release_pan" title="Permalink to this definition">¶</a></dt>
<dd><p>the release mouse button callback in pan/zoom mode</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.NavigationToolbar2.release_zoom">
<tt class="descname">release_zoom</tt><big>(</big><em>event</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.NavigationToolbar2.release_zoom" title="Permalink to this definition">¶</a></dt>
<dd><p>the release mouse button callback in zoom to rect mode</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.NavigationToolbar2.save_figure">
<tt class="descname">save_figure</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.NavigationToolbar2.save_figure" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the current figure</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.NavigationToolbar2.set_cursor">
<tt class="descname">set_cursor</tt><big>(</big><em>cursor</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.NavigationToolbar2.set_cursor" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the current cursor to one of the <a class="reference internal" href="#matplotlib.backend_bases.Cursors" title="matplotlib.backend_bases.Cursors"><tt class="xref py py-class docutils literal"><span class="pre">Cursors</span></tt></a>
enums values</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.NavigationToolbar2.set_history_buttons">
<tt class="descname">set_history_buttons</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.NavigationToolbar2.set_history_buttons" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable or disable back/forward button</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.NavigationToolbar2.set_message">
<tt class="descname">set_message</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.NavigationToolbar2.set_message" title="Permalink to this definition">¶</a></dt>
<dd><p>Display a message on toolbar or in status bar</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.backend_bases.NavigationToolbar2.toolitems">
<tt class="descname">toolitems</tt><em class="property"> = (('Home', 'Reset original view', 'home', 'home'), ('Back', 'Back to  previous view', 'back', 'back'), ('Forward', 'Forward to next view', 'forward', 'forward'), (None, None, None, None), ('Pan', 'Pan axes with left mouse, zoom with right', 'move', 'pan'), ('Zoom', 'Zoom to rectangle', 'zoom_to_rect', 'zoom'), (None, None, None, None), ('Subplots', 'Configure subplots', 'subplots', 'configure_subplots'), ('Save', 'Save the figure', 'filesave', 'save_figure'))</em><a class="headerlink" href="#matplotlib.backend_bases.NavigationToolbar2.toolitems" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.NavigationToolbar2.update">
<tt class="descname">update</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.NavigationToolbar2.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the axes stack</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.NavigationToolbar2.zoom">
<tt class="descname">zoom</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.NavigationToolbar2.zoom" title="Permalink to this definition">¶</a></dt>
<dd><p>Activate zoom to rect mode</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="matplotlib.backend_bases.NonGuiException">
<em class="property">exception </em><tt class="descclassname">matplotlib.backend_bases.</tt><tt class="descname">NonGuiException</tt><a class="headerlink" href="#matplotlib.backend_bases.NonGuiException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></tt></p>
</dd></dl>

<dl class="class">
<dt id="matplotlib.backend_bases.PickEvent">
<em class="property">class </em><tt class="descclassname">matplotlib.backend_bases.</tt><tt class="descname">PickEvent</tt><big>(</big><em>name</em>, <em>canvas</em>, <em>mouseevent</em>, <em>artist</em>, <em>guiEvent=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.PickEvent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.backend_bases.Event</span></tt></a></p>
<p>a pick event, fired when the user picks a location on the canvas
sufficiently close to an artist.</p>
<p>Attrs: all the <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><tt class="xref py py-class docutils literal"><span class="pre">Event</span></tt></a> attributes plus</p>
<dl class="docutils">
<dt><em>mouseevent</em></dt>
<dd>the <a class="reference internal" href="#matplotlib.backend_bases.MouseEvent" title="matplotlib.backend_bases.MouseEvent"><tt class="xref py py-class docutils literal"><span class="pre">MouseEvent</span></tt></a> that generated the pick</dd>
<dt><em>artist</em></dt>
<dd>the <a class="reference internal" href="artist_api.html#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><tt class="xref py py-class docutils literal"><span class="pre">Artist</span></tt></a> picked</dd>
<dt>other</dt>
<dd>extra class dependent attrs &#8211; eg a
<a class="reference internal" href="artist_api.html#matplotlib.lines.Line2D" title="matplotlib.lines.Line2D"><tt class="xref py py-class docutils literal"><span class="pre">Line2D</span></tt></a> pick may define different
extra attributes than a
<a class="reference internal" href="collections_api.html#matplotlib.collections.PatchCollection" title="matplotlib.collections.PatchCollection"><tt class="xref py py-class docutils literal"><span class="pre">PatchCollection</span></tt></a> pick event</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">line</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="s">&#39;o&#39;</span><span class="p">,</span> <span class="n">picker</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>  <span class="c"># 5 points tolerance</span>

<span class="k">def</span> <span class="nf">on_pick</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="n">thisline</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">artist</span>
    <span class="n">xdata</span><span class="p">,</span> <span class="n">ydata</span> <span class="o">=</span> <span class="n">thisline</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">event</span><span class="o">.</span><span class="n">ind</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;on pick line:&#39;</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xdata</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">ydata</span><span class="p">[</span><span class="n">ind</span><span class="p">]))</span>

<span class="n">cid</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s">&#39;pick_event&#39;</span><span class="p">,</span> <span class="n">on_pick</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="matplotlib.backend_bases.RendererBase">
<em class="property">class </em><tt class="descclassname">matplotlib.backend_bases.</tt><tt class="descname">RendererBase</tt><a class="headerlink" href="#matplotlib.backend_bases.RendererBase" title="Permalink to this definition">¶</a></dt>
<dd><p>An abstract base class to handle drawing/rendering operations.</p>
<p>The following methods <em>must</em> be implemented in the backend:</p>
<ul class="simple">
<li><a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_path" title="matplotlib.backend_bases.RendererBase.draw_path"><tt class="xref py py-meth docutils literal"><span class="pre">draw_path()</span></tt></a></li>
<li><a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_image" title="matplotlib.backend_bases.RendererBase.draw_image"><tt class="xref py py-meth docutils literal"><span class="pre">draw_image()</span></tt></a></li>
<li><a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_text" title="matplotlib.backend_bases.RendererBase.draw_text"><tt class="xref py py-meth docutils literal"><span class="pre">draw_text()</span></tt></a></li>
<li><a class="reference internal" href="#matplotlib.backend_bases.RendererBase.get_text_width_height_descent" title="matplotlib.backend_bases.RendererBase.get_text_width_height_descent"><tt class="xref py py-meth docutils literal"><span class="pre">get_text_width_height_descent()</span></tt></a></li>
</ul>
<p>The following methods <em>should</em> be implemented in the backend for
optimization reasons:</p>
<ul class="simple">
<li><a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_markers" title="matplotlib.backend_bases.RendererBase.draw_markers"><tt class="xref py py-meth docutils literal"><span class="pre">draw_markers()</span></tt></a></li>
<li><a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_path_collection" title="matplotlib.backend_bases.RendererBase.draw_path_collection"><tt class="xref py py-meth docutils literal"><span class="pre">draw_path_collection()</span></tt></a></li>
<li><a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_quad_mesh" title="matplotlib.backend_bases.RendererBase.draw_quad_mesh"><tt class="xref py py-meth docutils literal"><span class="pre">draw_quad_mesh()</span></tt></a></li>
</ul>
<dl class="method">
<dt id="matplotlib.backend_bases.RendererBase.close_group">
<tt class="descname">close_group</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.RendererBase.close_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a grouping element with label <em>s</em>
Is only currently used by <tt class="xref py py-mod docutils literal"><span class="pre">backend_svg</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.RendererBase.draw_gouraud_triangle">
<tt class="descname">draw_gouraud_triangle</tt><big>(</big><em>gc</em>, <em>points</em>, <em>colors</em>, <em>transform</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.RendererBase.draw_gouraud_triangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a Gouraud-shaded triangle.</p>
<p><em>points</em> is a 3x2 array of (x, y) points for the triangle.</p>
<p><em>colors</em> is a 3x4 array of RGBA colors for each point of the
triangle.</p>
<p><em>transform</em> is an affine transform to apply to the points.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.RendererBase.draw_gouraud_triangles">
<tt class="descname">draw_gouraud_triangles</tt><big>(</big><em>gc</em>, <em>triangles_array</em>, <em>colors_array</em>, <em>transform</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.RendererBase.draw_gouraud_triangles" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a series of Gouraud triangles.</p>
<p><em>points</em> is a Nx3x2 array of (x, y) points for the trianglex.</p>
<p><em>colors</em> is a Nx3x4 array of RGBA colors for each point of the
triangles.</p>
<p><em>transform</em> is an affine transform to apply to the points.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.RendererBase.draw_image">
<tt class="descname">draw_image</tt><big>(</big><em>gc</em>, <em>x</em>, <em>y</em>, <em>im</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.RendererBase.draw_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw the image instance into the current axes;</p>
<dl class="docutils">
<dt><em>gc</em></dt>
<dd>a GraphicsContext containing clipping information</dd>
<dt><em>x</em></dt>
<dd>is the distance in pixels from the left hand side of the canvas.</dd>
<dt><em>y</em></dt>
<dd>the distance from the origin.  That is, if origin is
upper, y is the distance from top.  If origin is lower, y
is the distance from bottom</dd>
<dt><em>im</em></dt>
<dd>the <tt class="xref py py-class docutils literal"><span class="pre">matplotlib._image.Image</span></tt> instance</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.RendererBase.draw_markers">
<tt class="descname">draw_markers</tt><big>(</big><em>gc</em>, <em>marker_path</em>, <em>marker_trans</em>, <em>path</em>, <em>trans</em>, <em>rgbFace=None</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.RendererBase.draw_markers" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a marker at each of the vertices in path.  This includes
all vertices, including control points on curves.  To avoid
that behavior, those vertices should be removed before calling
this function.</p>
<dl class="docutils">
<dt><em>gc</em></dt>
<dd>the <a class="reference internal" href="#matplotlib.backend_bases.GraphicsContextBase" title="matplotlib.backend_bases.GraphicsContextBase"><tt class="xref py py-class docutils literal"><span class="pre">GraphicsContextBase</span></tt></a> instance</dd>
<dt><em>marker_trans</em></dt>
<dd>is an affine transform applied to the marker.</dd>
<dt><em>trans</em></dt>
<dd>is an affine transform applied to the path.</dd>
</dl>
<p>This provides a fallback implementation of draw_markers that
makes multiple calls to <a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_path" title="matplotlib.backend_bases.RendererBase.draw_path"><tt class="xref py py-meth docutils literal"><span class="pre">draw_path()</span></tt></a>.  Some backends may
want to override this method in order to draw the marker only
once and reuse it multiple times.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.RendererBase.draw_path">
<tt class="descname">draw_path</tt><big>(</big><em>gc</em>, <em>path</em>, <em>transform</em>, <em>rgbFace=None</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.RendererBase.draw_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a <a class="reference internal" href="path_api.html#matplotlib.path.Path" title="matplotlib.path.Path"><tt class="xref py py-class docutils literal"><span class="pre">Path</span></tt></a> instance using the
given affine transform.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.RendererBase.draw_path_collection">
<tt class="descname">draw_path_collection</tt><big>(</big><em>gc</em>, <em>master_transform</em>, <em>paths</em>, <em>all_transforms</em>, <em>offsets</em>, <em>offsetTrans</em>, <em>facecolors</em>, <em>edgecolors</em>, <em>linewidths</em>, <em>linestyles</em>, <em>antialiaseds</em>, <em>urls</em>, <em>offset_position</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.RendererBase.draw_path_collection" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a collection of paths selecting drawing properties from
the lists <em>facecolors</em>, <em>edgecolors</em>, <em>linewidths</em>,
<em>linestyles</em> and <em>antialiaseds</em>. <em>offsets</em> is a list of
offsets to apply to each of the paths.  The offsets in
<em>offsets</em> are first transformed by <em>offsetTrans</em> before being
applied.  <em>offset_position</em> may be either &#8220;screen&#8221; or &#8220;data&#8221;
depending on the space that the offsets are in.</p>
<p>This provides a fallback implementation of
<a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_path_collection" title="matplotlib.backend_bases.RendererBase.draw_path_collection"><tt class="xref py py-meth docutils literal"><span class="pre">draw_path_collection()</span></tt></a> that makes multiple calls to
<a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_path" title="matplotlib.backend_bases.RendererBase.draw_path"><tt class="xref py py-meth docutils literal"><span class="pre">draw_path()</span></tt></a>.  Some backends may want to override this in
order to render each set of path data only once, and then
reference that path multiple times with the different offsets,
colors, styles etc.  The generator methods
<tt class="xref py py-meth docutils literal"><span class="pre">_iter_collection_raw_paths()</span></tt> and
<tt class="xref py py-meth docutils literal"><span class="pre">_iter_collection()</span></tt> are provided to help with (and
standardize) the implementation across backends.  It is highly
recommended to use those generators, so that changes to the
behavior of <a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_path_collection" title="matplotlib.backend_bases.RendererBase.draw_path_collection"><tt class="xref py py-meth docutils literal"><span class="pre">draw_path_collection()</span></tt></a> can be made globally.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.RendererBase.draw_quad_mesh">
<tt class="descname">draw_quad_mesh</tt><big>(</big><em>gc</em>, <em>master_transform</em>, <em>meshWidth</em>, <em>meshHeight</em>, <em>coordinates</em>, <em>offsets</em>, <em>offsetTrans</em>, <em>facecolors</em>, <em>antialiased</em>, <em>edgecolors</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.RendererBase.draw_quad_mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>This provides a fallback implementation of
<a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_quad_mesh" title="matplotlib.backend_bases.RendererBase.draw_quad_mesh"><tt class="xref py py-meth docutils literal"><span class="pre">draw_quad_mesh()</span></tt></a> that generates paths and then calls
<a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_path_collection" title="matplotlib.backend_bases.RendererBase.draw_path_collection"><tt class="xref py py-meth docutils literal"><span class="pre">draw_path_collection()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.RendererBase.draw_tex">
<tt class="descname">draw_tex</tt><big>(</big><em>gc</em>, <em>x</em>, <em>y</em>, <em>s</em>, <em>prop</em>, <em>angle</em>, <em>ismath='TeX!'</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.RendererBase.draw_tex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.RendererBase.draw_text">
<tt class="descname">draw_text</tt><big>(</big><em>gc</em>, <em>x</em>, <em>y</em>, <em>s</em>, <em>prop</em>, <em>angle</em>, <em>ismath=False</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.RendererBase.draw_text" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw the text instance</p>
<dl class="docutils">
<dt><em>gc</em></dt>
<dd>the <a class="reference internal" href="#matplotlib.backend_bases.GraphicsContextBase" title="matplotlib.backend_bases.GraphicsContextBase"><tt class="xref py py-class docutils literal"><span class="pre">GraphicsContextBase</span></tt></a> instance</dd>
<dt><em>x</em></dt>
<dd>the x location of the text in display coords</dd>
<dt><em>y</em></dt>
<dd>the y location of the text in display coords</dd>
<dt><em>s</em></dt>
<dd>a <a class="reference internal" href="artist_api.html#matplotlib.text.Text" title="matplotlib.text.Text"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.text.Text</span></tt></a> instance</dd>
<dt><em>prop</em></dt>
<dd>a <a class="reference internal" href="font_manager_api.html#matplotlib.font_manager.FontProperties" title="matplotlib.font_manager.FontProperties"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.font_manager.FontProperties</span></tt></a> instance</dd>
<dt><em>angle</em></dt>
<dd>the rotation angle in degrees</dd>
</dl>
<p><strong>backend implementers note</strong></p>
<p>When you are trying to determine if you have gotten your bounding box
right (which is what enables the text layout/alignment to work
properly), it helps to change the line in text.py:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="mi">0</span><span class="p">:</span> <span class="n">bbox_artist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renderer</span><span class="p">)</span>
</pre></div>
</div>
<p>to if 1, and then the actual bounding box will be blotted along with
your text.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.RendererBase.flipy">
<tt class="descname">flipy</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.RendererBase.flipy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return true if y small numbers are top for renderer Is used
for drawing text (<a class="reference internal" href="artist_api.html#module-matplotlib.text" title="matplotlib.text"><tt class="xref py py-mod docutils literal"><span class="pre">matplotlib.text</span></tt></a>) and images
(<tt class="xref py py-mod docutils literal"><span class="pre">matplotlib.image</span></tt>) only</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.RendererBase.get_canvas_width_height">
<tt class="descname">get_canvas_width_height</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.RendererBase.get_canvas_width_height" title="Permalink to this definition">¶</a></dt>
<dd><p>return the canvas width and height in display coords</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.RendererBase.get_image_magnification">
<tt class="descname">get_image_magnification</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.RendererBase.get_image_magnification" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the factor by which to magnify images passed to <a class="reference internal" href="#matplotlib.backend_bases.RendererBase.draw_image" title="matplotlib.backend_bases.RendererBase.draw_image"><tt class="xref py py-meth docutils literal"><span class="pre">draw_image()</span></tt></a>.
Allows a backend to have images at a different resolution to other
artists.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.RendererBase.get_texmanager">
<tt class="descname">get_texmanager</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.RendererBase.get_texmanager" title="Permalink to this definition">¶</a></dt>
<dd><p>return the <tt class="xref py py-class docutils literal"><span class="pre">matplotlib.texmanager.TexManager</span></tt> instance</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.RendererBase.get_text_width_height_descent">
<tt class="descname">get_text_width_height_descent</tt><big>(</big><em>s</em>, <em>prop</em>, <em>ismath</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.RendererBase.get_text_width_height_descent" title="Permalink to this definition">¶</a></dt>
<dd><p>get the width and height, and the offset from the bottom to the
baseline (descent), in display coords of the string s with
<a class="reference internal" href="font_manager_api.html#matplotlib.font_manager.FontProperties" title="matplotlib.font_manager.FontProperties"><tt class="xref py py-class docutils literal"><span class="pre">FontProperties</span></tt></a> prop</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.RendererBase.new_gc">
<tt class="descname">new_gc</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.RendererBase.new_gc" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an instance of a <a class="reference internal" href="#matplotlib.backend_bases.GraphicsContextBase" title="matplotlib.backend_bases.GraphicsContextBase"><tt class="xref py py-class docutils literal"><span class="pre">GraphicsContextBase</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.RendererBase.open_group">
<tt class="descname">open_group</tt><big>(</big><em>s</em>, <em>gid=None</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.RendererBase.open_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a grouping element with label <em>s</em>. If <em>gid</em> is given, use
<em>gid</em> as the id of the group. Is only currently used by
<tt class="xref py py-mod docutils literal"><span class="pre">backend_svg</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.RendererBase.option_image_nocomposite">
<tt class="descname">option_image_nocomposite</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.RendererBase.option_image_nocomposite" title="Permalink to this definition">¶</a></dt>
<dd><p>override this method for renderers that do not necessarily
want to rescale and composite raster images. (like SVG)</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.RendererBase.option_scale_image">
<tt class="descname">option_scale_image</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.RendererBase.option_scale_image" title="Permalink to this definition">¶</a></dt>
<dd><p>override this method for renderers that support arbitrary
scaling of image (most of the vector backend).</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.RendererBase.points_to_pixels">
<tt class="descname">points_to_pixels</tt><big>(</big><em>points</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.RendererBase.points_to_pixels" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert points to display units</p>
<dl class="docutils">
<dt><em>points</em></dt>
<dd>a float or a numpy array of float</dd>
</dl>
<p>return points converted to pixels</p>
<p>You need to override this function (unless your backend
doesn&#8217;t have a dpi, eg, postscript or svg).  Some imaging
systems assume some value for pixels per inch:</p>
<div class="highlight-python"><pre>points to pixels = points * pixels_per_inch/72.0 * dpi/72.0</pre>
</div>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.RendererBase.start_filter">
<tt class="descname">start_filter</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.RendererBase.start_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in AggRenderer. Switch to a temporary renderer for image
filtering effects.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.RendererBase.start_rasterizing">
<tt class="descname">start_rasterizing</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.RendererBase.start_rasterizing" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in MixedModeRenderer. Switch to the raster renderer.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.RendererBase.stop_filter">
<tt class="descname">stop_filter</tt><big>(</big><em>filter_func</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.RendererBase.stop_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in AggRenderer. Switch back to the original renderer.
The contents of the temporary renderer is processed with the
<em>filter_func</em> and is drawn on the original renderer as an
image.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.RendererBase.stop_rasterizing">
<tt class="descname">stop_rasterizing</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.RendererBase.stop_rasterizing" title="Permalink to this definition">¶</a></dt>
<dd><p>Used in MixedModeRenderer. Switch back to the vector renderer
and draw the contents of the raster renderer as an image on
the vector renderer.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.RendererBase.strip_math">
<tt class="descname">strip_math</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.RendererBase.strip_math" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.backend_bases.ResizeEvent">
<em class="property">class </em><tt class="descclassname">matplotlib.backend_bases.</tt><tt class="descname">ResizeEvent</tt><big>(</big><em>name</em>, <em>canvas</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.ResizeEvent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.backend_bases.Event</span></tt></a></p>
<p>An event triggered by a canvas resize</p>
<p>In addition to the <a class="reference internal" href="#matplotlib.backend_bases.Event" title="matplotlib.backend_bases.Event"><tt class="xref py py-class docutils literal"><span class="pre">Event</span></tt></a> attributes, the following event attributes are defined:</p>
<dl class="docutils">
<dt><em>width</em></dt>
<dd>width of the canvas in pixels</dd>
<dt><em>height</em></dt>
<dd>height of the canvas in pixels</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="matplotlib.backend_bases.ShowBase">
<em class="property">class </em><tt class="descclassname">matplotlib.backend_bases.</tt><tt class="descname">ShowBase</tt><a class="headerlink" href="#matplotlib.backend_bases.ShowBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Simple base class to generate a show() callable in backends.</p>
<p>Subclass must override mainloop() method.</p>
<dl class="method">
<dt id="matplotlib.backend_bases.ShowBase.mainloop">
<tt class="descname">mainloop</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.ShowBase.mainloop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.backend_bases.TimerBase">
<em class="property">class </em><tt class="descclassname">matplotlib.backend_bases.</tt><tt class="descname">TimerBase</tt><big>(</big><em>interval=None</em>, <em>callbacks=None</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.TimerBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A base class for providing timer events, useful for things animations.
Backends need to implement a few specific methods in order to use their
own timing mechanisms so that the timer events are integrated into their
event loops.</p>
<p>Mandatory functions that must be implemented:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="xref py py-obj docutils literal"><span class="pre">_timer_start</span></tt>: Contains backend-specific code for starting
the timer</li>
<li><tt class="xref py py-obj docutils literal"><span class="pre">_timer_stop</span></tt>: Contains backend-specific code for stopping
the timer</li>
</ul>
</div></blockquote>
<p>Optional overrides:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="xref py py-obj docutils literal"><span class="pre">_timer_set_single_shot</span></tt>: Code for setting the timer to
single shot operating mode, if supported by the timer
object. If not, the <tt class="xref py py-obj docutils literal"><span class="pre">Timer</span></tt> class itself will store the flag
and the <tt class="xref py py-obj docutils literal"><span class="pre">_on_timer</span></tt> method should be overridden to support
such behavior.</li>
<li><tt class="xref py py-obj docutils literal"><span class="pre">_timer_set_interval</span></tt>: Code for setting the interval on the
timer, if there is a method for doing so on the timer
object.</li>
<li><tt class="xref py py-obj docutils literal"><span class="pre">_on_timer</span></tt>: This is the internal function that any timer
object should call, which will handle the task of running
all callbacks that have been set.</li>
</ul>
</div></blockquote>
<p>Attributes:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#matplotlib.backend_bases.TimerBase.interval" title="matplotlib.backend_bases.TimerBase.interval"><tt class="xref py py-obj docutils literal"><span class="pre">interval</span></tt></a>: The time between timer events in
milliseconds. Default is 1000 ms.</li>
<li><a class="reference internal" href="#matplotlib.backend_bases.TimerBase.single_shot" title="matplotlib.backend_bases.TimerBase.single_shot"><tt class="xref py py-obj docutils literal"><span class="pre">single_shot</span></tt></a>: Boolean flag indicating whether this timer
should operate as single shot (run once and then
stop). Defaults to <tt class="xref py py-obj docutils literal"><span class="pre">False</span></tt>.</li>
<li><tt class="xref py py-obj docutils literal"><span class="pre">callbacks</span></tt>: Stores list of (func, args) tuples that will be
called upon timer events. This list can be manipulated
directly, or the functions <a class="reference internal" href="#matplotlib.backend_bases.TimerBase.add_callback" title="matplotlib.backend_bases.TimerBase.add_callback"><tt class="xref py py-obj docutils literal"><span class="pre">add_callback</span></tt></a> and
<a class="reference internal" href="#matplotlib.backend_bases.TimerBase.remove_callback" title="matplotlib.backend_bases.TimerBase.remove_callback"><tt class="xref py py-obj docutils literal"><span class="pre">remove_callback</span></tt></a> can be used.</li>
</ul>
</div></blockquote>
<dl class="method">
<dt id="matplotlib.backend_bases.TimerBase.add_callback">
<tt class="descname">add_callback</tt><big>(</big><em>func</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.TimerBase.add_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Register <tt class="xref py py-obj docutils literal"><span class="pre">func</span></tt> to be called by timer when the event fires. Any
additional arguments provided will be passed to <tt class="xref py py-obj docutils literal"><span class="pre">func</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.backend_bases.TimerBase.interval">
<tt class="descname">interval</tt><a class="headerlink" href="#matplotlib.backend_bases.TimerBase.interval" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.TimerBase.remove_callback">
<tt class="descname">remove_callback</tt><big>(</big><em>func</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.TimerBase.remove_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove <tt class="xref py py-obj docutils literal"><span class="pre">func</span></tt> from list of callbacks. <tt class="xref py py-obj docutils literal"><span class="pre">args</span></tt> and <tt class="xref py py-obj docutils literal"><span class="pre">kwargs</span></tt> are optional
and used to distinguish between copies of the same function registered
to be called with different arguments.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.backend_bases.TimerBase.single_shot">
<tt class="descname">single_shot</tt><a class="headerlink" href="#matplotlib.backend_bases.TimerBase.single_shot" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.TimerBase.start">
<tt class="descname">start</tt><big>(</big><em>interval=None</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.TimerBase.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start the timer object. <a class="reference internal" href="#matplotlib.backend_bases.TimerBase.interval" title="matplotlib.backend_bases.TimerBase.interval"><tt class="xref py py-obj docutils literal"><span class="pre">interval</span></tt></a> is optional and will be used
to reset the timer interval first if provided.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.backend_bases.TimerBase.stop">
<tt class="descname">stop</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.TimerBase.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the timer.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="matplotlib.backend_bases.key_press_handler">
<tt class="descclassname">matplotlib.backend_bases.</tt><tt class="descname">key_press_handler</tt><big>(</big><em>event</em>, <em>canvas</em>, <em>toolbar=None</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.key_press_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>Implement the default mpl key bindings for the canvas and toolbar
described at <a class="reference internal" href="../users/navigation_toolbar.html#key-event-handling"><em>Navigation Keyboard Shortcuts</em></a></p>
<dl class="docutils">
<dt><em>event</em></dt>
<dd>a <a class="reference internal" href="#matplotlib.backend_bases.KeyEvent" title="matplotlib.backend_bases.KeyEvent"><tt class="xref py py-class docutils literal"><span class="pre">KeyEvent</span></tt></a> instance</dd>
<dt><em>canvas</em></dt>
<dd>a <a class="reference internal" href="#matplotlib.backend_bases.FigureCanvasBase" title="matplotlib.backend_bases.FigureCanvasBase"><tt class="xref py py-class docutils literal"><span class="pre">FigureCanvasBase</span></tt></a> instance</dd>
<dt><em>toolbar</em></dt>
<dd>a <a class="reference internal" href="#matplotlib.backend_bases.NavigationToolbar2" title="matplotlib.backend_bases.NavigationToolbar2"><tt class="xref py py-class docutils literal"><span class="pre">NavigationToolbar2</span></tt></a> instance</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="matplotlib.backend_bases.register_backend">
<tt class="descclassname">matplotlib.backend_bases.</tt><tt class="descname">register_backend</tt><big>(</big><em>format</em>, <em>backend_class</em><big>)</big><a class="headerlink" href="#matplotlib.backend_bases.register_backend" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="backend_gtkagg_api.html" title="matplotlib.backends.backend_gtkagg"
             >next</a> |</li>
        <li class="right" >
          <a href="index_backend_api.html" title="backends"
             >previous</a> |</li>
        <li><a href="../index.html">home</a>|&nbsp;</li>
        <li><a href="../search.html">search</a>|&nbsp;</li>
        <li><a href="../examples/index.html">examples</a>|&nbsp;</li>
        <li><a href="../gallery.html">gallery</a>|&nbsp;</li>
        <li><a href="../contents.html">docs</a> &raquo;</li>

          <li><a href="index.html" >The Matplotlib API</a> &raquo;</li>
          <li><a href="index_backend_api.html" >backends</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012 John Hunter, Darren Dale, Eric Firing, Michael Droettboom and the matplotlib development team.
      Last updated on Sep 19, 2012.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>