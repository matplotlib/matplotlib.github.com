

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>collections &mdash; Matplotlib 1.2.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/mpl.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Matplotlib 1.2.0 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="top" title="Matplotlib 1.2.0 documentation" href="../index.html" />
    <link rel="up" title="The Matplotlib API" href="index.html" />
    <link rel="next" title="colorbar" href="colorbar_api.html" />
    <link rel="prev" title="cm (colormap)" href="cm_api.html" /> 
  </head>
  <body>
<!-- Piwik -->
<script type="text/javascript">
if ("matplotlib.sourceforge.net" == document.location.hostname ||
    "matplotlib.sf.net" == document.location.hostname) {
  var pkBaseURL = (("https:" == document.location.protocol) ? "https://apps.sourceforge.net/piwik/matplotlib/" : "http://apps.sourceforge.net/piwik/matplotlib/");
  document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
}
</script>
<script type="text/javascript">
if ("matplotlib.sourceforge.net" == document.location.hostname ||
    "matplotlib.sf.net" == document.location.hostname) {
  piwik_action_name = '';
  piwik_idsite = 1;
  piwik_url = pkBaseURL + "piwik.php";
  piwik_log(piwik_action_name, piwik_idsite, piwik_url);
  document.write(unescape('%3Cobject%3E%3Cnoscript%3E%3Cp%3E%3Cimg src="http://apps.sourceforge.net/piwik/matplotlib/piwik.php?idsite=1" alt="piwik"/%3E%3C/p%3E%3C/noscript%3E%3C/object%3E'));
}
</script>
<!-- End Piwik Tag -->
<link rel="shortcut icon" href="_static/favicon.ico">

<!-- The "Fork me on github" ribbon -->
<img style="float: right; margin-bottom: -40px; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png" usemap="#ribbonmap"/>
<map name="ribbonmap">
    <area shape="poly" coords="15,0,148,-1,148,135" href="https://github.com/matplotlib/matplotlib" title="Fork me on GitHub" />
</map>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../index.html"><img src="../_static/logo2.png" border="0" alt="matplotlib"/></a>
</div>


    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="colorbar_api.html" title="colorbar"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="cm_api.html" title="cm (colormap)"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">home</a>|&nbsp;</li>
        <li><a href="../search.html">search</a>|&nbsp;</li>
        <li><a href="../examples/index.html">examples</a>|&nbsp;</li>
        <li><a href="../gallery.html">gallery</a>|&nbsp;</li>
        <li><a href="../contents.html">docs</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">The Matplotlib API</a> &raquo;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">collections</a><ul>
<li><a class="reference internal" href="#module-matplotlib.collections"><tt class="docutils literal"><span class="pre">matplotlib.collections</span></tt></a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="cm_api.html"
                        title="previous chapter">cm (colormap)</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="colorbar_api.html"
                        title="next chapter">colorbar</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/api/collections_api.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="collections">
<h1>collections<a class="headerlink" href="#collections" title="Permalink to this headline">¶</a></h1>
<p class="graphviz">
<img src="../_images/inheritance-356a477633a6d11e81cbab96e03a9237613028e4.png" alt="Inheritance diagram of matplotlib.collections" usemap="#inheritance829eaf436e" class="inheritance"/>
<map id="inheritance829eaf436e" name="inheritance829eaf436e">
<area shape="rect" id="node1" href="#matplotlib.collections.Collection" title="collections.Collection" alt="" coords="165,164,291,185"/>
<area shape="rect" id="node6" href="#matplotlib.collections.QuadMesh" title="collections.QuadMesh" alt="" coords="357,4,489,24"/>
<area shape="rect" id="node8" href="#matplotlib.collections.PolyCollection" title="collections.PolyCollection" alt="" coords="349,44,497,65"/>
<area shape="rect" id="node10" href="#matplotlib.collections.CircleCollection" title="collections.CircleCollection" alt="" coords="345,84,501,105"/>
<area shape="rect" id="node13" href="#matplotlib.collections.RegularPolyCollection" title="collections.RegularPolyCollection" alt="" coords="330,124,516,145"/>
<area shape="rect" id="node15" href="#matplotlib.collections.TriMesh" title="collections.TriMesh" alt="" coords="366,164,480,185"/>
<area shape="rect" id="node17" href="#matplotlib.collections.LineCollection" title="collections.LineCollection" alt="" coords="349,204,497,225"/>
<area shape="rect" id="node19" href="#matplotlib.collections.PathCollection" title="collections.PathCollection" alt="" coords="349,245,497,265"/>
<area shape="rect" id="node21" href="#matplotlib.collections.EllipseCollection" title="collections.EllipseCollection" alt="" coords="344,285,502,305"/>
<area shape="rect" id="node26" href="#matplotlib.collections.PatchCollection" title="collections.PatchCollection" alt="" coords="345,325,501,345"/>
<area shape="rect" id="node2" href="artist_api.html#matplotlib.artist.Artist" title="artist.Artist" alt="" coords="27,144,103,164"/>
<area shape="rect" id="node4" href="cm_api.html#matplotlib.cm.ScalarMappable" title="cm.ScalarMappable" alt="" coords="5,184,125,204"/>
<area shape="rect" id="node28" href="#matplotlib.collections.BrokenBarHCollection" title="collections.BrokenBarHCollection" alt="" coords="565,44,754,65"/>
<area shape="rect" id="node12" href="#matplotlib.collections.AsteriskPolygonCollection" title="collections.AsteriskPolygonCollection" alt="" coords="555,104,764,124"/>
<area shape="rect" id="node23" href="#matplotlib.collections.StarPolygonCollection" title="collections.StarPolygonCollection" alt="" coords="565,144,754,164"/>
</map>
</p>
<div class="section" id="module-matplotlib.collections">
<span id="matplotlib-collections"></span><h2><a class="reference internal" href="#module-matplotlib.collections" title="matplotlib.collections"><tt class="xref py py-mod docutils literal"><span class="pre">matplotlib.collections</span></tt></a><a class="headerlink" href="#module-matplotlib.collections" title="Permalink to this headline">¶</a></h2>
<p>Classes for the efficient drawing of large collections of objects that
share most properties, e.g. a large number of line segments or
polygons.</p>
<p>The classes are not meant to be as flexible as their single element
counterparts (e.g. you may not be able to select all line styles) but
they are meant to be fast for common use cases (e.g. a large set of solid
line segemnts)</p>
<dl class="class">
<dt id="matplotlib.collections.AsteriskPolygonCollection">
<em class="property">class </em><tt class="descclassname">matplotlib.collections.</tt><tt class="descname">AsteriskPolygonCollection</tt><big>(</big><em>numsides</em>, <em>rotation=0</em>, <em>sizes=(1</em>, <em>)</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.collections.AsteriskPolygonCollection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection" title="matplotlib.collections.RegularPolyCollection"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.collections.RegularPolyCollection</span></tt></a></p>
<p>Draw a collection of regular asterisks with <em>numsides</em> points.</p>
<dl class="docutils">
<dt><em>numsides</em></dt>
<dd>the number of sides of the polygon</dd>
<dt><em>rotation</em></dt>
<dd>the rotation of the polygon in radians</dd>
<dt><em>sizes</em></dt>
<dd><p class="first">gives the area of the circle circumscribing the
regular polygon in points^2</p>
<p>Valid Collection keyword arguments:</p>
<blockquote>
<div><ul class="simple">
<li><em>edgecolors</em>: None</li>
<li><em>facecolors</em>: None</li>
<li><em>linewidths</em>: None</li>
<li><em>antialiaseds</em>: None</li>
<li><em>offsets</em>: None</li>
<li><em>transOffset</em>: transforms.IdentityTransform()</li>
<li><em>norm</em>: None (optional for
<a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.cm.ScalarMappable</span></tt></a>)</li>
<li><em>cmap</em>: None (optional for
<a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.cm.ScalarMappable</span></tt></a>)</li>
</ul>
</div></blockquote>
<p><em>offsets</em> and <em>transOffset</em> are used to translate the patch after
rendering (default no offsets)</p>
<p class="last">If any of <em>edgecolors</em>, <em>facecolors</em>, <em>linewidths</em>, <em>antialiaseds</em>
are None, they default to their <tt class="xref py py-data docutils literal"><span class="pre">matplotlib.rcParams</span></tt> patch
setting, in sequence form.</p>
</dd>
</dl>
<p>Example: see <tt class="file docutils literal"><span class="pre">examples/dynamic_collection.py</span></tt> for
complete example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">facecolors</span> <span class="o">=</span> <span class="p">[</span><span class="n">cm</span><span class="o">.</span><span class="n">jet</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">20</span><span class="p">)]</span>
<span class="n">black</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="n">collection</span> <span class="o">=</span> <span class="n">RegularPolyCollection</span><span class="p">(</span>
    <span class="n">numsides</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="c"># a pentagon</span>
    <span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sizes</span><span class="o">=</span><span class="p">(</span><span class="mi">50</span><span class="p">,),</span>
    <span class="n">facecolors</span> <span class="o">=</span> <span class="n">facecolors</span><span class="p">,</span>
    <span class="n">edgecolors</span> <span class="o">=</span> <span class="p">(</span><span class="n">black</span><span class="p">,),</span>
    <span class="n">linewidths</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
    <span class="n">offsets</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">,</span>
    <span class="n">transOffset</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="matplotlib.collections.BrokenBarHCollection">
<em class="property">class </em><tt class="descclassname">matplotlib.collections.</tt><tt class="descname">BrokenBarHCollection</tt><big>(</big><em>xranges</em>, <em>yrange</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.collections.BrokenBarHCollection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.collections.PolyCollection" title="matplotlib.collections.PolyCollection"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.collections.PolyCollection</span></tt></a></p>
<p>A collection of horizontal bars spanning <em>yrange</em> with a sequence of
<em>xranges</em>.</p>
<dl class="docutils">
<dt><em>xranges</em></dt>
<dd>sequence of (<em>xmin</em>, <em>xwidth</em>)</dd>
<dt><em>yrange</em></dt>
<dd><p class="first"><em>ymin</em>, <em>ywidth</em></p>
<p>Valid Collection keyword arguments:</p>
<blockquote>
<div><ul class="simple">
<li><em>edgecolors</em>: None</li>
<li><em>facecolors</em>: None</li>
<li><em>linewidths</em>: None</li>
<li><em>antialiaseds</em>: None</li>
<li><em>offsets</em>: None</li>
<li><em>transOffset</em>: transforms.IdentityTransform()</li>
<li><em>norm</em>: None (optional for
<a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.cm.ScalarMappable</span></tt></a>)</li>
<li><em>cmap</em>: None (optional for
<a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.cm.ScalarMappable</span></tt></a>)</li>
</ul>
</div></blockquote>
<p><em>offsets</em> and <em>transOffset</em> are used to translate the patch after
rendering (default no offsets)</p>
<p class="last">If any of <em>edgecolors</em>, <em>facecolors</em>, <em>linewidths</em>, <em>antialiaseds</em>
are None, they default to their <tt class="xref py py-data docutils literal"><span class="pre">matplotlib.rcParams</span></tt> patch
setting, in sequence form.</p>
</dd>
</dl>
<dl class="staticmethod">
<dt id="matplotlib.collections.BrokenBarHCollection.span_where">
<em class="property">static </em><tt class="descname">span_where</tt><big>(</big><em>x</em>, <em>ymin</em>, <em>ymax</em>, <em>where</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.collections.BrokenBarHCollection.span_where" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a BrokenBarHCollection to plot horizontal bars from
over the regions in <em>x</em> where <em>where</em> is True.  The bars range
on the y-axis from <em>ymin</em> to <em>ymax</em></p>
<p>A <a class="reference internal" href="#matplotlib.collections.BrokenBarHCollection" title="matplotlib.collections.BrokenBarHCollection"><tt class="xref py py-class docutils literal"><span class="pre">BrokenBarHCollection</span></tt></a> is returned.  <em>kwargs</em> are
passed on to the collection.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.collections.CircleCollection">
<em class="property">class </em><tt class="descclassname">matplotlib.collections.</tt><tt class="descname">CircleCollection</tt><big>(</big><em>sizes</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.collections.CircleCollection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.collections.Collection" title="matplotlib.collections.Collection"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.collections.Collection</span></tt></a></p>
<p>A collection of circles, drawn using splines.</p>
<p><em>sizes</em>
Gives the area of the circle in points^2</p>
<p>Valid Collection keyword arguments:</p>
<blockquote>
<div><ul class="simple">
<li><em>edgecolors</em>: None</li>
<li><em>facecolors</em>: None</li>
<li><em>linewidths</em>: None</li>
<li><em>antialiaseds</em>: None</li>
<li><em>offsets</em>: None</li>
<li><em>transOffset</em>: transforms.IdentityTransform()</li>
<li><em>norm</em>: None (optional for
<a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.cm.ScalarMappable</span></tt></a>)</li>
<li><em>cmap</em>: None (optional for
<a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.cm.ScalarMappable</span></tt></a>)</li>
</ul>
</div></blockquote>
<p><em>offsets</em> and <em>transOffset</em> are used to translate the patch after
rendering (default no offsets)</p>
<p>If any of <em>edgecolors</em>, <em>facecolors</em>, <em>linewidths</em>, <em>antialiaseds</em>
are None, they default to their <tt class="xref py py-data docutils literal"><span class="pre">matplotlib.rcParams</span></tt> patch
setting, in sequence form.</p>
<dl class="method">
<dt id="matplotlib.collections.CircleCollection.draw">
<tt class="descname">draw</tt><big>(</big><em>artist</em>, <em>renderer</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.collections.CircleCollection.draw" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.CircleCollection.get_sizes">
<tt class="descname">get_sizes</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.CircleCollection.get_sizes" title="Permalink to this definition">¶</a></dt>
<dd><p>return sizes of circles</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.collections.Collection">
<em class="property">class </em><tt class="descclassname">matplotlib.collections.</tt><tt class="descname">Collection</tt><big>(</big><em>edgecolors=None</em>, <em>facecolors=None</em>, <em>linewidths=None</em>, <em>linestyles='solid'</em>, <em>antialiaseds=None</em>, <em>offsets=None</em>, <em>transOffset=None</em>, <em>norm=None</em>, <em>cmap=None</em>, <em>pickradius=5.0</em>, <em>hatch=None</em>, <em>urls=None</em>, <em>offset_position='screen'</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="artist_api.html#matplotlib.artist.Artist" title="matplotlib.artist.Artist"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.artist.Artist</span></tt></a>, <a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.cm.ScalarMappable</span></tt></a></p>
<p>Base class for Collections.  Must be subclassed to be usable.</p>
<p>All properties in a collection must be sequences or scalars;
if scalars, they will be converted to sequences.  The
property of the ith element of the collection is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">prop</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">props</span><span class="p">)]</span>
</pre></div>
</div>
<p>Keyword arguments and default values:</p>
<blockquote>
<div><ul class="simple">
<li><em>edgecolors</em>: None</li>
<li><em>facecolors</em>: None</li>
<li><em>linewidths</em>: None</li>
<li><em>antialiaseds</em>: None</li>
<li><em>offsets</em>: None</li>
<li><em>transOffset</em>: transforms.IdentityTransform()</li>
<li><em>offset_position</em>: &#8216;screen&#8217; (default) or &#8216;data&#8217;</li>
<li><em>norm</em>: None (optional for
<a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.cm.ScalarMappable</span></tt></a>)</li>
<li><em>cmap</em>: None (optional for
<a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.cm.ScalarMappable</span></tt></a>)</li>
<li><em>hatch</em>: None</li>
</ul>
</div></blockquote>
<p><em>offsets</em> and <em>transOffset</em> are used to translate the patch after
rendering (default no offsets).  If offset_position is &#8216;screen&#8217;
(default) the offset is applied after the master transform has
been applied, that is, the offsets are in screen coordinates.  If
offset_position is &#8216;data&#8217;, the offset is applied before the master
transform, i.e., the offsets are in data coordinates.</p>
<p>If any of <em>edgecolors</em>, <em>facecolors</em>, <em>linewidths</em>, <em>antialiaseds</em>
are None, they default to their <tt class="xref py py-data docutils literal"><span class="pre">matplotlib.rcParams</span></tt> patch
setting, in sequence form.</p>
<p>The use of <a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><tt class="xref py py-class docutils literal"><span class="pre">ScalarMappable</span></tt></a> is optional.  If
the <a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><tt class="xref py py-class docutils literal"><span class="pre">ScalarMappable</span></tt></a> matrix _A is not None
(ie a call to set_array has been made), at draw time a call to
scalar mappable will be made to set the face colors.</p>
<p>Create a Collection</p>
<p>%(Collection)s</p>
<dl class="method">
<dt id="matplotlib.collections.Collection.contains">
<tt class="descname">contains</tt><big>(</big><em>mouseevent</em><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether the mouse event occurred in the collection.</p>
<p>Returns True | False, <tt class="docutils literal"><span class="pre">dict(ind=itemlist)</span></tt>, where every
item in itemlist contains the event.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.draw">
<tt class="descname">draw</tt><big>(</big><em>artist</em>, <em>renderer</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.draw" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.get_dashes">
<tt class="descname">get_dashes</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.get_dashes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.get_datalim">
<tt class="descname">get_datalim</tt><big>(</big><em>transData</em><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.get_datalim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.get_edgecolor">
<tt class="descname">get_edgecolor</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.get_edgecolor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.get_edgecolors">
<tt class="descname">get_edgecolors</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.get_edgecolors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.get_facecolor">
<tt class="descname">get_facecolor</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.get_facecolor" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.get_facecolors">
<tt class="descname">get_facecolors</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.get_facecolors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.get_hatch">
<tt class="descname">get_hatch</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.get_hatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current hatching pattern</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.get_linestyle">
<tt class="descname">get_linestyle</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.get_linestyle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.get_linestyles">
<tt class="descname">get_linestyles</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.get_linestyles" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.get_linewidth">
<tt class="descname">get_linewidth</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.get_linewidth" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.get_linewidths">
<tt class="descname">get_linewidths</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.get_linewidths" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.get_offset_position">
<tt class="descname">get_offset_position</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.get_offset_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns how offsets are applied for the collection.  If
<em>offset_position</em> is &#8216;screen&#8217;, the offset is applied after the
master transform has been applied, that is, the offsets are in
screen coordinates.  If offset_position is &#8216;data&#8217;, the offset
is applied before the master transform, i.e., the offsets are
in data coordinates.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.get_offset_transform">
<tt class="descname">get_offset_transform</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.get_offset_transform" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.get_offsets">
<tt class="descname">get_offsets</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.get_offsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the offsets for the collection.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.get_paths">
<tt class="descname">get_paths</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.get_paths" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.get_pickradius">
<tt class="descname">get_pickradius</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.get_pickradius" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.get_transforms">
<tt class="descname">get_transforms</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.get_transforms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.get_urls">
<tt class="descname">get_urls</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.get_urls" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.get_window_extent">
<tt class="descname">get_window_extent</tt><big>(</big><em>renderer</em><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.get_window_extent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.set_alpha">
<tt class="descname">set_alpha</tt><big>(</big><em>alpha</em><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.set_alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the alpha tranparencies of the collection.  <em>alpha</em> must be
a float or <em>None</em>.</p>
<p>ACCEPTS: float or None</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.set_antialiased">
<tt class="descname">set_antialiased</tt><big>(</big><em>aa</em><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.set_antialiased" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the antialiasing state for rendering.</p>
<p>ACCEPTS: Boolean or sequence of booleans</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.set_antialiaseds">
<tt class="descname">set_antialiaseds</tt><big>(</big><em>aa</em><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.set_antialiaseds" title="Permalink to this definition">¶</a></dt>
<dd><p>alias for set_antialiased</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.set_color">
<tt class="descname">set_color</tt><big>(</big><em>c</em><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.set_color" title="Permalink to this definition">¶</a></dt>
<dd><p>Set both the edgecolor and the facecolor.</p>
<p>ACCEPTS: matplotlib color arg or sequence of rgba tuples</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#matplotlib.collections.Collection.set_facecolor" title="matplotlib.collections.Collection.set_facecolor"><tt class="xref py py-meth docutils literal"><span class="pre">set_facecolor()</span></tt></a>, <a class="reference internal" href="#matplotlib.collections.Collection.set_edgecolor" title="matplotlib.collections.Collection.set_edgecolor"><tt class="xref py py-meth docutils literal"><span class="pre">set_edgecolor()</span></tt></a></dt>
<dd>For setting the edge or face color individually.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.set_dashes">
<tt class="descname">set_dashes</tt><big>(</big><em>ls</em><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.set_dashes" title="Permalink to this definition">¶</a></dt>
<dd><p>alias for set_linestyle</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.set_edgecolor">
<tt class="descname">set_edgecolor</tt><big>(</big><em>c</em><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.set_edgecolor" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the edgecolor(s) of the collection. <em>c</em> can be a
matplotlib color arg (all patches have same color), or a
sequence of rgba tuples; if it is a sequence the patches will
cycle through the sequence.</p>
<p>If <em>c</em> is &#8216;face&#8217;, the edge color will always be the same as
the face color.  If it is &#8216;none&#8217;, the patch boundary will not
be drawn.</p>
<p>ACCEPTS: matplotlib color arg or sequence of rgba tuples</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.set_edgecolors">
<tt class="descname">set_edgecolors</tt><big>(</big><em>c</em><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.set_edgecolors" title="Permalink to this definition">¶</a></dt>
<dd><p>alias for set_edgecolor</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.set_facecolor">
<tt class="descname">set_facecolor</tt><big>(</big><em>c</em><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.set_facecolor" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the facecolor(s) of the collection.  <em>c</em> can be a
matplotlib color arg (all patches have same color), or a
sequence of rgba tuples; if it is a sequence the patches will
cycle through the sequence.</p>
<p>If <em>c</em> is &#8216;none&#8217;, the patch will not be filled.</p>
<p>ACCEPTS: matplotlib color arg or sequence of rgba tuples</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.set_facecolors">
<tt class="descname">set_facecolors</tt><big>(</big><em>c</em><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.set_facecolors" title="Permalink to this definition">¶</a></dt>
<dd><p>alias for set_facecolor</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.set_hatch">
<tt class="descname">set_hatch</tt><big>(</big><em>hatch</em><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.set_hatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the hatching pattern</p>
<p><em>hatch</em> can be one of:</p>
<div class="highlight-python"><pre>/   - diagonal hatching
\   - back diagonal
|   - vertical
-   - horizontal
+   - crossed
x   - crossed diagonal
o   - small circle
O   - large circle
.   - dots
*   - stars</pre>
</div>
<p>Letters can be combined, in which case all the specified
hatchings are done.  If same letter repeats, it increases the
density of hatching of that pattern.</p>
<p>Hatching is supported in the PostScript, PDF, SVG and Agg
backends only.</p>
<p>Unlike other properties such as linewidth and colors, hatching
can only be specified for the collection as a whole, not separately
for each member.</p>
<p>ACCEPTS: [ &#8216;/&#8217; | &#8216;\&#8217; | &#8216;|&#8217; | &#8216;-&#8216; | &#8216;+&#8217; | &#8216;x&#8217; | &#8216;o&#8217; | &#8216;O&#8217; | &#8216;.&#8217; | &#8216;*&#8217; ]</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.set_linestyle">
<tt class="descname">set_linestyle</tt><big>(</big><em>ls</em><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.set_linestyle" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the linestyle(s) for the collection.</p>
<p>ACCEPTS: [&#8216;solid&#8217; | &#8216;dashed&#8217;, &#8216;dashdot&#8217;, &#8216;dotted&#8217; |
(offset, on-off-dash-seq) ]</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.set_linestyles">
<tt class="descname">set_linestyles</tt><big>(</big><em>ls</em><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.set_linestyles" title="Permalink to this definition">¶</a></dt>
<dd><p>alias for set_linestyle</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.set_linewidth">
<tt class="descname">set_linewidth</tt><big>(</big><em>lw</em><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.set_linewidth" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the linewidth(s) for the collection.  <em>lw</em> can be a scalar
or a sequence; if it is a sequence the patches will cycle
through the sequence</p>
<p>ACCEPTS: float or sequence of floats</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.set_linewidths">
<tt class="descname">set_linewidths</tt><big>(</big><em>lw</em><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.set_linewidths" title="Permalink to this definition">¶</a></dt>
<dd><p>alias for set_linewidth</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.set_lw">
<tt class="descname">set_lw</tt><big>(</big><em>lw</em><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.set_lw" title="Permalink to this definition">¶</a></dt>
<dd><p>alias for set_linewidth</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.set_offset_position">
<tt class="descname">set_offset_position</tt><big>(</big><em>offset_position</em><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.set_offset_position" title="Permalink to this definition">¶</a></dt>
<dd><p>Set how offsets are applied.  If <em>offset_position</em> is &#8216;screen&#8217;
(default) the offset is applied after the master transform has
been applied, that is, the offsets are in screen coordinates.
If offset_position is &#8216;data&#8217;, the offset is applied before the
master transform, i.e., the offsets are in data coordinates.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.set_offsets">
<tt class="descname">set_offsets</tt><big>(</big><em>offsets</em><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.set_offsets" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the offsets for the collection.  <em>offsets</em> can be a scalar
or a sequence.</p>
<p>ACCEPTS: float or sequence of floats</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.set_paths">
<tt class="descname">set_paths</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.set_paths" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.set_pickradius">
<tt class="descname">set_pickradius</tt><big>(</big><em>pr</em><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.set_pickradius" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.set_urls">
<tt class="descname">set_urls</tt><big>(</big><em>urls</em><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.set_urls" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.update_from">
<tt class="descname">update_from</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.update_from" title="Permalink to this definition">¶</a></dt>
<dd><p>copy properties from other to self</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.collections.Collection.update_scalarmappable">
<tt class="descname">update_scalarmappable</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.Collection.update_scalarmappable" title="Permalink to this definition">¶</a></dt>
<dd><p>If the scalar mappable array is not none, update colors
from scalar data</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.collections.Collection.zorder">
<tt class="descname">zorder</tt><em class="property"> = 1</em><a class="headerlink" href="#matplotlib.collections.Collection.zorder" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.collections.EllipseCollection">
<em class="property">class </em><tt class="descclassname">matplotlib.collections.</tt><tt class="descname">EllipseCollection</tt><big>(</big><em>widths</em>, <em>heights</em>, <em>angles</em>, <em>units='points'</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.collections.EllipseCollection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.collections.Collection" title="matplotlib.collections.Collection"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.collections.Collection</span></tt></a></p>
<p>A collection of ellipses, drawn using splines.</p>
<dl class="docutils">
<dt><em>widths</em>: sequence</dt>
<dd>lengths of first axes (e.g., major axis lengths)</dd>
<dt><em>heights</em>: sequence</dt>
<dd>lengths of second axes</dd>
<dt><em>angles</em>: sequence</dt>
<dd>angles of first axes, degrees CCW from the X-axis</dd>
</dl>
<p><em>units</em>: [&#8216;points&#8217; | &#8216;inches&#8217; | &#8216;dots&#8217; | &#8216;width&#8217; | &#8216;height&#8217;
| &#8216;x&#8217; | &#8216;y&#8217; | &#8216;xy&#8217;]</p>
<blockquote>
<div>units in which majors and minors are given; &#8216;width&#8217; and
&#8216;height&#8217; refer to the dimensions of the axes, while &#8216;x&#8217;
and &#8216;y&#8217; refer to the <em>offsets</em> data units. &#8216;xy&#8217; differs
from all others in that the angle as plotted varies with
the aspect ratio, and equals the specified angle only when
the aspect ratio is unity.  Hence it behaves the same as
the <a class="reference internal" href="artist_api.html#matplotlib.patches.Ellipse" title="matplotlib.patches.Ellipse"><tt class="xref py py-class docutils literal"><span class="pre">Ellipse</span></tt></a> with
axes.transData as its transform.</div></blockquote>
<p>Additional kwargs inherited from the base <a class="reference internal" href="#matplotlib.collections.Collection" title="matplotlib.collections.Collection"><tt class="xref py py-class docutils literal"><span class="pre">Collection</span></tt></a>:</p>
<blockquote>
<div><p>Valid Collection keyword arguments:</p>
<blockquote>
<div><ul class="simple">
<li><em>edgecolors</em>: None</li>
<li><em>facecolors</em>: None</li>
<li><em>linewidths</em>: None</li>
<li><em>antialiaseds</em>: None</li>
<li><em>offsets</em>: None</li>
<li><em>transOffset</em>: transforms.IdentityTransform()</li>
<li><em>norm</em>: None (optional for
<a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.cm.ScalarMappable</span></tt></a>)</li>
<li><em>cmap</em>: None (optional for
<a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.cm.ScalarMappable</span></tt></a>)</li>
</ul>
</div></blockquote>
<p><em>offsets</em> and <em>transOffset</em> are used to translate the patch after
rendering (default no offsets)</p>
<p>If any of <em>edgecolors</em>, <em>facecolors</em>, <em>linewidths</em>, <em>antialiaseds</em>
are None, they default to their <tt class="xref py py-data docutils literal"><span class="pre">matplotlib.rcParams</span></tt> patch
setting, in sequence form.</p>
</div></blockquote>
<dl class="method">
<dt id="matplotlib.collections.EllipseCollection.draw">
<tt class="descname">draw</tt><big>(</big><em>artist</em>, <em>renderer</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.collections.EllipseCollection.draw" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.collections.LineCollection">
<em class="property">class </em><tt class="descclassname">matplotlib.collections.</tt><tt class="descname">LineCollection</tt><big>(</big><em>segments</em>, <em>linewidths=None</em>, <em>colors=None</em>, <em>antialiaseds=None</em>, <em>linestyles='solid'</em>, <em>offsets=None</em>, <em>transOffset=None</em>, <em>norm=None</em>, <em>cmap=None</em>, <em>pickradius=5</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.collections.LineCollection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.collections.Collection" title="matplotlib.collections.Collection"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.collections.Collection</span></tt></a></p>
<p>All parameters must be sequences or scalars; if scalars, they will
be converted to sequences.  The property of the ith line
segment is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">prop</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">props</span><span class="p">)]</span>
</pre></div>
</div>
<p>i.e., the properties cycle if the <tt class="docutils literal"><span class="pre">len</span></tt> of props is less than the
number of segments.</p>
<dl class="docutils">
<dt><em>segments</em></dt>
<dd><p class="first">a sequence of (<em>line0</em>, <em>line1</em>, <em>line2</em>), where:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">linen</span> <span class="o">=</span> <span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">),</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="o">...</span> <span class="p">(</span><span class="n">xm</span><span class="p">,</span> <span class="n">ym</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">or the equivalent numpy array with two columns. Each line
can be a different length.</p>
</dd>
<dt><em>colors</em></dt>
<dd>must be a sequence of RGBA tuples (eg arbitrary color
strings, etc, not allowed).</dd>
<dt><em>antialiaseds</em></dt>
<dd>must be a sequence of ones or zeros</dd>
<dt><em>linestyles</em> [ &#8216;solid&#8217; | &#8216;dashed&#8217; | &#8216;dashdot&#8217; | &#8216;dotted&#8217; ]</dt>
<dd><p class="first">a string or dash tuple. The dash tuple is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">onoffseq</span><span class="p">),</span>
</pre></div>
</div>
<p class="last">where <em>onoffseq</em> is an even length tuple of on and off ink
in points.</p>
</dd>
</dl>
<p>If <em>linewidths</em>, <em>colors</em>, or <em>antialiaseds</em> is None, they
default to their rcParams setting, in sequence form.</p>
<p>If <em>offsets</em> and <em>transOffset</em> are not None, then
<em>offsets</em> are transformed by <em>transOffset</em> and applied after
the segments have been transformed to display coordinates.</p>
<p>If <em>offsets</em> is not None but <em>transOffset</em> is None, then the
<em>offsets</em> are added to the segments before any transformation.
In this case, a single offset can be specified as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">offsets</span><span class="o">=</span><span class="p">(</span><span class="n">xo</span><span class="p">,</span><span class="n">yo</span><span class="p">)</span>
</pre></div>
</div>
<p>and this value will be added cumulatively to each successive
segment, so as to produce a set of successively offset curves.</p>
<dl class="docutils">
<dt><em>norm</em></dt>
<dd>None (optional for <a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.cm.ScalarMappable</span></tt></a>)</dd>
<dt><em>cmap</em></dt>
<dd>None (optional for <a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.cm.ScalarMappable</span></tt></a>)</dd>
</dl>
<p><em>pickradius</em> is the tolerance for mouse clicks picking a line.
The default is 5 pt.</p>
<p>The use of <a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><tt class="xref py py-class docutils literal"><span class="pre">ScalarMappable</span></tt></a> is optional.
If the <a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><tt class="xref py py-class docutils literal"><span class="pre">ScalarMappable</span></tt></a> array
<tt class="xref py py-attr docutils literal"><span class="pre">_A</span></tt> is not None (ie a call to
<a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable.set_array" title="matplotlib.cm.ScalarMappable.set_array"><tt class="xref py py-meth docutils literal"><span class="pre">set_array()</span></tt></a> has been made), at
draw time a call to scalar mappable will be made to set the colors.</p>
<dl class="method">
<dt id="matplotlib.collections.LineCollection.color">
<tt class="descname">color</tt><big>(</big><em>c</em><big>)</big><a class="headerlink" href="#matplotlib.collections.LineCollection.color" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the color(s) of the line collection.  <em>c</em> can be a
matplotlib color arg (all patches have same color), or a
sequence or rgba tuples; if it is a sequence the patches will
cycle through the sequence</p>
<p>ACCEPTS: matplotlib color arg or sequence of rgba tuples</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.collections.LineCollection.get_color">
<tt class="descname">get_color</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.LineCollection.get_color" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.LineCollection.get_colors">
<tt class="descname">get_colors</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.LineCollection.get_colors" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.LineCollection.set_color">
<tt class="descname">set_color</tt><big>(</big><em>c</em><big>)</big><a class="headerlink" href="#matplotlib.collections.LineCollection.set_color" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the color(s) of the line collection.  <em>c</em> can be a
matplotlib color arg (all patches have same color), or a
sequence or rgba tuples; if it is a sequence the patches will
cycle through the sequence.</p>
<p>ACCEPTS: matplotlib color arg or sequence of rgba tuples</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.collections.LineCollection.set_paths">
<tt class="descname">set_paths</tt><big>(</big><em>segments</em><big>)</big><a class="headerlink" href="#matplotlib.collections.LineCollection.set_paths" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.LineCollection.set_segments">
<tt class="descname">set_segments</tt><big>(</big><em>segments</em><big>)</big><a class="headerlink" href="#matplotlib.collections.LineCollection.set_segments" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.LineCollection.set_verts">
<tt class="descname">set_verts</tt><big>(</big><em>segments</em><big>)</big><a class="headerlink" href="#matplotlib.collections.LineCollection.set_verts" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.collections.LineCollection.zorder">
<tt class="descname">zorder</tt><em class="property"> = 2</em><a class="headerlink" href="#matplotlib.collections.LineCollection.zorder" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.collections.PatchCollection">
<em class="property">class </em><tt class="descclassname">matplotlib.collections.</tt><tt class="descname">PatchCollection</tt><big>(</big><em>patches</em>, <em>match_original=False</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.collections.PatchCollection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.collections.Collection" title="matplotlib.collections.Collection"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.collections.Collection</span></tt></a></p>
<p>A generic collection of patches.</p>
<p>This makes it easier to assign a color map to a heterogeneous
collection of patches.</p>
<p>This also may improve plotting speed, since PatchCollection will
draw faster than a large number of patches.</p>
<dl class="docutils">
<dt><em>patches</em></dt>
<dd>a sequence of Patch objects.  This list may include
a heterogeneous assortment of different patch types.</dd>
<dt><em>match_original</em></dt>
<dd>If True, use the colors and linewidths of the original
patches.  If False, new colors may be assigned by
providing the standard collection arguments, facecolor,
edgecolor, linewidths, norm or cmap.</dd>
</dl>
<p>If any of <em>edgecolors</em>, <em>facecolors</em>, <em>linewidths</em>,
<em>antialiaseds</em> are None, they default to their
<tt class="xref py py-data docutils literal"><span class="pre">matplotlib.rcParams</span></tt> patch setting, in sequence form.</p>
<p>The use of <a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><tt class="xref py py-class docutils literal"><span class="pre">ScalarMappable</span></tt></a> is optional.
If the <a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><tt class="xref py py-class docutils literal"><span class="pre">ScalarMappable</span></tt></a> matrix _A is not
None (ie a call to set_array has been made), at draw time a
call to scalar mappable will be made to set the face colors.</p>
<dl class="method">
<dt id="matplotlib.collections.PatchCollection.set_paths">
<tt class="descname">set_paths</tt><big>(</big><em>patches</em><big>)</big><a class="headerlink" href="#matplotlib.collections.PatchCollection.set_paths" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.collections.PathCollection">
<em class="property">class </em><tt class="descclassname">matplotlib.collections.</tt><tt class="descname">PathCollection</tt><big>(</big><em>paths</em>, <em>sizes=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.collections.PathCollection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.collections.Collection" title="matplotlib.collections.Collection"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.collections.Collection</span></tt></a></p>
<p>This is the most basic <a class="reference internal" href="#matplotlib.collections.Collection" title="matplotlib.collections.Collection"><tt class="xref py py-class docutils literal"><span class="pre">Collection</span></tt></a> subclass.</p>
<p><em>paths</em> is a sequence of <a class="reference internal" href="path_api.html#matplotlib.path.Path" title="matplotlib.path.Path"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.path.Path</span></tt></a>
instances.</p>
<blockquote>
<div><p>Valid Collection keyword arguments:</p>
<blockquote>
<div><ul class="simple">
<li><em>edgecolors</em>: None</li>
<li><em>facecolors</em>: None</li>
<li><em>linewidths</em>: None</li>
<li><em>antialiaseds</em>: None</li>
<li><em>offsets</em>: None</li>
<li><em>transOffset</em>: transforms.IdentityTransform()</li>
<li><em>norm</em>: None (optional for
<a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.cm.ScalarMappable</span></tt></a>)</li>
<li><em>cmap</em>: None (optional for
<a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.cm.ScalarMappable</span></tt></a>)</li>
</ul>
</div></blockquote>
<p><em>offsets</em> and <em>transOffset</em> are used to translate the patch after
rendering (default no offsets)</p>
<p>If any of <em>edgecolors</em>, <em>facecolors</em>, <em>linewidths</em>, <em>antialiaseds</em>
are None, they default to their <tt class="xref py py-data docutils literal"><span class="pre">matplotlib.rcParams</span></tt> patch
setting, in sequence form.</p>
</div></blockquote>
<dl class="method">
<dt id="matplotlib.collections.PathCollection.draw">
<tt class="descname">draw</tt><big>(</big><em>artist</em>, <em>renderer</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.collections.PathCollection.draw" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.PathCollection.get_paths">
<tt class="descname">get_paths</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.PathCollection.get_paths" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.PathCollection.get_sizes">
<tt class="descname">get_sizes</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.PathCollection.get_sizes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.PathCollection.set_paths">
<tt class="descname">set_paths</tt><big>(</big><em>paths</em><big>)</big><a class="headerlink" href="#matplotlib.collections.PathCollection.set_paths" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.collections.PolyCollection">
<em class="property">class </em><tt class="descclassname">matplotlib.collections.</tt><tt class="descname">PolyCollection</tt><big>(</big><em>verts</em>, <em>sizes=None</em>, <em>closed=True</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.collections.PolyCollection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.collections.Collection" title="matplotlib.collections.Collection"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.collections.Collection</span></tt></a></p>
<p><em>verts</em> is a sequence of ( <em>verts0</em>, <em>verts1</em>, ...) where
<em>verts_i</em> is a sequence of <em>xy</em> tuples of vertices, or an
equivalent <tt class="xref py py-mod docutils literal"><span class="pre">numpy</span></tt> array of shape (<em>nv</em>, 2).</p>
<p><em>sizes</em> is <em>None</em> (default) or a sequence of floats that
scale the corresponding <em>verts_i</em>.  The scaling is applied
before the Artist master transform; if the latter is an identity
transform, then the overall scaling is such that if
<em>verts_i</em> specify a unit square, then <em>sizes_i</em> is the area
of that square in points^2.
If len(<em>sizes</em>) &lt; <em>nv</em>, the additional values will be
taken cyclically from the array.</p>
<p><em>closed</em>, when <em>True</em>, will explicitly close the polygon.</p>
<blockquote>
<div><p>Valid Collection keyword arguments:</p>
<blockquote>
<div><ul class="simple">
<li><em>edgecolors</em>: None</li>
<li><em>facecolors</em>: None</li>
<li><em>linewidths</em>: None</li>
<li><em>antialiaseds</em>: None</li>
<li><em>offsets</em>: None</li>
<li><em>transOffset</em>: transforms.IdentityTransform()</li>
<li><em>norm</em>: None (optional for
<a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.cm.ScalarMappable</span></tt></a>)</li>
<li><em>cmap</em>: None (optional for
<a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.cm.ScalarMappable</span></tt></a>)</li>
</ul>
</div></blockquote>
<p><em>offsets</em> and <em>transOffset</em> are used to translate the patch after
rendering (default no offsets)</p>
<p>If any of <em>edgecolors</em>, <em>facecolors</em>, <em>linewidths</em>, <em>antialiaseds</em>
are None, they default to their <tt class="xref py py-data docutils literal"><span class="pre">matplotlib.rcParams</span></tt> patch
setting, in sequence form.</p>
</div></blockquote>
<dl class="method">
<dt id="matplotlib.collections.PolyCollection.draw">
<tt class="descname">draw</tt><big>(</big><em>artist</em>, <em>renderer</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.collections.PolyCollection.draw" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.PolyCollection.set_paths">
<tt class="descname">set_paths</tt><big>(</big><em>verts</em>, <em>closed=True</em><big>)</big><a class="headerlink" href="#matplotlib.collections.PolyCollection.set_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>This allows one to delay initialization of the vertices.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.collections.PolyCollection.set_verts">
<tt class="descname">set_verts</tt><big>(</big><em>verts</em>, <em>closed=True</em><big>)</big><a class="headerlink" href="#matplotlib.collections.PolyCollection.set_verts" title="Permalink to this definition">¶</a></dt>
<dd><p>This allows one to delay initialization of the vertices.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.collections.QuadMesh">
<em class="property">class </em><tt class="descclassname">matplotlib.collections.</tt><tt class="descname">QuadMesh</tt><big>(</big><em>meshWidth</em>, <em>meshHeight</em>, <em>coordinates</em>, <em>antialiased=True</em>, <em>shading='flat'</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.collections.QuadMesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.collections.Collection" title="matplotlib.collections.Collection"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.collections.Collection</span></tt></a></p>
<p>Class for the efficient drawing of a quadrilateral mesh.</p>
<p>A quadrilateral mesh consists of a grid of vertices. The
dimensions of this array are (<em>meshWidth</em> + 1, <em>meshHeight</em> +
1). Each vertex in the mesh has a different set of &#8220;mesh
coordinates&#8221; representing its position in the topology of the
mesh. For any values (<em>m</em>, <em>n</em>) such that 0 &lt;= <em>m</em> &lt;= <em>meshWidth</em>
and 0 &lt;= <em>n</em> &lt;= <em>meshHeight</em>, the vertices at mesh coordinates
(<em>m</em>, <em>n</em>), (<em>m</em>, <em>n</em> + 1), (<em>m</em> + 1, <em>n</em> + 1), and (<em>m</em> + 1, <em>n</em>)
form one of the quadrilaterals in the mesh. There are thus
(<em>meshWidth</em> * <em>meshHeight</em>) quadrilaterals in the mesh.  The mesh
need not be regular and the polygons need not be convex.</p>
<p>A quadrilateral mesh is represented by a (2 x ((<em>meshWidth</em> + 1) *
(<em>meshHeight</em> + 1))) numpy array <em>coordinates</em>, where each row is
the <em>x</em> and <em>y</em> coordinates of one of the vertices.  To define the
function that maps from a data point to its corresponding color,
use the <tt class="xref py py-meth docutils literal"><span class="pre">set_cmap()</span></tt> method.  Each of these arrays is indexed in
row-major order by the mesh coordinates of the vertex (or the mesh
coordinates of the lower left vertex, in the case of the
colors).</p>
<p>For example, the first entry in <em>coordinates</em> is the
coordinates of the vertex at mesh coordinates (0, 0), then the one
at (0, 1), then at (0, 2) .. (0, meshWidth), (1, 0), (1, 1), and
so on.</p>
<p><em>shading</em> may be &#8216;flat&#8217;, or &#8216;gouraud&#8217;</p>
<dl class="staticmethod">
<dt id="matplotlib.collections.QuadMesh.convert_mesh_to_paths">
<em class="property">static </em><tt class="descname">convert_mesh_to_paths</tt><big>(</big><em>meshWidth</em>, <em>meshHeight</em>, <em>coordinates</em><big>)</big><a class="headerlink" href="#matplotlib.collections.QuadMesh.convert_mesh_to_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a given mesh into a sequence of
<a class="reference internal" href="path_api.html#matplotlib.path.Path" title="matplotlib.path.Path"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.path.Path</span></tt></a> objects for easier rendering by
backends that do not directly support quadmeshes.</p>
<p>This function is primarily of use to backend implementers.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.collections.QuadMesh.convert_mesh_to_triangles">
<tt class="descname">convert_mesh_to_triangles</tt><big>(</big><em>meshWidth</em>, <em>meshHeight</em>, <em>coordinates</em><big>)</big><a class="headerlink" href="#matplotlib.collections.QuadMesh.convert_mesh_to_triangles" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a given mesh into a sequence of triangles, each point
with its own color.  This is useful for experiments using
<tt class="xref py py-obj docutils literal"><span class="pre">draw_qouraud_triangle</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.collections.QuadMesh.draw">
<tt class="descname">draw</tt><big>(</big><em>artist</em>, <em>renderer</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.collections.QuadMesh.draw" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.QuadMesh.get_datalim">
<tt class="descname">get_datalim</tt><big>(</big><em>transData</em><big>)</big><a class="headerlink" href="#matplotlib.collections.QuadMesh.get_datalim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.QuadMesh.get_paths">
<tt class="descname">get_paths</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.QuadMesh.get_paths" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.QuadMesh.set_paths">
<tt class="descname">set_paths</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.QuadMesh.set_paths" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.collections.RegularPolyCollection">
<em class="property">class </em><tt class="descclassname">matplotlib.collections.</tt><tt class="descname">RegularPolyCollection</tt><big>(</big><em>numsides</em>, <em>rotation=0</em>, <em>sizes=(1</em>, <em>)</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.collections.RegularPolyCollection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.collections.Collection" title="matplotlib.collections.Collection"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.collections.Collection</span></tt></a></p>
<p>Draw a collection of regular polygons with <em>numsides</em>.</p>
<dl class="docutils">
<dt><em>numsides</em></dt>
<dd>the number of sides of the polygon</dd>
<dt><em>rotation</em></dt>
<dd>the rotation of the polygon in radians</dd>
<dt><em>sizes</em></dt>
<dd><p class="first">gives the area of the circle circumscribing the
regular polygon in points^2</p>
<p>Valid Collection keyword arguments:</p>
<blockquote>
<div><ul class="simple">
<li><em>edgecolors</em>: None</li>
<li><em>facecolors</em>: None</li>
<li><em>linewidths</em>: None</li>
<li><em>antialiaseds</em>: None</li>
<li><em>offsets</em>: None</li>
<li><em>transOffset</em>: transforms.IdentityTransform()</li>
<li><em>norm</em>: None (optional for
<a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.cm.ScalarMappable</span></tt></a>)</li>
<li><em>cmap</em>: None (optional for
<a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.cm.ScalarMappable</span></tt></a>)</li>
</ul>
</div></blockquote>
<p><em>offsets</em> and <em>transOffset</em> are used to translate the patch after
rendering (default no offsets)</p>
<p class="last">If any of <em>edgecolors</em>, <em>facecolors</em>, <em>linewidths</em>, <em>antialiaseds</em>
are None, they default to their <tt class="xref py py-data docutils literal"><span class="pre">matplotlib.rcParams</span></tt> patch
setting, in sequence form.</p>
</dd>
</dl>
<p>Example: see <tt class="file docutils literal"><span class="pre">examples/dynamic_collection.py</span></tt> for
complete example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">facecolors</span> <span class="o">=</span> <span class="p">[</span><span class="n">cm</span><span class="o">.</span><span class="n">jet</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">20</span><span class="p">)]</span>
<span class="n">black</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="n">collection</span> <span class="o">=</span> <span class="n">RegularPolyCollection</span><span class="p">(</span>
    <span class="n">numsides</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="c"># a pentagon</span>
    <span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sizes</span><span class="o">=</span><span class="p">(</span><span class="mi">50</span><span class="p">,),</span>
    <span class="n">facecolors</span> <span class="o">=</span> <span class="n">facecolors</span><span class="p">,</span>
    <span class="n">edgecolors</span> <span class="o">=</span> <span class="p">(</span><span class="n">black</span><span class="p">,),</span>
    <span class="n">linewidths</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
    <span class="n">offsets</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">,</span>
    <span class="n">transOffset</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>
</div>
<dl class="method">
<dt id="matplotlib.collections.RegularPolyCollection.draw">
<tt class="descname">draw</tt><big>(</big><em>artist</em>, <em>renderer</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.collections.RegularPolyCollection.draw" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.RegularPolyCollection.get_numsides">
<tt class="descname">get_numsides</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.RegularPolyCollection.get_numsides" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.RegularPolyCollection.get_rotation">
<tt class="descname">get_rotation</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.RegularPolyCollection.get_rotation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.RegularPolyCollection.get_sizes">
<tt class="descname">get_sizes</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.RegularPolyCollection.get_sizes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.collections.StarPolygonCollection">
<em class="property">class </em><tt class="descclassname">matplotlib.collections.</tt><tt class="descname">StarPolygonCollection</tt><big>(</big><em>numsides</em>, <em>rotation=0</em>, <em>sizes=(1</em>, <em>)</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.collections.StarPolygonCollection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.collections.RegularPolyCollection" title="matplotlib.collections.RegularPolyCollection"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.collections.RegularPolyCollection</span></tt></a></p>
<p>Draw a collection of regular stars with <em>numsides</em> points.</p>
<dl class="docutils">
<dt><em>numsides</em></dt>
<dd>the number of sides of the polygon</dd>
<dt><em>rotation</em></dt>
<dd>the rotation of the polygon in radians</dd>
<dt><em>sizes</em></dt>
<dd><p class="first">gives the area of the circle circumscribing the
regular polygon in points^2</p>
<p>Valid Collection keyword arguments:</p>
<blockquote>
<div><ul class="simple">
<li><em>edgecolors</em>: None</li>
<li><em>facecolors</em>: None</li>
<li><em>linewidths</em>: None</li>
<li><em>antialiaseds</em>: None</li>
<li><em>offsets</em>: None</li>
<li><em>transOffset</em>: transforms.IdentityTransform()</li>
<li><em>norm</em>: None (optional for
<a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.cm.ScalarMappable</span></tt></a>)</li>
<li><em>cmap</em>: None (optional for
<a class="reference internal" href="cm_api.html#matplotlib.cm.ScalarMappable" title="matplotlib.cm.ScalarMappable"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.cm.ScalarMappable</span></tt></a>)</li>
</ul>
</div></blockquote>
<p><em>offsets</em> and <em>transOffset</em> are used to translate the patch after
rendering (default no offsets)</p>
<p class="last">If any of <em>edgecolors</em>, <em>facecolors</em>, <em>linewidths</em>, <em>antialiaseds</em>
are None, they default to their <tt class="xref py py-data docutils literal"><span class="pre">matplotlib.rcParams</span></tt> patch
setting, in sequence form.</p>
</dd>
</dl>
<p>Example: see <tt class="file docutils literal"><span class="pre">examples/dynamic_collection.py</span></tt> for
complete example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">facecolors</span> <span class="o">=</span> <span class="p">[</span><span class="n">cm</span><span class="o">.</span><span class="n">jet</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">20</span><span class="p">)]</span>
<span class="n">black</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="n">collection</span> <span class="o">=</span> <span class="n">RegularPolyCollection</span><span class="p">(</span>
    <span class="n">numsides</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="c"># a pentagon</span>
    <span class="n">rotation</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sizes</span><span class="o">=</span><span class="p">(</span><span class="mi">50</span><span class="p">,),</span>
    <span class="n">facecolors</span> <span class="o">=</span> <span class="n">facecolors</span><span class="p">,</span>
    <span class="n">edgecolors</span> <span class="o">=</span> <span class="p">(</span><span class="n">black</span><span class="p">,),</span>
    <span class="n">linewidths</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
    <span class="n">offsets</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">,</span>
    <span class="n">transOffset</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="matplotlib.collections.TriMesh">
<em class="property">class </em><tt class="descclassname">matplotlib.collections.</tt><tt class="descname">TriMesh</tt><big>(</big><em>triangulation</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.collections.TriMesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.collections.Collection" title="matplotlib.collections.Collection"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.collections.Collection</span></tt></a></p>
<p>Class for the efficient drawing of a triangular mesh using
Gouraud shading.</p>
<p>A triangular mesh is a <tt class="xref py py-class docutils literal"><span class="pre">Triangulation</span></tt>
object.</p>
<dl class="staticmethod">
<dt id="matplotlib.collections.TriMesh.convert_mesh_to_paths">
<em class="property">static </em><tt class="descname">convert_mesh_to_paths</tt><big>(</big><em>tri</em><big>)</big><a class="headerlink" href="#matplotlib.collections.TriMesh.convert_mesh_to_paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a given mesh into a sequence of
<a class="reference internal" href="path_api.html#matplotlib.path.Path" title="matplotlib.path.Path"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.path.Path</span></tt></a> objects for easier rendering by
backends that do not directly support meshes.</p>
<p>This function is primarily of use to backend implementers.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.collections.TriMesh.draw">
<tt class="descname">draw</tt><big>(</big><em>artist</em>, <em>renderer</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#matplotlib.collections.TriMesh.draw" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.TriMesh.get_paths">
<tt class="descname">get_paths</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.TriMesh.get_paths" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.collections.TriMesh.set_paths">
<tt class="descname">set_paths</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.collections.TriMesh.set_paths" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="colorbar_api.html" title="colorbar"
             >next</a> |</li>
        <li class="right" >
          <a href="cm_api.html" title="cm (colormap)"
             >previous</a> |</li>
        <li><a href="../index.html">home</a>|&nbsp;</li>
        <li><a href="../search.html">search</a>|&nbsp;</li>
        <li><a href="../examples/index.html">examples</a>|&nbsp;</li>
        <li><a href="../gallery.html">gallery</a>|&nbsp;</li>
        <li><a href="../contents.html">docs</a> &raquo;</li>

          <li><a href="index.html" >The Matplotlib API</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012 John Hunter, Darren Dale, Eric Firing, Michael Droettboom and the matplotlib development team.
      Last updated on Nov 26, 2012.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>