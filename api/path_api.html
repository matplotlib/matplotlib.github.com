

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>path &mdash; Matplotlib 1.1.1 documentation</title>
    
    <link rel="stylesheet" href="../_static/mpl.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Matplotlib 1.1.1 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="top" title="Matplotlib 1.1.1 documentation" href="../index.html" />
    <link rel="up" title="The Matplotlib API" href="index.html" />
    <link rel="next" title="pyplot" href="pyplot_api.html" />
    <link rel="prev" title="nxutils" href="nxutils_api.html" /> 
  </head>
  <body>
<!-- Piwik -->
<script type="text/javascript">
if ("matplotlib.sourceforge.net" == document.location.hostname ||
    "matplotlib.sf.net" == document.location.hostname) {
  var pkBaseURL = (("https:" == document.location.protocol) ? "https://apps.sourceforge.net/piwik/matplotlib/" : "http://apps.sourceforge.net/piwik/matplotlib/");
  document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
}
</script>
<script type="text/javascript">
if ("matplotlib.sourceforge.net" == document.location.hostname ||
    "matplotlib.sf.net" == document.location.hostname) {
  piwik_action_name = '';
  piwik_idsite = 1;
  piwik_url = pkBaseURL + "piwik.php";
  piwik_log(piwik_action_name, piwik_idsite, piwik_url);
  document.write(unescape('%3Cobject%3E%3Cnoscript%3E%3Cp%3E%3Cimg src="http://apps.sourceforge.net/piwik/matplotlib/piwik.php?idsite=1" alt="piwik"/%3E%3C/p%3E%3C/noscript%3E%3C/object%3E'));
}
</script>
<!-- End Piwik Tag -->
<link rel="shortcut icon" href="_static/favicon.ico">

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="../index.html"><img src="../_static/logo2.png" border="0" alt="matplotlib"/></a>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pyplot_api.html" title="pyplot"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="nxutils_api.html" title="nxutils"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">home</a>|&nbsp;</li>
        <li><a href="../search.html">search</a>|&nbsp;</li>
        <li><a href="../examples/index.html">examples</a>|&nbsp;</li>
        <li><a href="../gallery.html">gallery</a>|&nbsp;</li>
        <li><a href="../contents.html">docs</a> &raquo;</li>

          <li><a href="index.html" accesskey="U">The Matplotlib API</a> &raquo;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">path</a><ul>
<li><a class="reference internal" href="#module-matplotlib.path"><tt class="docutils literal"><span class="pre">matplotlib.path</span></tt></a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="nxutils_api.html"
                        title="previous chapter">nxutils</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="pyplot_api.html"
                        title="next chapter">pyplot</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/api/path_api.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="path">
<h1>path<a class="headerlink" href="#path" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-matplotlib.path">
<span id="matplotlib-path"></span><h2><a class="reference internal" href="#module-matplotlib.path" title="matplotlib.path"><tt class="xref py py-mod docutils literal"><span class="pre">matplotlib.path</span></tt></a><a class="headerlink" href="#module-matplotlib.path" title="Permalink to this headline">¶</a></h2>
<p>Contains a class for managing paths (polylines).</p>
<dl class="class">
<dt id="matplotlib.path.Path">
<em class="property">class </em><tt class="descclassname">matplotlib.path.</tt><tt class="descname">Path</tt><big>(</big><em>vertices</em>, <em>codes=None</em>, <em>_interpolation_steps=1</em>, <em>closed=False</em><big>)</big><a class="headerlink" href="#matplotlib.path.Path" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p><a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><tt class="xref py py-class docutils literal"><span class="pre">Path</span></tt></a> represents a series of possibly disconnected,
possibly closed, line and curve segments.</p>
<dl class="docutils">
<dt>The underlying storage is made up of two parallel numpy arrays:</dt>
<dd><ul class="first last simple">
<li><em>vertices</em>: an Nx2 float array of vertices</li>
<li><em>codes</em>: an N-length uint8 array of vertex types</li>
</ul>
</dd>
</dl>
<p>These two arrays always have the same length in the first
dimension.  For example, to represent a cubic curve, you must
provide three vertices as well as three codes <tt class="docutils literal"><span class="pre">CURVE3</span></tt>.</p>
<p>The code types are:</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">STOP</span></tt> <span class="classifier-delimiter">:</span> <span class="classifier">1 vertex (ignored)</span></dt>
<dd><p class="first last">A marker for the end of the entire path (currently not
required and ignored)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">MOVETO</span></tt> <span class="classifier-delimiter">:</span> <span class="classifier">1 vertex</span></dt>
<dd><p class="first last">Pick up the pen and move to the given vertex.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">LINETO</span></tt> <span class="classifier-delimiter">:</span> <span class="classifier">1 vertex</span></dt>
<dd><p class="first last">Draw a line from the current position to the given vertex.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">CURVE3</span></tt> <span class="classifier-delimiter">:</span> <span class="classifier">1 control point, 1 endpoint</span></dt>
<dd><p class="first last">Draw a quadratic Bezier curve from the current position,
with the given control point, to the given end point.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">CURVE4</span></tt> <span class="classifier-delimiter">:</span> <span class="classifier">2 control points, 1 endpoint</span></dt>
<dd><p class="first last">Draw a cubic Bezier curve from the current position, with
the given control points, to the given end point.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">CLOSEPOLY</span></tt> <span class="classifier-delimiter">:</span> <span class="classifier">1 vertex (ignored)</span></dt>
<dd><p class="first last">Draw a line segment to the start point of the current
polyline.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>Users of Path objects should not access the vertices and codes
arrays directly.  Instead, they should use <a class="reference internal" href="#matplotlib.path.Path.iter_segments" title="matplotlib.path.Path.iter_segments"><tt class="xref py py-meth docutils literal"><span class="pre">iter_segments()</span></tt></a>
to get the vertex/code pairs.  This is important, since many
<a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><tt class="xref py py-class docutils literal"><span class="pre">Path</span></tt></a> objects, as an optimization, do not store a <em>codes</em>
at all, but have a default one provided for them by
<a class="reference internal" href="#matplotlib.path.Path.iter_segments" title="matplotlib.path.Path.iter_segments"><tt class="xref py py-meth docutils literal"><span class="pre">iter_segments()</span></tt></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The vertices and codes arrays should be treated as
immutable &#8211; there are a number of optimizations and assumptions
made up front in the constructor that will not change when the
data changes.</p>
</div>
<p>Create a new path with the given vertices and codes.</p>
<p><em>vertices</em> is an Nx2 numpy float array, masked array or Python
sequence.</p>
<p><em>codes</em> is an N-length numpy array or Python sequence of type
<a class="reference internal" href="#matplotlib.path.Path.code_type" title="matplotlib.path.Path.code_type"><tt class="xref py py-attr docutils literal"><span class="pre">matplotlib.path.Path.code_type</span></tt></a>.</p>
<p>These two arrays must have the same length in the first
dimension.</p>
<p>If <em>codes</em> is None, <em>vertices</em> will be treated as a series of
line segments.</p>
<p>If <em>vertices</em> contains masked values, they will be converted
to NaNs which are then handled correctly by the Agg
PathIterator and other consumers of path data, such as
<a class="reference internal" href="#matplotlib.path.Path.iter_segments" title="matplotlib.path.Path.iter_segments"><tt class="xref py py-meth docutils literal"><span class="pre">iter_segments()</span></tt></a>.</p>
<p><em>interpolation_steps</em> is used as a hint to certain projections,
such as Polar, that this path should be linearly interpolated
immediately before drawing.  This attribute is primarily an
implementation detail and is not intended for public use.</p>
<dl class="attribute">
<dt id="matplotlib.path.Path.CLOSEPOLY">
<tt class="descname">CLOSEPOLY</tt><em class="property"> = 79</em><a class="headerlink" href="#matplotlib.path.Path.CLOSEPOLY" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.path.Path.CURVE3">
<tt class="descname">CURVE3</tt><em class="property"> = 3</em><a class="headerlink" href="#matplotlib.path.Path.CURVE3" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.path.Path.CURVE4">
<tt class="descname">CURVE4</tt><em class="property"> = 4</em><a class="headerlink" href="#matplotlib.path.Path.CURVE4" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.path.Path.LINETO">
<tt class="descname">LINETO</tt><em class="property"> = 2</em><a class="headerlink" href="#matplotlib.path.Path.LINETO" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.path.Path.MOVETO">
<tt class="descname">MOVETO</tt><em class="property"> = 1</em><a class="headerlink" href="#matplotlib.path.Path.MOVETO" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.path.Path.NUM_VERTICES">
<tt class="descname">NUM_VERTICES</tt><em class="property"> = [1, 1, 1, 2, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</em><a class="headerlink" href="#matplotlib.path.Path.NUM_VERTICES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.path.Path.STOP">
<tt class="descname">STOP</tt><em class="property"> = 0</em><a class="headerlink" href="#matplotlib.path.Path.STOP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="classmethod">
<dt id="matplotlib.path.Path.arc">
<em class="property">classmethod </em><tt class="descname">arc</tt><big>(</big><em>theta1</em>, <em>theta2</em>, <em>n=None</em>, <em>is_wedge=False</em><big>)</big><a class="headerlink" href="#matplotlib.path.Path.arc" title="Permalink to this definition">¶</a></dt>
<dd><p>(staticmethod) Returns an arc on the unit circle from angle
<em>theta1</em> to angle <em>theta2</em> (in degrees).</p>
<p>If <em>n</em> is provided, it is the number of spline segments to make.
If <em>n</em> is not provided, the number of spline segments is
determined based on the delta between <em>theta1</em> and <em>theta2</em>.</p>
<blockquote>
<div>Masionobe, L.  2003.  <a class="reference external" href="http://www.spaceroots.org/documents/ellipse/index.html">Drawing an elliptical arc using
polylines, quadratic or cubic Bezier curves</a>.</div></blockquote>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.path.Path.code_type">
<tt class="descname">code_type</tt><a class="headerlink" href="#matplotlib.path.Path.code_type" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <tt class="xref py py-class docutils literal"><span class="pre">uint8</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.path.Path.contains_path">
<tt class="descname">contains_path</tt><big>(</big><em>path</em>, <em>transform=None</em><big>)</big><a class="headerlink" href="#matplotlib.path.Path.contains_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <em>True</em> if this path completely contains the given path.</p>
<p>If <em>transform</em> is not <em>None</em>, the path will be transformed
before performing the test.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.path.Path.contains_point">
<tt class="descname">contains_point</tt><big>(</big><em>point</em>, <em>transform=None</em>, <em>radius=0.0</em><big>)</big><a class="headerlink" href="#matplotlib.path.Path.contains_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <em>True</em> if the path contains the given point.</p>
<p>If <em>transform</em> is not <em>None</em>, the path will be transformed
before performing the test.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.path.Path.get_extents">
<tt class="descname">get_extents</tt><big>(</big><em>transform=None</em><big>)</big><a class="headerlink" href="#matplotlib.path.Path.get_extents" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the extents (<em>xmin</em>, <em>ymin</em>, <em>xmax</em>, <em>ymax</em>) of the
path.</p>
<p>Unlike computing the extents on the <em>vertices</em> alone, this
algorithm will take into account the curves and deal with
control points appropriately.</p>
</dd></dl>

<dl class="classmethod">
<dt id="matplotlib.path.Path.hatch">
<em class="property">classmethod </em><tt class="descname">hatch</tt><big>(</big><em>hatchpattern</em>, <em>density=6</em><big>)</big><a class="headerlink" href="#matplotlib.path.Path.hatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a hatch specifier, <em>hatchpattern</em>, generates a Path that
can be used in a repeated hatching pattern.  <em>density</em> is the
number of lines per unit square.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.path.Path.interpolated">
<tt class="descname">interpolated</tt><big>(</big><em>steps</em><big>)</big><a class="headerlink" href="#matplotlib.path.Path.interpolated" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new path resampled to length N x steps.  Does not
currently handle interpolating curves.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.path.Path.intersects_bbox">
<tt class="descname">intersects_bbox</tt><big>(</big><em>bbox</em>, <em>filled=True</em><big>)</big><a class="headerlink" href="#matplotlib.path.Path.intersects_bbox" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <em>True</em> if this path intersects a given
<a class="reference internal" href="../devel/transformations.html#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><tt class="xref py py-class docutils literal"><span class="pre">Bbox</span></tt></a>.</p>
<p><em>filled</em>, when True, treats the path as if it was filled.
That is, if one path completely encloses the other,
<a class="reference internal" href="#matplotlib.path.Path.intersects_path" title="matplotlib.path.Path.intersects_path"><tt class="xref py py-meth docutils literal"><span class="pre">intersects_path()</span></tt></a> will return True.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.path.Path.intersects_path">
<tt class="descname">intersects_path</tt><big>(</big><em>other</em>, <em>filled=True</em><big>)</big><a class="headerlink" href="#matplotlib.path.Path.intersects_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <em>True</em> if this path intersects another given path.</p>
<p><em>filled</em>, when True, treats the paths as if they were filled.
That is, if one path completely encloses the other,
<a class="reference internal" href="#matplotlib.path.Path.intersects_path" title="matplotlib.path.Path.intersects_path"><tt class="xref py py-meth docutils literal"><span class="pre">intersects_path()</span></tt></a> will return True.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.path.Path.iter_segments">
<tt class="descname">iter_segments</tt><big>(</big><em>transform=None</em>, <em>remove_nans=True</em>, <em>clip=None</em>, <em>snap=False</em>, <em>stroke_width=1.0</em>, <em>simplify=None</em>, <em>curves=True</em><big>)</big><a class="headerlink" href="#matplotlib.path.Path.iter_segments" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterates over all of the curve segments in the path.  Each
iteration returns a 2-tuple (<em>vertices</em>, <em>code</em>), where
<em>vertices</em> is a sequence of 1 - 3 coordinate pairs, and <em>code</em> is
one of the <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><tt class="xref py py-class docutils literal"><span class="pre">Path</span></tt></a> codes.</p>
<p>Additionally, this method can provide a number of standard
cleanups and conversions to the path.</p>
<dl class="docutils">
<dt><em>transform</em>: if not None, the given affine transformation will</dt>
<dd>be applied to the path.</dd>
<dt><em>remove_nans</em>: if True, will remove all NaNs from the path and</dt>
<dd>insert MOVETO commands to skip over them.</dd>
<dt><em>clip</em>: if not None, must be a four-tuple (x1, y1, x2, y2)</dt>
<dd>defining a rectangle in which to clip the path.</dd>
<dt><em>snap</em>: if None, auto-snap to pixels, to reduce</dt>
<dd>fuzziness of rectilinear lines.  If True, force snapping, and
if False, don&#8217;t snap.</dd>
<dt><em>stroke_width</em>: the width of the stroke being drawn.  Needed</dt>
<dd>as a hint for the snapping algorithm.</dd>
<dt><em>simplify</em>: if True, perform simplification, to remove</dt>
<dd>vertices that do not affect the appearance of the path.  If
False, perform no simplification.  If None, use the
should_simplify member variable.</dd>
<dt><em>curves</em>: If True, curve segments will be returned as curve</dt>
<dd>segments.  If False, all curves will be converted to line
segments.</dd>
</dl>
</dd></dl>

<dl class="classmethod">
<dt id="matplotlib.path.Path.make_compound_path">
<em class="property">classmethod </em><tt class="descname">make_compound_path</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#matplotlib.path.Path.make_compound_path" title="Permalink to this definition">¶</a></dt>
<dd><p>(staticmethod) Make a compound path from a list of Path
objects.  Only polygons (not curves) are supported.</p>
</dd></dl>

<dl class="classmethod">
<dt id="matplotlib.path.Path.make_compound_path_from_polys">
<em class="property">classmethod </em><tt class="descname">make_compound_path_from_polys</tt><big>(</big><em>XY</em><big>)</big><a class="headerlink" href="#matplotlib.path.Path.make_compound_path_from_polys" title="Permalink to this definition">¶</a></dt>
<dd><p>(static method) Make a compound path object to draw a number
of polygons with equal numbers of sides XY is a (numpolys x
numsides x 2) numpy array of vertices.  Return object is a
<a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><tt class="xref py py-class docutils literal"><span class="pre">Path</span></tt></a></p>
<p>(<a class="reference external" href="../mpl_examples/api/histogram_path_demo.py">Source code</a>, <a class="reference external" href="../mpl_examples/api/histogram_path_demo.png">png</a>, <a class="reference external" href="../mpl_examples/api/histogram_path_demo.hires.png">hires.png</a>, <a class="reference external" href="../mpl_examples/api/histogram_path_demo.pdf">pdf</a>)</p>
<div class="figure">
<img alt="../_images/histogram_path_demo.png" src="../_images/histogram_path_demo.png" />
</div>
</dd></dl>

<dl class="method">
<dt id="matplotlib.path.Path.to_polygons">
<tt class="descname">to_polygons</tt><big>(</big><em>transform=None</em>, <em>width=0</em>, <em>height=0</em><big>)</big><a class="headerlink" href="#matplotlib.path.Path.to_polygons" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert this path to a list of polygons.  Each polygon is an
Nx2 array of vertices.  In other words, each polygon has no
<tt class="docutils literal"><span class="pre">MOVETO</span></tt> instructions or curves.  This is useful for
displaying in backends that do not support compound paths or
Bezier curves, such as GDK.</p>
<p>If <em>width</em> and <em>height</em> are both non-zero then the lines will
be simplified so that vertices outside of (0, 0), (width,
height) will be clipped.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.path.Path.transformed">
<tt class="descname">transformed</tt><big>(</big><em>transform</em><big>)</big><a class="headerlink" href="#matplotlib.path.Path.transformed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a transformed copy of the path.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="../devel/transformations.html#matplotlib.transforms.TransformedPath" title="matplotlib.transforms.TransformedPath"><tt class="xref py py-class docutils literal"><span class="pre">matplotlib.transforms.TransformedPath</span></tt></a></dt>
<dd>A specialized path class that will cache the
transformed result and automatically update when the
transform changes.</dd>
</dl>
</div>
</dd></dl>

<dl class="classmethod">
<dt id="matplotlib.path.Path.unit_circle">
<em class="property">classmethod </em><tt class="descname">unit_circle</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.path.Path.unit_circle" title="Permalink to this definition">¶</a></dt>
<dd><p>(staticmethod) Returns a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><tt class="xref py py-class docutils literal"><span class="pre">Path</span></tt></a> of the unit circle.
The circle is approximated using cubic Bezier curves.  This
uses 8 splines around the circle using the approach presented
here:</p>
<blockquote>
<div>Lancaster, Don.  <a class="reference external" href="http://www.tinaja.com/glib/ellipse4.pdf">Approximating a Circle or an Ellipse Using Four
Bezier Cubic Splines</a>.</div></blockquote>
</dd></dl>

<dl class="classmethod">
<dt id="matplotlib.path.Path.unit_circle_righthalf">
<em class="property">classmethod </em><tt class="descname">unit_circle_righthalf</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.path.Path.unit_circle_righthalf" title="Permalink to this definition">¶</a></dt>
<dd><p>(staticmethod) Returns a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><tt class="xref py py-class docutils literal"><span class="pre">Path</span></tt></a> of the right half
of a unit circle. The circle is approximated using cubic Bezier
curves.  This uses 4 splines around the circle using the approach
presented here:</p>
<blockquote>
<div>Lancaster, Don.  <a class="reference external" href="http://www.tinaja.com/glib/ellipse4.pdf">Approximating a Circle or an Ellipse Using Four
Bezier Cubic Splines</a>.</div></blockquote>
</dd></dl>

<dl class="classmethod">
<dt id="matplotlib.path.Path.unit_rectangle">
<em class="property">classmethod </em><tt class="descname">unit_rectangle</tt><big>(</big><big>)</big><a class="headerlink" href="#matplotlib.path.Path.unit_rectangle" title="Permalink to this definition">¶</a></dt>
<dd><p>(staticmethod) Returns a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><tt class="xref py py-class docutils literal"><span class="pre">Path</span></tt></a> of the unit rectangle
from (0, 0) to (1, 1).</p>
</dd></dl>

<dl class="classmethod">
<dt id="matplotlib.path.Path.unit_regular_asterisk">
<em class="property">classmethod </em><tt class="descname">unit_regular_asterisk</tt><big>(</big><em>numVertices</em><big>)</big><a class="headerlink" href="#matplotlib.path.Path.unit_regular_asterisk" title="Permalink to this definition">¶</a></dt>
<dd><p>(staticmethod) Returns a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><tt class="xref py py-class docutils literal"><span class="pre">Path</span></tt></a> for a unit regular
asterisk with the given numVertices and radius of 1.0,
centered at (0, 0).</p>
</dd></dl>

<dl class="classmethod">
<dt id="matplotlib.path.Path.unit_regular_polygon">
<em class="property">classmethod </em><tt class="descname">unit_regular_polygon</tt><big>(</big><em>numVertices</em><big>)</big><a class="headerlink" href="#matplotlib.path.Path.unit_regular_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>(staticmethod) Returns a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><tt class="xref py py-class docutils literal"><span class="pre">Path</span></tt></a> for a unit regular
polygon with the given <em>numVertices</em> and radius of 1.0,
centered at (0, 0).</p>
</dd></dl>

<dl class="classmethod">
<dt id="matplotlib.path.Path.unit_regular_star">
<em class="property">classmethod </em><tt class="descname">unit_regular_star</tt><big>(</big><em>numVertices</em>, <em>innerCircle=0.5</em><big>)</big><a class="headerlink" href="#matplotlib.path.Path.unit_regular_star" title="Permalink to this definition">¶</a></dt>
<dd><p>(staticmethod) Returns a <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><tt class="xref py py-class docutils literal"><span class="pre">Path</span></tt></a> for a unit regular star
with the given numVertices and radius of 1.0, centered at (0,
0).</p>
</dd></dl>

<dl class="classmethod">
<dt id="matplotlib.path.Path.wedge">
<em class="property">classmethod </em><tt class="descname">wedge</tt><big>(</big><em>theta1</em>, <em>theta2</em>, <em>n=None</em><big>)</big><a class="headerlink" href="#matplotlib.path.Path.wedge" title="Permalink to this definition">¶</a></dt>
<dd><p>(staticmethod) Returns a wedge of the unit circle from angle
<em>theta1</em> to angle <em>theta2</em> (in degrees).</p>
<p>If <em>n</em> is provided, it is the number of spline segments to make.
If <em>n</em> is not provided, the number of spline segments is
determined based on the delta between <em>theta1</em> and <em>theta2</em>.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="matplotlib.path.cleanup_path">
<tt class="descclassname">matplotlib.path.</tt><tt class="descname">cleanup_path</tt><big>(</big><em>path</em>, <em>trans</em>, <em>remove_nans</em>, <em>clip</em>, <em>snap</em>, <em>simplify</em>, <em>curves</em><big>)</big><a class="headerlink" href="#matplotlib.path.cleanup_path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="matplotlib.path.convert_path_to_polygons">
<tt class="descclassname">matplotlib.path.</tt><tt class="descname">convert_path_to_polygons</tt><big>(</big><em>path</em>, <em>trans</em>, <em>width</em>, <em>height</em><big>)</big><a class="headerlink" href="#matplotlib.path.convert_path_to_polygons" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="matplotlib.path.get_path_collection_extents">
<tt class="descclassname">matplotlib.path.</tt><tt class="descname">get_path_collection_extents</tt><big>(</big><em>*args</em><big>)</big><a class="headerlink" href="#matplotlib.path.get_path_collection_extents" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a sequence of <a class="reference internal" href="#matplotlib.path.Path" title="matplotlib.path.Path"><tt class="xref py py-class docutils literal"><span class="pre">Path</span></tt></a> objects, returns the bounding
box that encapsulates all of them.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.path.get_path_extents">
<tt class="descclassname">matplotlib.path.</tt><tt class="descname">get_path_extents</tt><big>(</big><em>path</em>, <em>trans</em><big>)</big><a class="headerlink" href="#matplotlib.path.get_path_extents" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="matplotlib.path.path_in_path">
<tt class="descclassname">matplotlib.path.</tt><tt class="descname">path_in_path</tt><big>(</big><em>a</em>, <em>atrans</em>, <em>b</em>, <em>btrans</em><big>)</big><a class="headerlink" href="#matplotlib.path.path_in_path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="matplotlib.path.path_intersects_path">
<tt class="descclassname">matplotlib.path.</tt><tt class="descname">path_intersects_path</tt><big>(</big><em>p1</em>, <em>p2</em><big>)</big><a class="headerlink" href="#matplotlib.path.path_intersects_path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="matplotlib.path.point_in_path">
<tt class="descclassname">matplotlib.path.</tt><tt class="descname">point_in_path</tt><big>(</big><em>x</em>, <em>y</em>, <em>path</em>, <em>trans</em><big>)</big><a class="headerlink" href="#matplotlib.path.point_in_path" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="matplotlib.path.point_in_path_collection">
<tt class="descclassname">matplotlib.path.</tt><tt class="descname">point_in_path_collection</tt><big>(</big><em>x</em>, <em>y</em>, <em>r</em>, <em>trans</em>, <em>paths</em>, <em>transforms</em>, <em>offsets</em>, <em>offsetTrans</em>, <em>filled</em><big>)</big><a class="headerlink" href="#matplotlib.path.point_in_path_collection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pyplot_api.html" title="pyplot"
             >next</a> |</li>
        <li class="right" >
          <a href="nxutils_api.html" title="nxutils"
             >previous</a> |</li>
        <li><a href="../index.html">home</a>|&nbsp;</li>
        <li><a href="../search.html">search</a>|&nbsp;</li>
        <li><a href="../examples/index.html">examples</a>|&nbsp;</li>
        <li><a href="../gallery.html">gallery</a>|&nbsp;</li>
        <li><a href="../contents.html">docs</a> &raquo;</li>

          <li><a href="index.html" >The Matplotlib API</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2008, John Hunter, Darren Dale, Michael Droettboom.
      Last updated on Aug 10, 2012.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>