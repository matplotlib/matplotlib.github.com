<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>transformations &mdash; Matplotlib 3.0.3 documentation</title>
    
    <link rel="stylesheet" href="../_static/mpl.css"
type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css"
type="text/css" />
    <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
    <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Matplotlib 3.0.3 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html"
/>
    <link rel="search" title="Search" href="../search.html"
/>
    <link rel="top" title="Matplotlib 3.0.3 documentation" href="../index.html" />
    <link rel="up" title="The Matplotlib API" href="index.html" />
    <link rel="next" title="triangular grids" href="tri_api.html" />
    <link rel="prev" title="tight_layout" href="tight_layout_api.html" />
  <link rel="canonical" href="https://matplotlib.org/api/transformations.html" />



  </head>
  <body>


<div id="GSOC-banner">
  Apply to work with matplotlib for GSOC! Take a look at our 
  <a href='https://github.com/matplotlib/matplotlib/wiki/GSOC-2019-Ideas-Page'>
    ideas list
  </a> and learn how to
  <a href='https://github.com/numfocus/gsoc/blob/master/README.md'>
    apply here
  </a>.

</div>
<div id="plotting-contest">
    The 2019 <a href="https://jhepc.github.io">
      SciPy John Hunter Excellence in Plotting Contest </a> is accepting
    <a href="https://docs.google.com/forms/d/e/1FAIpQLSe-_AnKvYSzeQWfNDRoXgW0vl7_8q6jj3QbLIac8eUcb9lSAA/viewform?usp=sf_link">
        submissions until June 8th!
    </a>
</div>
<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px; position: relative;">
<a href="../index.html">
    <div style="float: left; position: absolute; width: 496px; bottom: 0; padding-bottom: 24px"><span style="float: right; color: #789; background: white">Version 3.0.3</span></div>
    <img src="../_static/logo2.png" height="125px" border="0" alt="matplotlib"/></a>

<!-- The "Fork me on github" ribbon -->
<div id="forkongithub"><a href="https://github.com/matplotlib/matplotlib">Fork me on GitHub</a></div>
</div>




    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tri_api.html" title="triangular grids"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tight_layout_api.html" title="tight_layout"
             accesskey="P">previous</a> |</li>

        <li><a href="../index.html">home</a>|&nbsp;</li>
        <li><a href="../gallery/index.html">examples</a>|&nbsp;</li>
        <li><a href="../tutorials/index.html">tutorials</a>|&nbsp;</li>
        <li><a href="api_overview.html">API</a>|&nbsp;</li>
        <li><a href="../contents.html">docs</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">The Matplotlib API</a> &raquo;</li> 
      </ul>
    </div>

  
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
  <h3><a href="../contents.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">transformations</a><ul>
<li><a class="reference internal" href="#module-matplotlib.transforms"><code class="docutils literal notranslate"><span class="pre">matplotlib.transforms</span></code></a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../contents.html">Documentation overview</a><ul>
  <li><a href="index.html">The Matplotlib API</a><ul>
      <li>Previous: <a href="tight_layout_api.html" title="previous chapter">tight_layout</a></li>
      <li>Next: <a href="tri_api.html" title="next chapter">triangular grids</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div id="sidebar-pagesource" role="note" aria-label="source link"
    style="margin-top: 1.5em; padding-top: 0.1em; border-top: 1px solid #86989b">
  <a href="../_sources/api/transformations.rst.txt"
     style="color: #c0c0c0" rel="nofollow">Show Page Source</a>
  </div>
        </div>
      </div>
    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="transformations">
<h1>transformations<a class="headerlink" href="#transformations" title="Permalink to this headline">¶</a></h1>
<div class="graphviz"><img src="../_images/inheritance-eafd5ed19d2f8badee138776b0306812a48917f9.png" alt="Inheritance diagram of matplotlib.transforms, matplotlib.path" usemap="#inheritancedbde0cb62f" class="inheritance graphviz" /></div>
<map id="inheritancedbde0cb62f" name="inheritancedbde0cb62f">
<area shape="rect" id="node1" href="#matplotlib.transforms.Affine2D" target="_top" title="A mutable 2D affine transformation." alt="" coords="531,4,583,20"/>
<area shape="rect" id="node2" href="#matplotlib.transforms.Affine2DBase" target="_top" title="The base class of all 2D affine transformations." alt="" coords="402,118,475,135"/>
<area shape="rect" id="node8" href="#matplotlib.transforms.BboxTransform" target="_top" title=":class:`BboxTransform` linearly transforms points from one" alt="" coords="517,36,596,53"/>
<area shape="rect" id="node9" href="#matplotlib.transforms.BboxTransformFrom" target="_top" title=":class:`BboxTransformFrom` linearly transforms points from a given" alt="" coords="506,69,607,85"/>
<area shape="rect" id="node10" href="#matplotlib.transforms.BboxTransformTo" target="_top" title=":class:`BboxTransformTo` is a transformation that linearly" alt="" coords="512,101,601,118"/>
<area shape="rect" id="node12" href="#matplotlib.transforms.BlendedAffine2D" target="_top" title="A &quot;blended&quot; transform uses one transform for the *x*&#45;direction, and" alt="" coords="513,134,600,151"/>
<area shape="rect" id="node14" href="#matplotlib.transforms.CompositeAffine2D" target="_top" title="A composite transform formed by applying transform *a* then transform *b*." alt="" coords="508,166,606,183"/>
<area shape="rect" id="node16" href="#matplotlib.transforms.IdentityTransform" target="_top" title="A special class that does one thing, the identity transform, in a" alt="" coords="511,199,602,216"/>
<area shape="rect" id="node19" href="#matplotlib.transforms.ScaledTranslation" target="_top" title="A transformation that translates by *xt* and *yt*, after *xt* and *yt*" alt="" coords="512,232,602,248"/>
<area shape="rect" id="node3" href="#matplotlib.transforms.AffineBase" target="_top" title="The base class of all affine transformations of any number of" alt="" coords="271,118,332,135"/>
<area shape="rect" id="node4" href="#matplotlib.transforms.Transform" target="_top" title="The base class of all :class:`TransformNode` instances that" alt="" coords="130,183,187,200"/>
<area shape="rect" id="node13" href="#matplotlib.transforms.BlendedGenericTransform" target="_top" title="A &quot;blended&quot; transform uses one transform for the *x*&#45;direction, and" alt="" coords="239,151,365,167"/>
<area shape="rect" id="node15" href="#matplotlib.transforms.CompositeGenericTransform" target="_top" title="A composite transform formed by applying transform *a* then" alt="" coords="233,183,370,200"/>
<area shape="rect" id="node20" href="#matplotlib.transforms.TransformWrapper" target="_top" title="A helper class that holds a single child transform and acts" alt="" coords="255,216,348,233"/>
<area shape="rect" id="node5" href="#matplotlib.transforms.Bbox" target="_top" title="A mutable bounding box." alt="" coords="278,248,325,265"/>
<area shape="rect" id="node6" href="#matplotlib.transforms.BboxBase" target="_top" title="This is the base class of all bounding boxes, and provides" alt="" coords="130,281,187,298"/>
<area shape="rect" id="node17" href="#matplotlib.transforms.LockableBbox" target="_top" title="A :class:`Bbox` where some elements may be locked at certain values." alt="" coords="264,281,339,298"/>
<area shape="rect" id="node21" href="#matplotlib.transforms.TransformedBbox" target="_top" title="A :class:`Bbox` that is automatically transformed by a given" alt="" coords="257,314,347,330"/>
<area shape="rect" id="node7" href="#matplotlib.transforms.TransformNode" target="_top" title=":class:`TransformNode` is the base class for anything that" alt="" coords="4,281,84,298"/>
<area shape="rect" id="node23" href="#matplotlib.transforms.TransformedPath" target="_top" title="A :class:`TransformedPath` caches a non&#45;affine transformed copy of" alt="" coords="115,329,202,346"/>
<area shape="rect" id="node11" href="#matplotlib.transforms.BboxTransformToMaxOnly" target="_top" title=":class:`BboxTransformTo` is a transformation that linearly" alt="" coords="639,101,764,118"/>
<area shape="rect" id="node18" href="path_api.html#matplotlib.path.Path" target="_top" title=":class:`Path` represents a series of possibly disconnected," alt="" coords="20,248,67,265"/>
<area shape="rect" id="node22" href="#matplotlib.transforms.TransformedPatchPath" target="_top" title="A :class:`TransformedPatchPath` caches a non&#45;affine transformed copy of" alt="" coords="247,346,357,363"/>
</map><div class="section" id="module-matplotlib.transforms">
<span id="matplotlib-transforms"></span><h2><a class="reference internal" href="#module-matplotlib.transforms" title="matplotlib.transforms"><code class="xref py py-mod docutils literal notranslate"><span class="pre">matplotlib.transforms</span></code></a><a class="headerlink" href="#module-matplotlib.transforms" title="Permalink to this headline">¶</a></h2>
<p>matplotlib includes a framework for arbitrary geometric
transformations that is used determine the final position of all
elements drawn on the canvas.</p>
<p>Transforms are composed into trees of <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransformNode</span></code></a> objects
whose actual value depends on their children.  When the contents of
children change, their parents are automatically invalidated.  The
next time an invalidated transform is accessed, it is recomputed to
reflect those changes.  This invalidation/caching approach prevents
unnecessary recomputations of transforms, and contributes to better
interactive performance.</p>
<p>For example, here is a graph of the transform tree used to plot data
to the graph:</p>
<img alt="../_images/transforms.png" src="../_images/transforms.png" />
<p>The framework can be used for both affine and non-affine
transformations.  However, for speed, we want use the backend
renderers to perform affine transformations whenever possible.
Therefore, it is possible to perform just the affine or non-affine
part of a transformation on a set of data.  The affine is always
assumed to occur after the non-affine.  For any transform:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">full</span> <span class="n">transform</span> <span class="o">==</span> <span class="n">non</span><span class="o">-</span><span class="n">affine</span> <span class="n">part</span> <span class="o">+</span> <span class="n">affine</span> <span class="n">part</span>
</pre></div>
</div>
<p>The backends are not expected to handle non-affine transformations
themselves.</p>
<dl class="class">
<dt id="matplotlib.transforms.Affine2D">
<em class="property">class </em><code class="descclassname">matplotlib.transforms.</code><code class="descname">Affine2D</code><span class="sig-paren">(</span><em>matrix=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Affine2D"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Affine2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.transforms.Affine2DBase</span></code></a></p>
<p>A mutable 2D affine transformation.</p>
<p>Initialize an Affine transform from a 3x3 numpy float array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="n">c</span> <span class="n">e</span>
<span class="n">b</span> <span class="n">d</span> <span class="n">f</span>
<span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span>
</pre></div>
</div>
<p>If <em>matrix</em> is None, initialize with the identity transform.</p>
<dl class="method">
<dt id="matplotlib.transforms.Affine2D.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Affine2D.clear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Affine2D.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the underlying matrix to the identity transform.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="matplotlib.transforms.Affine2D.from_values">
<em class="property">static </em><code class="descname">from_values</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>, <em>e</em>, <em>f</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Affine2D.from_values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Affine2D.from_values" title="Permalink to this definition">¶</a></dt>
<dd><p>(staticmethod) Create a new Affine2D instance from the given
values:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="n">c</span> <span class="n">e</span>
<span class="n">b</span> <span class="n">d</span> <span class="n">f</span>
<span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span>
</pre></div>
</div>
<p>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Affine2D.get_matrix">
<code class="descname">get_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Affine2D.get_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Affine2D.get_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the underlying transformation matrix as a 3x3 numpy array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="n">c</span> <span class="n">e</span>
<span class="n">b</span> <span class="n">d</span> <span class="n">f</span>
<span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span>
</pre></div>
</div>
<p>.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="matplotlib.transforms.Affine2D.identity">
<em class="property">static </em><code class="descname">identity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Affine2D.identity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Affine2D.identity" title="Permalink to this definition">¶</a></dt>
<dd><p>(staticmethod) Return a new <a class="reference internal" href="#matplotlib.transforms.Affine2D" title="matplotlib.transforms.Affine2D"><code class="xref py py-class docutils literal notranslate"><span class="pre">Affine2D</span></code></a> object that is
the identity transform.</p>
<p>Unless this transform will be mutated later on, consider using
the faster <a class="reference internal" href="#matplotlib.transforms.IdentityTransform" title="matplotlib.transforms.IdentityTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">IdentityTransform</span></code></a> class instead.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.Affine2D.is_separable">
<code class="descname">is_separable</code><a class="headerlink" href="#matplotlib.transforms.Affine2D.is_separable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Affine2D.rotate">
<code class="descname">rotate</code><span class="sig-paren">(</span><em>theta</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Affine2D.rotate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Affine2D.rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a rotation (in radians) to this transform in place.</p>
<p>Returns <em>self</em>, so this method can easily be chained with more
calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rotate()</span></code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rotate_deg()</span></code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">translate()</span></code></a>
and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scale()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Affine2D.rotate_around">
<code class="descname">rotate_around</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>theta</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Affine2D.rotate_around"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Affine2D.rotate_around" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a rotation (in radians) around the point (x, y) in place.</p>
<p>Returns <em>self</em>, so this method can easily be chained with more
calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rotate()</span></code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rotate_deg()</span></code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">translate()</span></code></a>
and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scale()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Affine2D.rotate_deg">
<code class="descname">rotate_deg</code><span class="sig-paren">(</span><em>degrees</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Affine2D.rotate_deg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Affine2D.rotate_deg" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a rotation (in degrees) to this transform in place.</p>
<p>Returns <em>self</em>, so this method can easily be chained with more
calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rotate()</span></code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rotate_deg()</span></code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">translate()</span></code></a>
and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scale()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Affine2D.rotate_deg_around">
<code class="descname">rotate_deg_around</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>degrees</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Affine2D.rotate_deg_around"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Affine2D.rotate_deg_around" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a rotation (in degrees) around the point (x, y) in place.</p>
<p>Returns <em>self</em>, so this method can easily be chained with more
calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rotate()</span></code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rotate_deg()</span></code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">translate()</span></code></a>
and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scale()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Affine2D.scale">
<code class="descname">scale</code><span class="sig-paren">(</span><em>sx</em>, <em>sy=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Affine2D.scale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Affine2D.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a scale in place.</p>
<p>If <em>sy</em> is None, the same scale is applied in both the <em>x</em>- and
<em>y</em>-directions.</p>
<p>Returns <em>self</em>, so this method can easily be chained with more
calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rotate()</span></code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rotate_deg()</span></code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">translate()</span></code></a>
and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scale()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Affine2D.set">
<code class="descname">set</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Affine2D.set"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Affine2D.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set this transformation from the frozen copy of another
<a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">Affine2DBase</span></code></a> object.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Affine2D.set_matrix">
<code class="descname">set_matrix</code><span class="sig-paren">(</span><em>mtx</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Affine2D.set_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Affine2D.set_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the underlying transformation matrix from a 3x3 numpy array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="n">c</span> <span class="n">e</span>
<span class="n">b</span> <span class="n">d</span> <span class="n">f</span>
<span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span>
</pre></div>
</div>
<p>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Affine2D.skew">
<code class="descname">skew</code><span class="sig-paren">(</span><em>xShear</em>, <em>yShear</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Affine2D.skew"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Affine2D.skew" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a skew in place.</p>
<p><em>xShear</em> and <em>yShear</em> are the shear angles along the <em>x</em>- and
<em>y</em>-axes, respectively, in radians.</p>
<p>Returns <em>self</em>, so this method can easily be chained with more
calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rotate()</span></code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rotate_deg()</span></code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">translate()</span></code></a>
and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scale()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Affine2D.skew_deg">
<code class="descname">skew_deg</code><span class="sig-paren">(</span><em>xShear</em>, <em>yShear</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Affine2D.skew_deg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Affine2D.skew_deg" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a skew in place.</p>
<p><em>xShear</em> and <em>yShear</em> are the shear angles along the <em>x</em>- and
<em>y</em>-axes, respectively, in degrees.</p>
<p>Returns <em>self</em>, so this method can easily be chained with more
calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rotate()</span></code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rotate_deg()</span></code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">translate()</span></code></a>
and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scale()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Affine2D.translate">
<code class="descname">translate</code><span class="sig-paren">(</span><em>tx</em>, <em>ty</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Affine2D.translate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Affine2D.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a translation in place.</p>
<p>Returns <em>self</em>, so this method can easily be chained with more
calls to <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate" title="matplotlib.transforms.Affine2D.rotate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rotate()</span></code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.rotate_deg" title="matplotlib.transforms.Affine2D.rotate_deg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rotate_deg()</span></code></a>, <a class="reference internal" href="#matplotlib.transforms.Affine2D.translate" title="matplotlib.transforms.Affine2D.translate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">translate()</span></code></a>
and <a class="reference internal" href="#matplotlib.transforms.Affine2D.scale" title="matplotlib.transforms.Affine2D.scale"><code class="xref py py-meth docutils literal notranslate"><span class="pre">scale()</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.transforms.Affine2DBase">
<em class="property">class </em><code class="descclassname">matplotlib.transforms.</code><code class="descname">Affine2DBase</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Affine2DBase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Affine2DBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.transforms.AffineBase" title="matplotlib.transforms.AffineBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.transforms.AffineBase</span></code></a></p>
<p>The base class of all 2D affine transformations.</p>
<p>2D affine transformations are performed using a 3x3 numpy array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="n">c</span> <span class="n">e</span>
<span class="n">b</span> <span class="n">d</span> <span class="n">f</span>
<span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span>
</pre></div>
</div>
<p>This class provides the read-only interface.  For a mutable 2D
affine transformation, use <a class="reference internal" href="#matplotlib.transforms.Affine2D" title="matplotlib.transforms.Affine2D"><code class="xref py py-class docutils literal notranslate"><span class="pre">Affine2D</span></code></a>.</p>
<p>Subclasses of this class will generally only need to override a
constructor and <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_matrix()</span></code> that generates a custom 3x3 matrix.</p>
<dl class="method">
<dt id="matplotlib.transforms.Affine2DBase.frozen">
<code class="descname">frozen</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Affine2DBase.frozen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Affine2DBase.frozen" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a frozen copy of this transform node.  The frozen copy
will not update when its children change.  Useful for storing
a previously known state of a transform where
<code class="docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code> might normally be used.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.Affine2DBase.has_inverse">
<code class="descname">has_inverse</code><em class="property"> = True</em><a class="headerlink" href="#matplotlib.transforms.Affine2DBase.has_inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.Affine2DBase.input_dims">
<code class="descname">input_dims</code><em class="property"> = 2</em><a class="headerlink" href="#matplotlib.transforms.Affine2DBase.input_dims" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Affine2DBase.inverted">
<code class="descname">inverted</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Affine2DBase.inverted"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Affine2DBase.inverted" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the corresponding inverse transformation.</p>
<p>The return value of this method should be treated as
temporary.  An update to <em>self</em> does not cause a corresponding
update to its inverted copy.</p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">===</span> <span class="pre">self.inverted().transform(self.transform(x))</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.Affine2DBase.is_separable">
<code class="descname">is_separable</code><a class="headerlink" href="#matplotlib.transforms.Affine2DBase.is_separable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="matplotlib.transforms.Affine2DBase.matrix_from_values">
<em class="property">static </em><code class="descname">matrix_from_values</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>, <em>e</em>, <em>f</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Affine2DBase.matrix_from_values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Affine2DBase.matrix_from_values" title="Permalink to this definition">¶</a></dt>
<dd><p>(staticmethod) Create a new transformation matrix as a 3x3
numpy array of the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="n">c</span> <span class="n">e</span>
<span class="n">b</span> <span class="n">d</span> <span class="n">f</span>
<span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.Affine2DBase.output_dims">
<code class="descname">output_dims</code><em class="property"> = 2</em><a class="headerlink" href="#matplotlib.transforms.Affine2DBase.output_dims" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Affine2DBase.to_values">
<code class="descname">to_values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Affine2DBase.to_values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Affine2DBase.to_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the values of the matrix as a sequence (a,b,c,d,e,f)</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Affine2DBase.transform_affine">
<code class="descname">transform_affine</code><span class="sig-paren">(</span><em>points</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Affine2DBase.transform_affine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Affine2DBase.transform_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs only the affine part of this transformation on the
given array of values.</p>
<p><code class="docutils literal notranslate"><span class="pre">transform(values)</span></code> is always equivalent to
<code class="docutils literal notranslate"><span class="pre">transform_affine(transform_non_affine(values))</span></code>.</p>
<p>In non-affine transformations, this is generally a no-op.  In
affine transformations, this is equivalent to
<code class="docutils literal notranslate"><span class="pre">transform(values)</span></code>.</p>
<p>Accepts a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.Affine2DBase.input_dims" title="matplotlib.transforms.Affine2DBase.input_dims"><code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code></a>) and
returns a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.Affine2DBase.output_dims" title="matplotlib.transforms.Affine2DBase.output_dims"><code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code></a>).</p>
<p>Alternatively, accepts a numpy array of length <a class="reference internal" href="#matplotlib.transforms.Affine2DBase.input_dims" title="matplotlib.transforms.Affine2DBase.input_dims"><code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code></a>
and returns a numpy array of length <a class="reference internal" href="#matplotlib.transforms.Affine2DBase.output_dims" title="matplotlib.transforms.Affine2DBase.output_dims"><code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Affine2DBase.transform_point">
<code class="descname">transform_point</code><span class="sig-paren">(</span><em>point</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Affine2DBase.transform_point"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Affine2DBase.transform_point" title="Permalink to this definition">¶</a></dt>
<dd><p>A convenience function that returns the transformed copy of a
single point.</p>
<p>The point is given as a sequence of length <a class="reference internal" href="#matplotlib.transforms.Affine2DBase.input_dims" title="matplotlib.transforms.Affine2DBase.input_dims"><code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code></a>.
The transformed point is returned as a sequence of length
<a class="reference internal" href="#matplotlib.transforms.Affine2DBase.output_dims" title="matplotlib.transforms.Affine2DBase.output_dims"><code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.transforms.AffineBase">
<em class="property">class </em><code class="descclassname">matplotlib.transforms.</code><code class="descname">AffineBase</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#AffineBase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.AffineBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.transforms.Transform</span></code></a></p>
<p>The base class of all affine transformations of any number of
dimensions.</p>
<dl class="method">
<dt id="matplotlib.transforms.AffineBase.get_affine">
<code class="descname">get_affine</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#AffineBase.get_affine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.AffineBase.get_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the affine part of this transform.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.AffineBase.is_affine">
<code class="descname">is_affine</code><em class="property"> = True</em><a class="headerlink" href="#matplotlib.transforms.AffineBase.is_affine" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.AffineBase.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>values</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#AffineBase.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.AffineBase.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the transformation on the given array of values.</p>
<p>Accepts a numpy array of shape (N x <code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code>) and
returns a numpy array of shape (N x <code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code>).</p>
<p>Alternatively, accepts a numpy array of length <code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code>
and returns a numpy array of length <code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.AffineBase.transform_affine">
<code class="descname">transform_affine</code><span class="sig-paren">(</span><em>values</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#AffineBase.transform_affine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.AffineBase.transform_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs only the affine part of this transformation on the
given array of values.</p>
<p><code class="docutils literal notranslate"><span class="pre">transform(values)</span></code> is always equivalent to
<code class="docutils literal notranslate"><span class="pre">transform_affine(transform_non_affine(values))</span></code>.</p>
<p>In non-affine transformations, this is generally a no-op.  In
affine transformations, this is equivalent to
<code class="docutils literal notranslate"><span class="pre">transform(values)</span></code>.</p>
<p>Accepts a numpy array of shape (N x <code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code>) and
returns a numpy array of shape (N x <code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code>).</p>
<p>Alternatively, accepts a numpy array of length <code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code>
and returns a numpy array of length <code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.AffineBase.transform_non_affine">
<code class="descname">transform_non_affine</code><span class="sig-paren">(</span><em>points</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#AffineBase.transform_non_affine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.AffineBase.transform_non_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs only the non-affine part of the transformation.</p>
<p><code class="docutils literal notranslate"><span class="pre">transform(values)</span></code> is always equivalent to
<code class="docutils literal notranslate"><span class="pre">transform_affine(transform_non_affine(values))</span></code>.</p>
<p>In non-affine transformations, this is generally equivalent to
<code class="docutils literal notranslate"><span class="pre">transform(values)</span></code>.  In affine transformations, this is
always a no-op.</p>
<p>Accepts a numpy array of shape (N x <code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code>) and
returns a numpy array of shape (N x <code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code>).</p>
<p>Alternatively, accepts a numpy array of length <code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code>
and returns a numpy array of length <code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.AffineBase.transform_path">
<code class="descname">transform_path</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#AffineBase.transform_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.AffineBase.transform_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a transformed path.</p>
<p><em>path</em>: a <a class="reference internal" href="path_api.html#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> instance.</p>
<p>In some cases, this transform may insert curves into the path
that began as line segments.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.AffineBase.transform_path_affine">
<code class="descname">transform_path_affine</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#AffineBase.transform_path_affine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.AffineBase.transform_path_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a path, transformed only by the affine part of
this transform.</p>
<p><em>path</em>: a <a class="reference internal" href="path_api.html#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> instance.</p>
<p><code class="docutils literal notranslate"><span class="pre">transform_path(path)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">transform_path_affine(transform_path_non_affine(values))</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.AffineBase.transform_path_non_affine">
<code class="descname">transform_path_non_affine</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#AffineBase.transform_path_non_affine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.AffineBase.transform_path_non_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a path, transformed only by the non-affine
part of this transform.</p>
<p><em>path</em>: a <a class="reference internal" href="path_api.html#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> instance.</p>
<p><code class="docutils literal notranslate"><span class="pre">transform_path(path)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">transform_path_affine(transform_path_non_affine(values))</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.transforms.Bbox">
<em class="property">class </em><code class="descclassname">matplotlib.transforms.</code><code class="descname">Bbox</code><span class="sig-paren">(</span><em>points</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Bbox"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Bbox" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.transforms.BboxBase" title="matplotlib.transforms.BboxBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.transforms.BboxBase</span></code></a></p>
<p>A mutable bounding box.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">A 2x2 numpy array of the form <code class="docutils literal notranslate"><span class="pre">[[x0,</span> <span class="pre">y0],</span> <span class="pre">[x1,</span> <span class="pre">y1]]</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If you need to create a <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a> object from another form
of data, consider the static methods <a class="reference internal" href="#matplotlib.transforms.Bbox.unit" title="matplotlib.transforms.Bbox.unit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">unit()</span></code></a>,
<a class="reference internal" href="#matplotlib.transforms.Bbox.from_bounds" title="matplotlib.transforms.Bbox.from_bounds"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_bounds()</span></code></a> and <a class="reference internal" href="#matplotlib.transforms.Bbox.from_extents" title="matplotlib.transforms.Bbox.from_extents"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_extents()</span></code></a>.</p>
<dl class="attribute">
<dt id="matplotlib.transforms.Bbox.bounds">
<code class="descname">bounds</code><a class="headerlink" href="#matplotlib.transforms.Bbox.bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns (<a class="reference internal" href="#matplotlib.transforms.Bbox.x0" title="matplotlib.transforms.Bbox.x0"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x0</span></code></a>, <a class="reference internal" href="#matplotlib.transforms.Bbox.y0" title="matplotlib.transforms.Bbox.y0"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y0</span></code></a>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">width</span></code>,
<code class="xref py py-attr docutils literal notranslate"><span class="pre">height</span></code>).</p>
</dd></dl>

<dl class="staticmethod">
<dt id="matplotlib.transforms.Bbox.from_bounds">
<em class="property">static </em><code class="descname">from_bounds</code><span class="sig-paren">(</span><em>x0</em>, <em>y0</em>, <em>width</em>, <em>height</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Bbox.from_bounds"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Bbox.from_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>(staticmethod) Create a new <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a> from <em>x0</em>, <em>y0</em>,
<em>width</em> and <em>height</em>.</p>
<p><em>width</em> and <em>height</em> may be negative.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="matplotlib.transforms.Bbox.from_extents">
<em class="property">static </em><code class="descname">from_extents</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Bbox.from_extents"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Bbox.from_extents" title="Permalink to this definition">¶</a></dt>
<dd><p>(staticmethod) Create a new Bbox from <em>left</em>, <em>bottom</em>,
<em>right</em> and <em>top</em>.</p>
<p>The <em>y</em>-axis increases upwards.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Bbox.get_points">
<code class="descname">get_points</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Bbox.get_points"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Bbox.get_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the points of the bounding box directly as a numpy array
of the form: <code class="docutils literal notranslate"><span class="pre">[[x0,</span> <span class="pre">y0],</span> <span class="pre">[x1,</span> <span class="pre">y1]]</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Bbox.ignore">
<code class="descname">ignore</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Bbox.ignore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Bbox.ignore" title="Permalink to this definition">¶</a></dt>
<dd><p>Set whether the existing bounds of the box should be ignored
by subsequent calls to <a class="reference internal" href="#matplotlib.transforms.Bbox.update_from_data_xy" title="matplotlib.transforms.Bbox.update_from_data_xy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update_from_data_xy()</span></code></a>.</p>
<dl class="docutils">
<dt>value <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><ul class="first last simple">
<li>When <code class="docutils literal notranslate"><span class="pre">True</span></code>, subsequent calls to <a class="reference internal" href="#matplotlib.transforms.Bbox.update_from_data_xy" title="matplotlib.transforms.Bbox.update_from_data_xy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update_from_data_xy()</span></code></a>
will ignore the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a>.</li>
<li>When <code class="docutils literal notranslate"><span class="pre">False</span></code>, subsequent calls to <a class="reference internal" href="#matplotlib.transforms.Bbox.update_from_data_xy" title="matplotlib.transforms.Bbox.update_from_data_xy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">update_from_data_xy()</span></code></a>
will include the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a>.</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.Bbox.intervalx">
<code class="descname">intervalx</code><a class="headerlink" href="#matplotlib.transforms.Bbox.intervalx" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#matplotlib.transforms.Bbox.intervalx" title="matplotlib.transforms.Bbox.intervalx"><code class="xref py py-attr docutils literal notranslate"><span class="pre">intervalx</span></code></a> is the pair of <em>x</em> coordinates that define
the bounding box. It is not guaranteed to be sorted from left to right.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.Bbox.intervaly">
<code class="descname">intervaly</code><a class="headerlink" href="#matplotlib.transforms.Bbox.intervaly" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#matplotlib.transforms.Bbox.intervaly" title="matplotlib.transforms.Bbox.intervaly"><code class="xref py py-attr docutils literal notranslate"><span class="pre">intervaly</span></code></a> is the pair of <em>y</em> coordinates that define
the bounding box.  It is not guaranteed to be sorted from bottom to
top.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.Bbox.minpos">
<code class="descname">minpos</code><a class="headerlink" href="#matplotlib.transforms.Bbox.minpos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.Bbox.minposx">
<code class="descname">minposx</code><a class="headerlink" href="#matplotlib.transforms.Bbox.minposx" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.Bbox.minposy">
<code class="descname">minposy</code><a class="headerlink" href="#matplotlib.transforms.Bbox.minposy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Bbox.mutated">
<code class="descname">mutated</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Bbox.mutated"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Bbox.mutated" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the bbox has changed since init.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Bbox.mutatedx">
<code class="descname">mutatedx</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Bbox.mutatedx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Bbox.mutatedx" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the x-limits have changed since init.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Bbox.mutatedy">
<code class="descname">mutatedy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Bbox.mutatedy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Bbox.mutatedy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the y-limits have changed since init.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="matplotlib.transforms.Bbox.null">
<em class="property">static </em><code class="descname">null</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Bbox.null"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Bbox.null" title="Permalink to this definition">¶</a></dt>
<dd><p>(staticmethod) Create a new null <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a> from (inf, inf) to
(-inf, -inf).</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.Bbox.p0">
<code class="descname">p0</code><a class="headerlink" href="#matplotlib.transforms.Bbox.p0" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#matplotlib.transforms.Bbox.p0" title="matplotlib.transforms.Bbox.p0"><code class="xref py py-attr docutils literal notranslate"><span class="pre">p0</span></code></a> is the first pair of (<em>x</em>, <em>y</em>) coordinates that
define the bounding box.  It is not guaranteed to be the bottom-left
corner.  For that, use <code class="xref py py-attr docutils literal notranslate"><span class="pre">min</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.Bbox.p1">
<code class="descname">p1</code><a class="headerlink" href="#matplotlib.transforms.Bbox.p1" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#matplotlib.transforms.Bbox.p1" title="matplotlib.transforms.Bbox.p1"><code class="xref py py-attr docutils literal notranslate"><span class="pre">p1</span></code></a> is the second pair of (<em>x</em>, <em>y</em>) coordinates that
define the bounding box.  It is not guaranteed to be the top-right
corner.  For that, use <code class="xref py py-attr docutils literal notranslate"><span class="pre">max</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Bbox.set">
<code class="descname">set</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Bbox.set"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Bbox.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set this bounding box from the &quot;frozen&quot; bounds of another
<a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Bbox.set_points">
<code class="descname">set_points</code><span class="sig-paren">(</span><em>points</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Bbox.set_points"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Bbox.set_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the points of the bounding box directly from a numpy array
of the form: <code class="docutils literal notranslate"><span class="pre">[[x0,</span> <span class="pre">y0],</span> <span class="pre">[x1,</span> <span class="pre">y1]]</span></code>.  No error checking is
performed, as this method is mainly for internal use.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="matplotlib.transforms.Bbox.unit">
<em class="property">static </em><code class="descname">unit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Bbox.unit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Bbox.unit" title="Permalink to this definition">¶</a></dt>
<dd><p>(staticmethod) Create a new unit <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a> from (0, 0) to
(1, 1).</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Bbox.update_from_data_xy">
<code class="descname">update_from_data_xy</code><span class="sig-paren">(</span><em>xy</em>, <em>ignore=None</em>, <em>updatex=True</em>, <em>updatey=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Bbox.update_from_data_xy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Bbox.update_from_data_xy" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a> based on the passed in
data.  After updating, the bounds will have positive <em>width</em>
and <em>height</em>; <em>x0</em> and <em>y0</em> will be the minimal values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>xy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">A numpy array of 2D points.</p>
</dd>
<dt><strong>ignore</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><ul class="first last simple">
<li>When <code class="docutils literal notranslate"><span class="pre">True</span></code>, ignore the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a>.</li>
<li>When <code class="docutils literal notranslate"><span class="pre">False</span></code>, include the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a>.</li>
<li>When <code class="docutils literal notranslate"><span class="pre">None</span></code>, use the last value passed to <a class="reference internal" href="#matplotlib.transforms.Bbox.ignore" title="matplotlib.transforms.Bbox.ignore"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ignore()</span></code></a>.</li>
</ul>
</dd>
<dt><strong>updatex, updatey</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">When <code class="docutils literal notranslate"><span class="pre">True</span></code>, update the x/y values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Bbox.update_from_path">
<code class="descname">update_from_path</code><span class="sig-paren">(</span><em>path</em>, <em>ignore=None</em>, <em>updatex=True</em>, <em>updatey=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Bbox.update_from_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Bbox.update_from_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a> based on the passed in
data.  After updating, the bounds will have positive <em>width</em>
and <em>height</em>; <em>x0</em> and <em>y0</em> will be the minimal values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>path</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="path_api.html#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a></span></dt>
<dd></dd>
<dt><strong>ignore</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><ul class="first last simple">
<li>when <code class="docutils literal notranslate"><span class="pre">True</span></code>, ignore the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a>.</li>
<li>when <code class="docutils literal notranslate"><span class="pre">False</span></code>, include the existing bounds of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a>.</li>
<li>when <code class="docutils literal notranslate"><span class="pre">None</span></code>, use the last value passed to <a class="reference internal" href="#matplotlib.transforms.Bbox.ignore" title="matplotlib.transforms.Bbox.ignore"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ignore()</span></code></a>.</li>
</ul>
</dd>
<dt><strong>updatex, updatey</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional</span></dt>
<dd><p class="first last">When <code class="docutils literal notranslate"><span class="pre">True</span></code>, update the x/y values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.Bbox.x0">
<code class="descname">x0</code><a class="headerlink" href="#matplotlib.transforms.Bbox.x0" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#matplotlib.transforms.Bbox.x0" title="matplotlib.transforms.Bbox.x0"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x0</span></code></a> is the first of the pair of <em>x</em> coordinates that
define the bounding box. <a class="reference internal" href="#matplotlib.transforms.Bbox.x0" title="matplotlib.transforms.Bbox.x0"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x0</span></code></a> is not guaranteed to be less than
<a class="reference internal" href="#matplotlib.transforms.Bbox.x1" title="matplotlib.transforms.Bbox.x1"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x1</span></code></a>.  If you require that, use <code class="xref py py-attr docutils literal notranslate"><span class="pre">xmin</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.Bbox.x1">
<code class="descname">x1</code><a class="headerlink" href="#matplotlib.transforms.Bbox.x1" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#matplotlib.transforms.Bbox.x1" title="matplotlib.transforms.Bbox.x1"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x1</span></code></a> is the second of the pair of <em>x</em> coordinates that
define the bounding box. <a class="reference internal" href="#matplotlib.transforms.Bbox.x1" title="matplotlib.transforms.Bbox.x1"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x1</span></code></a> is not guaranteed to be greater
than <a class="reference internal" href="#matplotlib.transforms.Bbox.x0" title="matplotlib.transforms.Bbox.x0"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x0</span></code></a>.  If you require that, use <code class="xref py py-attr docutils literal notranslate"><span class="pre">xmax</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.Bbox.y0">
<code class="descname">y0</code><a class="headerlink" href="#matplotlib.transforms.Bbox.y0" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#matplotlib.transforms.Bbox.y0" title="matplotlib.transforms.Bbox.y0"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y0</span></code></a> is the first of the pair of <em>y</em> coordinates that
define the bounding box. <a class="reference internal" href="#matplotlib.transforms.Bbox.y0" title="matplotlib.transforms.Bbox.y0"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y0</span></code></a> is not guaranteed to be less than
<a class="reference internal" href="#matplotlib.transforms.Bbox.y1" title="matplotlib.transforms.Bbox.y1"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y1</span></code></a>.  If you require that, use <code class="xref py py-attr docutils literal notranslate"><span class="pre">ymin</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.Bbox.y1">
<code class="descname">y1</code><a class="headerlink" href="#matplotlib.transforms.Bbox.y1" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#matplotlib.transforms.Bbox.y1" title="matplotlib.transforms.Bbox.y1"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y1</span></code></a> is the second of the pair of <em>y</em> coordinates that
define the bounding box. <a class="reference internal" href="#matplotlib.transforms.Bbox.y1" title="matplotlib.transforms.Bbox.y1"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y1</span></code></a> is not guaranteed to be greater
than <a class="reference internal" href="#matplotlib.transforms.Bbox.y0" title="matplotlib.transforms.Bbox.y0"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y0</span></code></a>.  If you require that, use <code class="xref py py-attr docutils literal notranslate"><span class="pre">ymax</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.transforms.BboxBase">
<em class="property">class </em><code class="descclassname">matplotlib.transforms.</code><code class="descname">BboxBase</code><span class="sig-paren">(</span><em>shorthand_name=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxBase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.transforms.TransformNode</span></code></a></p>
<p>This is the base class of all bounding boxes, and provides
read-only access to its data.  A mutable bounding box is provided
by the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a> class.</p>
<p>The canonical representation is as two points, with no
restrictions on their ordering.  Convenience properties are
provided to get the left, bottom, right and top edges and width
and height, but these are not stored explicitly.</p>
<p>Creates a new <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransformNode</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>shorthand_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">A string representing the &quot;name&quot; of the transform. The name carries
no significance other than to improve the readability of
<code class="docutils literal notranslate"><span class="pre">str(transform)</span></code> when DEBUG=True.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="matplotlib.transforms.BboxBase.anchored">
<code class="descname">anchored</code><span class="sig-paren">(</span><em>c</em>, <em>container=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxBase.anchored"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxBase.anchored" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a>, shifted to position <em>c</em>
within a container.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>c :</strong></dt>
<dd><p class="first">May be either:</p>
<ul class="last simple">
<li>A sequence (<em>cx</em>, <em>cy</em>) where <em>cx</em> and <em>cy</em> range from 0
to 1, where 0 is left or bottom and 1 is right or top</li>
<li>a string:
- 'C' for centered
- 'S' for bottom-center
- 'SE' for bottom-left
- 'E' for left
- etc.</li>
</ul>
</dd>
<dt><strong>container</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Bbox, optional</span></dt>
<dd><p class="first last">The box within which the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a> is positioned; it defaults
to the initial <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BboxBase.bounds">
<code class="descname">bounds</code><a class="headerlink" href="#matplotlib.transforms.BboxBase.bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns (<a class="reference internal" href="#matplotlib.transforms.BboxBase.x0" title="matplotlib.transforms.BboxBase.x0"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x0</span></code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.y0" title="matplotlib.transforms.BboxBase.y0"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y0</span></code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.width" title="matplotlib.transforms.BboxBase.width"><code class="xref py py-attr docutils literal notranslate"><span class="pre">width</span></code></a>,
<a class="reference internal" href="#matplotlib.transforms.BboxBase.height" title="matplotlib.transforms.BboxBase.height"><code class="xref py py-attr docutils literal notranslate"><span class="pre">height</span></code></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BboxBase.coefs">
<code class="descname">coefs</code><em class="property"> = {'C': (0.5, 0.5), 'E': (1.0, 0.5), 'N': (0.5, 1.0), 'NE': (1.0, 1.0), 'NW': (0, 1.0), 'S': (0.5, 0), 'SE': (1.0, 0), 'SW': (0, 0), 'W': (0, 0.5)}</em><a class="headerlink" href="#matplotlib.transforms.BboxBase.coefs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BboxBase.contains">
<code class="descname">contains</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxBase.contains"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxBase.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether <code class="docutils literal notranslate"><span class="pre">(x,</span> <span class="pre">y)</span></code> is in the bounding box or on its edge.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BboxBase.containsx">
<code class="descname">containsx</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxBase.containsx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxBase.containsx" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether <em>x</em> is in the closed (<a class="reference internal" href="#matplotlib.transforms.BboxBase.x0" title="matplotlib.transforms.BboxBase.x0"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x0</span></code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.x1" title="matplotlib.transforms.BboxBase.x1"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x1</span></code></a>) interval.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BboxBase.containsy">
<code class="descname">containsy</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxBase.containsy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxBase.containsy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether <em>y</em> is in the closed (<a class="reference internal" href="#matplotlib.transforms.BboxBase.y0" title="matplotlib.transforms.BboxBase.y0"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y0</span></code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.y1" title="matplotlib.transforms.BboxBase.y1"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y1</span></code></a>) interval.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BboxBase.corners">
<code class="descname">corners</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxBase.corners"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxBase.corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of points which are the four corners of this
rectangle.  For example, if this <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a> is defined by
the points (<em>a</em>, <em>b</em>) and (<em>c</em>, <em>d</em>), <a class="reference internal" href="#matplotlib.transforms.BboxBase.corners" title="matplotlib.transforms.BboxBase.corners"><code class="xref py py-meth docutils literal notranslate"><span class="pre">corners()</span></code></a> returns
(<em>a</em>, <em>b</em>), (<em>a</em>, <em>d</em>), (<em>c</em>, <em>b</em>) and (<em>c</em>, <em>d</em>).</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BboxBase.count_contains">
<code class="descname">count_contains</code><span class="sig-paren">(</span><em>vertices</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxBase.count_contains"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxBase.count_contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of vertices contained in the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a>.
Any vertices with a non-finite x or y value are ignored.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>vertices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Nx2 Numpy array.</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BboxBase.count_overlaps">
<code class="descname">count_overlaps</code><span class="sig-paren">(</span><em>bboxes</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxBase.count_overlaps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxBase.count_overlaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of bounding boxes that overlap this one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>bboxes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of <a class="reference internal" href="#matplotlib.transforms.BboxBase" title="matplotlib.transforms.BboxBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">BboxBase</span></code></a> objects</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BboxBase.expanded">
<code class="descname">expanded</code><span class="sig-paren">(</span><em>sw</em>, <em>sh</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxBase.expanded"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxBase.expanded" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a> which is this <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a>
expanded around its center by the given factors <em>sw</em> and
<em>sh</em>.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BboxBase.extents">
<code class="descname">extents</code><a class="headerlink" href="#matplotlib.transforms.BboxBase.extents" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns (<a class="reference internal" href="#matplotlib.transforms.BboxBase.x0" title="matplotlib.transforms.BboxBase.x0"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x0</span></code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.y0" title="matplotlib.transforms.BboxBase.y0"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y0</span></code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.x1" title="matplotlib.transforms.BboxBase.x1"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x1</span></code></a>,
<a class="reference internal" href="#matplotlib.transforms.BboxBase.y1" title="matplotlib.transforms.BboxBase.y1"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y1</span></code></a>).</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BboxBase.frozen">
<code class="descname">frozen</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxBase.frozen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxBase.frozen" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransformNode</span></code></a> is the base class for anything that
participates in the transform tree and needs to invalidate its
parents or be invalidated.  This includes classes that are not
really transforms, such as bounding boxes, since some transforms
depend on bounding boxes to compute their values.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BboxBase.fully_contains">
<code class="descname">fully_contains</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxBase.fully_contains"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxBase.fully_contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether <code class="docutils literal notranslate"><span class="pre">x,</span> <span class="pre">y</span></code> is in the bounding box, but not on its edge.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BboxBase.fully_containsx">
<code class="descname">fully_containsx</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxBase.fully_containsx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxBase.fully_containsx" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether <em>x</em> is in the open (<a class="reference internal" href="#matplotlib.transforms.BboxBase.x0" title="matplotlib.transforms.BboxBase.x0"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x0</span></code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.x1" title="matplotlib.transforms.BboxBase.x1"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x1</span></code></a>) interval.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BboxBase.fully_containsy">
<code class="descname">fully_containsy</code><span class="sig-paren">(</span><em>y</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxBase.fully_containsy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxBase.fully_containsy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether <em>y</em> is in the open (<a class="reference internal" href="#matplotlib.transforms.BboxBase.y0" title="matplotlib.transforms.BboxBase.y0"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y0</span></code></a>, <a class="reference internal" href="#matplotlib.transforms.BboxBase.y1" title="matplotlib.transforms.BboxBase.y1"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y1</span></code></a>) interval.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BboxBase.fully_overlaps">
<code class="descname">fully_overlaps</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxBase.fully_overlaps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxBase.fully_overlaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether this bounding box overlaps with the other bounding box,
not including the edges.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>other</strong> <span class="classifier-delimiter">:</span> <span class="classifier">BboxBase</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BboxBase.get_points">
<code class="descname">get_points</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxBase.get_points"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxBase.get_points" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BboxBase.height">
<code class="descname">height</code><a class="headerlink" href="#matplotlib.transforms.BboxBase.height" title="Permalink to this definition">¶</a></dt>
<dd><p>The height of the bounding box.  It may be negative if
<a class="reference internal" href="#matplotlib.transforms.BboxBase.y1" title="matplotlib.transforms.BboxBase.y1"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y1</span></code></a> &lt; <a class="reference internal" href="#matplotlib.transforms.BboxBase.y0" title="matplotlib.transforms.BboxBase.y0"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y0</span></code></a>.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="matplotlib.transforms.BboxBase.intersection">
<em class="property">static </em><code class="descname">intersection</code><span class="sig-paren">(</span><em>bbox1</em>, <em>bbox2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxBase.intersection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxBase.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the intersection of the two bboxes or None
if they do not intersect.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BboxBase.intervalx">
<code class="descname">intervalx</code><a class="headerlink" href="#matplotlib.transforms.BboxBase.intervalx" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#matplotlib.transforms.BboxBase.intervalx" title="matplotlib.transforms.BboxBase.intervalx"><code class="xref py py-attr docutils literal notranslate"><span class="pre">intervalx</span></code></a> is the pair of <em>x</em> coordinates that define
the bounding box. It is not guaranteed to be sorted from left to right.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BboxBase.intervaly">
<code class="descname">intervaly</code><a class="headerlink" href="#matplotlib.transforms.BboxBase.intervaly" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#matplotlib.transforms.BboxBase.intervaly" title="matplotlib.transforms.BboxBase.intervaly"><code class="xref py py-attr docutils literal notranslate"><span class="pre">intervaly</span></code></a> is the pair of <em>y</em> coordinates that define
the bounding box.  It is not guaranteed to be sorted from bottom to
top.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BboxBase.inverse_transformed">
<code class="descname">inverse_transformed</code><span class="sig-paren">(</span><em>transform</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxBase.inverse_transformed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxBase.inverse_transformed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a> object, statically transformed by
the inverse of the given transform.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BboxBase.is_affine">
<code class="descname">is_affine</code><em class="property"> = True</em><a class="headerlink" href="#matplotlib.transforms.BboxBase.is_affine" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BboxBase.is_bbox">
<code class="descname">is_bbox</code><em class="property"> = True</em><a class="headerlink" href="#matplotlib.transforms.BboxBase.is_bbox" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BboxBase.is_unit">
<code class="descname">is_unit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxBase.is_unit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxBase.is_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a> is the unit bounding box
from (0, 0) to (1, 1).</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BboxBase.max">
<code class="descname">max</code><a class="headerlink" href="#matplotlib.transforms.BboxBase.max" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#matplotlib.transforms.BboxBase.max" title="matplotlib.transforms.BboxBase.max"><code class="xref py py-attr docutils literal notranslate"><span class="pre">max</span></code></a> is the top-right corner of the bounding box.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BboxBase.min">
<code class="descname">min</code><a class="headerlink" href="#matplotlib.transforms.BboxBase.min" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#matplotlib.transforms.BboxBase.min" title="matplotlib.transforms.BboxBase.min"><code class="xref py py-attr docutils literal notranslate"><span class="pre">min</span></code></a> is the bottom-left corner of the bounding box.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BboxBase.overlaps">
<code class="descname">overlaps</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxBase.overlaps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxBase.overlaps" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether this bounding box overlaps with the other bounding box.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>other</strong> <span class="classifier-delimiter">:</span> <span class="classifier">BboxBase</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BboxBase.p0">
<code class="descname">p0</code><a class="headerlink" href="#matplotlib.transforms.BboxBase.p0" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#matplotlib.transforms.BboxBase.p0" title="matplotlib.transforms.BboxBase.p0"><code class="xref py py-attr docutils literal notranslate"><span class="pre">p0</span></code></a> is the first pair of (<em>x</em>, <em>y</em>) coordinates that
define the bounding box.  It is not guaranteed to be the bottom-left
corner.  For that, use <a class="reference internal" href="#matplotlib.transforms.BboxBase.min" title="matplotlib.transforms.BboxBase.min"><code class="xref py py-attr docutils literal notranslate"><span class="pre">min</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BboxBase.p1">
<code class="descname">p1</code><a class="headerlink" href="#matplotlib.transforms.BboxBase.p1" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#matplotlib.transforms.BboxBase.p1" title="matplotlib.transforms.BboxBase.p1"><code class="xref py py-attr docutils literal notranslate"><span class="pre">p1</span></code></a> is the second pair of (<em>x</em>, <em>y</em>) coordinates that
define the bounding box.  It is not guaranteed to be the top-right
corner.  For that, use <a class="reference internal" href="#matplotlib.transforms.BboxBase.max" title="matplotlib.transforms.BboxBase.max"><code class="xref py py-attr docutils literal notranslate"><span class="pre">max</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BboxBase.padded">
<code class="descname">padded</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxBase.padded"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxBase.padded" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a> that is padded on all four sides by
the given value.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BboxBase.rotated">
<code class="descname">rotated</code><span class="sig-paren">(</span><em>radians</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxBase.rotated"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxBase.rotated" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new bounding box that bounds a rotated version of
this bounding box by the given radians.  The new bounding box
is still aligned with the axes, of course.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BboxBase.shrunk">
<code class="descname">shrunk</code><span class="sig-paren">(</span><em>mx</em>, <em>my</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxBase.shrunk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxBase.shrunk" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a>, shrunk by the factor <em>mx</em>
in the <em>x</em> direction and the factor <em>my</em> in the <em>y</em> direction.
The lower left corner of the box remains unchanged.  Normally
<em>mx</em> and <em>my</em> will be less than 1, but this is not enforced.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BboxBase.shrunk_to_aspect">
<code class="descname">shrunk_to_aspect</code><span class="sig-paren">(</span><em>box_aspect</em>, <em>container=None</em>, <em>fig_aspect=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxBase.shrunk_to_aspect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxBase.shrunk_to_aspect" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a>, shrunk so that it is as
large as it can be while having the desired aspect ratio,
<em>box_aspect</em>.  If the box coordinates are relative---that
is, fractions of a larger box such as a figure---then the
physical aspect ratio of that figure is specified with
<em>fig_aspect</em>, so that <em>box_aspect</em> can also be given as a
ratio of the absolute dimensions, not the relative dimensions.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BboxBase.size">
<code class="descname">size</code><a class="headerlink" href="#matplotlib.transforms.BboxBase.size" title="Permalink to this definition">¶</a></dt>
<dd><p>The width and height of the bounding box.  May be negative,
in the same way as <a class="reference internal" href="#matplotlib.transforms.BboxBase.width" title="matplotlib.transforms.BboxBase.width"><code class="xref py py-attr docutils literal notranslate"><span class="pre">width</span></code></a> and <a class="reference internal" href="#matplotlib.transforms.BboxBase.height" title="matplotlib.transforms.BboxBase.height"><code class="xref py py-attr docutils literal notranslate"><span class="pre">height</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BboxBase.splitx">
<code class="descname">splitx</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxBase.splitx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxBase.splitx" title="Permalink to this definition">¶</a></dt>
<dd><p>e.g., <code class="docutils literal notranslate"><span class="pre">bbox.splitx(f1,</span> <span class="pre">f2,</span> <span class="pre">...)</span></code></p>
<p>Returns a list of new <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a> objects formed by
splitting the original one with vertical lines at fractional
positions <em>f1</em>, <em>f2</em>, ...</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BboxBase.splity">
<code class="descname">splity</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxBase.splity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxBase.splity" title="Permalink to this definition">¶</a></dt>
<dd><p>e.g., <code class="docutils literal notranslate"><span class="pre">bbox.splitx(f1,</span> <span class="pre">f2,</span> <span class="pre">...)</span></code></p>
<p>Returns a list of new <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a> objects formed by
splitting the original one with horizontal lines at fractional
positions <em>f1</em>, <em>f2</em>, ...</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BboxBase.transformed">
<code class="descname">transformed</code><span class="sig-paren">(</span><em>transform</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxBase.transformed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxBase.transformed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a> object, statically transformed by
the given transform.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BboxBase.translated">
<code class="descname">translated</code><span class="sig-paren">(</span><em>tx</em>, <em>ty</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxBase.translated"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxBase.translated" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a>, statically translated by
<em>tx</em> and <em>ty</em>.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="matplotlib.transforms.BboxBase.union">
<em class="property">static </em><code class="descname">union</code><span class="sig-paren">(</span><em>bboxes</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxBase.union"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxBase.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a> that contains all of the given bboxes.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BboxBase.width">
<code class="descname">width</code><a class="headerlink" href="#matplotlib.transforms.BboxBase.width" title="Permalink to this definition">¶</a></dt>
<dd><p>The width of the bounding box.  It may be negative if
<a class="reference internal" href="#matplotlib.transforms.BboxBase.x1" title="matplotlib.transforms.BboxBase.x1"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x1</span></code></a> &lt; <a class="reference internal" href="#matplotlib.transforms.BboxBase.x0" title="matplotlib.transforms.BboxBase.x0"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x0</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BboxBase.x0">
<code class="descname">x0</code><a class="headerlink" href="#matplotlib.transforms.BboxBase.x0" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#matplotlib.transforms.BboxBase.x0" title="matplotlib.transforms.BboxBase.x0"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x0</span></code></a> is the first of the pair of <em>x</em> coordinates that
define the bounding box. <a class="reference internal" href="#matplotlib.transforms.BboxBase.x0" title="matplotlib.transforms.BboxBase.x0"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x0</span></code></a> is not guaranteed to be less than
<a class="reference internal" href="#matplotlib.transforms.BboxBase.x1" title="matplotlib.transforms.BboxBase.x1"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x1</span></code></a>.  If you require that, use <a class="reference internal" href="#matplotlib.transforms.BboxBase.xmin" title="matplotlib.transforms.BboxBase.xmin"><code class="xref py py-attr docutils literal notranslate"><span class="pre">xmin</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BboxBase.x1">
<code class="descname">x1</code><a class="headerlink" href="#matplotlib.transforms.BboxBase.x1" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#matplotlib.transforms.BboxBase.x1" title="matplotlib.transforms.BboxBase.x1"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x1</span></code></a> is the second of the pair of <em>x</em> coordinates that
define the bounding box. <a class="reference internal" href="#matplotlib.transforms.BboxBase.x1" title="matplotlib.transforms.BboxBase.x1"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x1</span></code></a> is not guaranteed to be greater
than <a class="reference internal" href="#matplotlib.transforms.BboxBase.x0" title="matplotlib.transforms.BboxBase.x0"><code class="xref py py-attr docutils literal notranslate"><span class="pre">x0</span></code></a>.  If you require that, use <a class="reference internal" href="#matplotlib.transforms.BboxBase.xmax" title="matplotlib.transforms.BboxBase.xmax"><code class="xref py py-attr docutils literal notranslate"><span class="pre">xmax</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BboxBase.xmax">
<code class="descname">xmax</code><a class="headerlink" href="#matplotlib.transforms.BboxBase.xmax" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#matplotlib.transforms.BboxBase.xmax" title="matplotlib.transforms.BboxBase.xmax"><code class="xref py py-attr docutils literal notranslate"><span class="pre">xmax</span></code></a> is the right edge of the bounding box.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BboxBase.xmin">
<code class="descname">xmin</code><a class="headerlink" href="#matplotlib.transforms.BboxBase.xmin" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#matplotlib.transforms.BboxBase.xmin" title="matplotlib.transforms.BboxBase.xmin"><code class="xref py py-attr docutils literal notranslate"><span class="pre">xmin</span></code></a> is the left edge of the bounding box.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BboxBase.y0">
<code class="descname">y0</code><a class="headerlink" href="#matplotlib.transforms.BboxBase.y0" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#matplotlib.transforms.BboxBase.y0" title="matplotlib.transforms.BboxBase.y0"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y0</span></code></a> is the first of the pair of <em>y</em> coordinates that
define the bounding box. <a class="reference internal" href="#matplotlib.transforms.BboxBase.y0" title="matplotlib.transforms.BboxBase.y0"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y0</span></code></a> is not guaranteed to be less than
<a class="reference internal" href="#matplotlib.transforms.BboxBase.y1" title="matplotlib.transforms.BboxBase.y1"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y1</span></code></a>.  If you require that, use <a class="reference internal" href="#matplotlib.transforms.BboxBase.ymin" title="matplotlib.transforms.BboxBase.ymin"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ymin</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BboxBase.y1">
<code class="descname">y1</code><a class="headerlink" href="#matplotlib.transforms.BboxBase.y1" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#matplotlib.transforms.BboxBase.y1" title="matplotlib.transforms.BboxBase.y1"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y1</span></code></a> is the second of the pair of <em>y</em> coordinates that
define the bounding box. <a class="reference internal" href="#matplotlib.transforms.BboxBase.y1" title="matplotlib.transforms.BboxBase.y1"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y1</span></code></a> is not guaranteed to be greater
than <a class="reference internal" href="#matplotlib.transforms.BboxBase.y0" title="matplotlib.transforms.BboxBase.y0"><code class="xref py py-attr docutils literal notranslate"><span class="pre">y0</span></code></a>.  If you require that, use <a class="reference internal" href="#matplotlib.transforms.BboxBase.ymax" title="matplotlib.transforms.BboxBase.ymax"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ymax</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BboxBase.ymax">
<code class="descname">ymax</code><a class="headerlink" href="#matplotlib.transforms.BboxBase.ymax" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#matplotlib.transforms.BboxBase.ymax" title="matplotlib.transforms.BboxBase.ymax"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ymax</span></code></a> is the top edge of the bounding box.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BboxBase.ymin">
<code class="descname">ymin</code><a class="headerlink" href="#matplotlib.transforms.BboxBase.ymin" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#matplotlib.transforms.BboxBase.ymin" title="matplotlib.transforms.BboxBase.ymin"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ymin</span></code></a> is the bottom edge of the bounding box.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.transforms.BboxTransform">
<em class="property">class </em><code class="descclassname">matplotlib.transforms.</code><code class="descname">BboxTransform</code><span class="sig-paren">(</span><em>boxin</em>, <em>boxout</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxTransform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.transforms.Affine2DBase</span></code></a></p>
<p><a class="reference internal" href="#matplotlib.transforms.BboxTransform" title="matplotlib.transforms.BboxTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">BboxTransform</span></code></a> linearly transforms points from one
<a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a> to another <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a>.</p>
<p>Create a new <a class="reference internal" href="#matplotlib.transforms.BboxTransform" title="matplotlib.transforms.BboxTransform"><code class="xref py py-class docutils literal notranslate"><span class="pre">BboxTransform</span></code></a> that linearly transforms
points from <em>boxin</em> to <em>boxout</em>.</p>
<dl class="method">
<dt id="matplotlib.transforms.BboxTransform.get_matrix">
<code class="descname">get_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxTransform.get_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxTransform.get_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Affine transformation array for the affine part
of this transform.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BboxTransform.is_separable">
<code class="descname">is_separable</code><em class="property"> = True</em><a class="headerlink" href="#matplotlib.transforms.BboxTransform.is_separable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.transforms.BboxTransformFrom">
<em class="property">class </em><code class="descclassname">matplotlib.transforms.</code><code class="descname">BboxTransformFrom</code><span class="sig-paren">(</span><em>boxin</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxTransformFrom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxTransformFrom" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.transforms.Affine2DBase</span></code></a></p>
<p><a class="reference internal" href="#matplotlib.transforms.BboxTransformFrom" title="matplotlib.transforms.BboxTransformFrom"><code class="xref py py-class docutils literal notranslate"><span class="pre">BboxTransformFrom</span></code></a> linearly transforms points from a given
<a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a> to the unit bounding box.</p>
<dl class="method">
<dt id="matplotlib.transforms.BboxTransformFrom.get_matrix">
<code class="descname">get_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxTransformFrom.get_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxTransformFrom.get_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Affine transformation array for the affine part
of this transform.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BboxTransformFrom.is_separable">
<code class="descname">is_separable</code><em class="property"> = True</em><a class="headerlink" href="#matplotlib.transforms.BboxTransformFrom.is_separable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.transforms.BboxTransformTo">
<em class="property">class </em><code class="descclassname">matplotlib.transforms.</code><code class="descname">BboxTransformTo</code><span class="sig-paren">(</span><em>boxout</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxTransformTo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxTransformTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.transforms.Affine2DBase</span></code></a></p>
<p><a class="reference internal" href="#matplotlib.transforms.BboxTransformTo" title="matplotlib.transforms.BboxTransformTo"><code class="xref py py-class docutils literal notranslate"><span class="pre">BboxTransformTo</span></code></a> is a transformation that linearly
transforms points from the unit bounding box to a given
<a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a>.</p>
<p>Create a new <a class="reference internal" href="#matplotlib.transforms.BboxTransformTo" title="matplotlib.transforms.BboxTransformTo"><code class="xref py py-class docutils literal notranslate"><span class="pre">BboxTransformTo</span></code></a> that linearly transforms
points from the unit bounding box to <em>boxout</em>.</p>
<dl class="method">
<dt id="matplotlib.transforms.BboxTransformTo.get_matrix">
<code class="descname">get_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxTransformTo.get_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxTransformTo.get_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Affine transformation array for the affine part
of this transform.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BboxTransformTo.is_separable">
<code class="descname">is_separable</code><em class="property"> = True</em><a class="headerlink" href="#matplotlib.transforms.BboxTransformTo.is_separable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.transforms.BboxTransformToMaxOnly">
<em class="property">class </em><code class="descclassname">matplotlib.transforms.</code><code class="descname">BboxTransformToMaxOnly</code><span class="sig-paren">(</span><em>boxout</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxTransformToMaxOnly"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxTransformToMaxOnly" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.transforms.BboxTransformTo" title="matplotlib.transforms.BboxTransformTo"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.transforms.BboxTransformTo</span></code></a></p>
<p><a class="reference internal" href="#matplotlib.transforms.BboxTransformTo" title="matplotlib.transforms.BboxTransformTo"><code class="xref py py-class docutils literal notranslate"><span class="pre">BboxTransformTo</span></code></a> is a transformation that linearly
transforms points from the unit bounding box to a given
<a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a> with a fixed upper left of (0, 0).</p>
<p>Create a new <a class="reference internal" href="#matplotlib.transforms.BboxTransformTo" title="matplotlib.transforms.BboxTransformTo"><code class="xref py py-class docutils literal notranslate"><span class="pre">BboxTransformTo</span></code></a> that linearly transforms
points from the unit bounding box to <em>boxout</em>.</p>
<dl class="method">
<dt id="matplotlib.transforms.BboxTransformToMaxOnly.get_matrix">
<code class="descname">get_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BboxTransformToMaxOnly.get_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BboxTransformToMaxOnly.get_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Affine transformation array for the affine part
of this transform.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.transforms.BlendedAffine2D">
<em class="property">class </em><code class="descclassname">matplotlib.transforms.</code><code class="descname">BlendedAffine2D</code><span class="sig-paren">(</span><em>x_transform</em>, <em>y_transform</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BlendedAffine2D"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BlendedAffine2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.transforms.Affine2DBase</span></code></a></p>
<p>A &quot;blended&quot; transform uses one transform for the <em>x</em>-direction, and
another transform for the <em>y</em>-direction.</p>
<p>This version is an optimization for the case where both child
transforms are of type <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">Affine2DBase</span></code></a>.</p>
<p>Create a new &quot;blended&quot; transform using <em>x_transform</em> to
transform the <em>x</em>-axis and <em>y_transform</em> to transform the
<em>y</em>-axis.</p>
<p>Both <em>x_transform</em> and <em>y_transform</em> must be 2D affine
transforms.</p>
<p>You will generally not call this constructor directly but use
the <a class="reference internal" href="#matplotlib.transforms.blended_transform_factory" title="matplotlib.transforms.blended_transform_factory"><code class="xref py py-func docutils literal notranslate"><span class="pre">blended_transform_factory()</span></code></a> function instead, which
can determine automatically which kind of blended transform to
create.</p>
<dl class="method">
<dt id="matplotlib.transforms.BlendedAffine2D.contains_branch_seperately">
<code class="descname">contains_branch_seperately</code><span class="sig-paren">(</span><em>transform</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BlendedAffine2D.contains_branch_seperately"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BlendedAffine2D.contains_branch_seperately" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the given branch is a sub-tree of this transform on
each separate dimension.</p>
<p>A common use for this method is to identify if a transform is a blended
transform containing an axes' data transform. e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x_isdata</span><span class="p">,</span> <span class="n">y_isdata</span> <span class="o">=</span> <span class="n">trans</span><span class="o">.</span><span class="n">contains_branch_seperately</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BlendedAffine2D.get_matrix">
<code class="descname">get_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BlendedAffine2D.get_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BlendedAffine2D.get_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Affine transformation array for the affine part
of this transform.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BlendedAffine2D.is_separable">
<code class="descname">is_separable</code><em class="property"> = True</em><a class="headerlink" href="#matplotlib.transforms.BlendedAffine2D.is_separable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.transforms.BlendedGenericTransform">
<em class="property">class </em><code class="descclassname">matplotlib.transforms.</code><code class="descname">BlendedGenericTransform</code><span class="sig-paren">(</span><em>x_transform</em>, <em>y_transform</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BlendedGenericTransform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BlendedGenericTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.transforms.Transform</span></code></a></p>
<p>A &quot;blended&quot; transform uses one transform for the <em>x</em>-direction, and
another transform for the <em>y</em>-direction.</p>
<p>This &quot;generic&quot; version can handle any given child transform in the
<em>x</em>- and <em>y</em>-directions.</p>
<p>Create a new &quot;blended&quot; transform using <em>x_transform</em> to
transform the <em>x</em>-axis and <em>y_transform</em> to transform the
<em>y</em>-axis.</p>
<p>You will generally not call this constructor directly but use
the <a class="reference internal" href="#matplotlib.transforms.blended_transform_factory" title="matplotlib.transforms.blended_transform_factory"><code class="xref py py-func docutils literal notranslate"><span class="pre">blended_transform_factory()</span></code></a> function instead, which
can determine automatically which kind of blended transform to
create.</p>
<dl class="method">
<dt id="matplotlib.transforms.BlendedGenericTransform.contains_branch">
<code class="descname">contains_branch</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BlendedGenericTransform.contains_branch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BlendedGenericTransform.contains_branch" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the given transform is a sub-tree of this transform.</p>
<p>This routine uses transform equality to identify sub-trees, therefore
in many situations it is object id which will be used.</p>
<p>For the case where the given transform represents the whole
of this transform, returns True.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BlendedGenericTransform.contains_branch_seperately">
<code class="descname">contains_branch_seperately</code><span class="sig-paren">(</span><em>transform</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BlendedGenericTransform.contains_branch_seperately"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BlendedGenericTransform.contains_branch_seperately" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the given branch is a sub-tree of this transform on
each separate dimension.</p>
<p>A common use for this method is to identify if a transform is a blended
transform containing an axes' data transform. e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x_isdata</span><span class="p">,</span> <span class="n">y_isdata</span> <span class="o">=</span> <span class="n">trans</span><span class="o">.</span><span class="n">contains_branch_seperately</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BlendedGenericTransform.depth">
<code class="descname">depth</code><a class="headerlink" href="#matplotlib.transforms.BlendedGenericTransform.depth" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of transforms which have been chained
together to form this Transform instance.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For the special case of a Composite transform, the maximum depth
of the two is returned.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BlendedGenericTransform.frozen">
<code class="descname">frozen</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BlendedGenericTransform.frozen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BlendedGenericTransform.frozen" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a frozen copy of this transform node.  The frozen copy
will not update when its children change.  Useful for storing
a previously known state of a transform where
<code class="docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code> might normally be used.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BlendedGenericTransform.get_affine">
<code class="descname">get_affine</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BlendedGenericTransform.get_affine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BlendedGenericTransform.get_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the affine part of this transform.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BlendedGenericTransform.has_inverse">
<code class="descname">has_inverse</code><a class="headerlink" href="#matplotlib.transforms.BlendedGenericTransform.has_inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BlendedGenericTransform.input_dims">
<code class="descname">input_dims</code><em class="property"> = 2</em><a class="headerlink" href="#matplotlib.transforms.BlendedGenericTransform.input_dims" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BlendedGenericTransform.inverted">
<code class="descname">inverted</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BlendedGenericTransform.inverted"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BlendedGenericTransform.inverted" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the corresponding inverse transformation.</p>
<p>The return value of this method should be treated as
temporary.  An update to <em>self</em> does not cause a corresponding
update to its inverted copy.</p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">===</span> <span class="pre">self.inverted().transform(self.transform(x))</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BlendedGenericTransform.is_affine">
<code class="descname">is_affine</code><a class="headerlink" href="#matplotlib.transforms.BlendedGenericTransform.is_affine" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BlendedGenericTransform.is_separable">
<code class="descname">is_separable</code><em class="property"> = True</em><a class="headerlink" href="#matplotlib.transforms.BlendedGenericTransform.is_separable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BlendedGenericTransform.output_dims">
<code class="descname">output_dims</code><em class="property"> = 2</em><a class="headerlink" href="#matplotlib.transforms.BlendedGenericTransform.output_dims" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.BlendedGenericTransform.pass_through">
<code class="descname">pass_through</code><em class="property"> = True</em><a class="headerlink" href="#matplotlib.transforms.BlendedGenericTransform.pass_through" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.BlendedGenericTransform.transform_non_affine">
<code class="descname">transform_non_affine</code><span class="sig-paren">(</span><em>points</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#BlendedGenericTransform.transform_non_affine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.BlendedGenericTransform.transform_non_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs only the non-affine part of the transformation.</p>
<p><code class="docutils literal notranslate"><span class="pre">transform(values)</span></code> is always equivalent to
<code class="docutils literal notranslate"><span class="pre">transform_affine(transform_non_affine(values))</span></code>.</p>
<p>In non-affine transformations, this is generally equivalent to
<code class="docutils literal notranslate"><span class="pre">transform(values)</span></code>.  In affine transformations, this is
always a no-op.</p>
<p>Accepts a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.BlendedGenericTransform.input_dims" title="matplotlib.transforms.BlendedGenericTransform.input_dims"><code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code></a>) and
returns a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.BlendedGenericTransform.output_dims" title="matplotlib.transforms.BlendedGenericTransform.output_dims"><code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code></a>).</p>
<p>Alternatively, accepts a numpy array of length <a class="reference internal" href="#matplotlib.transforms.BlendedGenericTransform.input_dims" title="matplotlib.transforms.BlendedGenericTransform.input_dims"><code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code></a>
and returns a numpy array of length <a class="reference internal" href="#matplotlib.transforms.BlendedGenericTransform.output_dims" title="matplotlib.transforms.BlendedGenericTransform.output_dims"><code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.transforms.CompositeAffine2D">
<em class="property">class </em><code class="descclassname">matplotlib.transforms.</code><code class="descname">CompositeAffine2D</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#CompositeAffine2D"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.CompositeAffine2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.transforms.Affine2DBase</span></code></a></p>
<p>A composite transform formed by applying transform <em>a</em> then transform <em>b</em>.</p>
<p>This version is an optimization that handles the case where both <em>a</em>
and <em>b</em> are 2D affines.</p>
<p>Create a new composite transform that is the result of
applying transform <em>a</em> then transform <em>b</em>.</p>
<p>Both <em>a</em> and <em>b</em> must be instances of <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">Affine2DBase</span></code></a>.</p>
<p>You will generally not call this constructor directly but use
the <a class="reference internal" href="#matplotlib.transforms.composite_transform_factory" title="matplotlib.transforms.composite_transform_factory"><code class="xref py py-func docutils literal notranslate"><span class="pre">composite_transform_factory()</span></code></a> function instead,
which can automatically choose the best kind of composite
transform instance to create.</p>
<dl class="attribute">
<dt id="matplotlib.transforms.CompositeAffine2D.depth">
<code class="descname">depth</code><a class="headerlink" href="#matplotlib.transforms.CompositeAffine2D.depth" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of transforms which have been chained
together to form this Transform instance.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For the special case of a Composite transform, the maximum depth
of the two is returned.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.CompositeAffine2D.get_matrix">
<code class="descname">get_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#CompositeAffine2D.get_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.CompositeAffine2D.get_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Affine transformation array for the affine part
of this transform.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.transforms.CompositeGenericTransform">
<em class="property">class </em><code class="descclassname">matplotlib.transforms.</code><code class="descname">CompositeGenericTransform</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#CompositeGenericTransform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.CompositeGenericTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.transforms.Transform</span></code></a></p>
<p>A composite transform formed by applying transform <em>a</em> then
transform <em>b</em>.</p>
<p>This &quot;generic&quot; version can handle any two arbitrary
transformations.</p>
<p>Create a new composite transform that is the result of
applying transform <em>a</em> then transform <em>b</em>.</p>
<p>You will generally not call this constructor directly but use
the <a class="reference internal" href="#matplotlib.transforms.composite_transform_factory" title="matplotlib.transforms.composite_transform_factory"><code class="xref py py-func docutils literal notranslate"><span class="pre">composite_transform_factory()</span></code></a> function instead,
which can automatically choose the best kind of composite
transform instance to create.</p>
<dl class="attribute">
<dt id="matplotlib.transforms.CompositeGenericTransform.depth">
<code class="descname">depth</code><a class="headerlink" href="#matplotlib.transforms.CompositeGenericTransform.depth" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of transforms which have been chained
together to form this Transform instance.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For the special case of a Composite transform, the maximum depth
of the two is returned.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.CompositeGenericTransform.frozen">
<code class="descname">frozen</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#CompositeGenericTransform.frozen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.CompositeGenericTransform.frozen" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a frozen copy of this transform node.  The frozen copy
will not update when its children change.  Useful for storing
a previously known state of a transform where
<code class="docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code> might normally be used.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.CompositeGenericTransform.get_affine">
<code class="descname">get_affine</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#CompositeGenericTransform.get_affine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.CompositeGenericTransform.get_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the affine part of this transform.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.CompositeGenericTransform.has_inverse">
<code class="descname">has_inverse</code><a class="headerlink" href="#matplotlib.transforms.CompositeGenericTransform.has_inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.CompositeGenericTransform.inverted">
<code class="descname">inverted</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#CompositeGenericTransform.inverted"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.CompositeGenericTransform.inverted" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the corresponding inverse transformation.</p>
<p>The return value of this method should be treated as
temporary.  An update to <em>self</em> does not cause a corresponding
update to its inverted copy.</p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">===</span> <span class="pre">self.inverted().transform(self.transform(x))</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.CompositeGenericTransform.is_affine">
<code class="descname">is_affine</code><a class="headerlink" href="#matplotlib.transforms.CompositeGenericTransform.is_affine" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.CompositeGenericTransform.is_separable">
<code class="descname">is_separable</code><a class="headerlink" href="#matplotlib.transforms.CompositeGenericTransform.is_separable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.CompositeGenericTransform.pass_through">
<code class="descname">pass_through</code><em class="property"> = True</em><a class="headerlink" href="#matplotlib.transforms.CompositeGenericTransform.pass_through" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.CompositeGenericTransform.transform_affine">
<code class="descname">transform_affine</code><span class="sig-paren">(</span><em>points</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#CompositeGenericTransform.transform_affine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.CompositeGenericTransform.transform_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs only the affine part of this transformation on the
given array of values.</p>
<p><code class="docutils literal notranslate"><span class="pre">transform(values)</span></code> is always equivalent to
<code class="docutils literal notranslate"><span class="pre">transform_affine(transform_non_affine(values))</span></code>.</p>
<p>In non-affine transformations, this is generally a no-op.  In
affine transformations, this is equivalent to
<code class="docutils literal notranslate"><span class="pre">transform(values)</span></code>.</p>
<p>Accepts a numpy array of shape (N x <code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code>) and
returns a numpy array of shape (N x <code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code>).</p>
<p>Alternatively, accepts a numpy array of length <code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code>
and returns a numpy array of length <code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.CompositeGenericTransform.transform_non_affine">
<code class="descname">transform_non_affine</code><span class="sig-paren">(</span><em>points</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#CompositeGenericTransform.transform_non_affine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.CompositeGenericTransform.transform_non_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs only the non-affine part of the transformation.</p>
<p><code class="docutils literal notranslate"><span class="pre">transform(values)</span></code> is always equivalent to
<code class="docutils literal notranslate"><span class="pre">transform_affine(transform_non_affine(values))</span></code>.</p>
<p>In non-affine transformations, this is generally equivalent to
<code class="docutils literal notranslate"><span class="pre">transform(values)</span></code>.  In affine transformations, this is
always a no-op.</p>
<p>Accepts a numpy array of shape (N x <code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code>) and
returns a numpy array of shape (N x <code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code>).</p>
<p>Alternatively, accepts a numpy array of length <code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code>
and returns a numpy array of length <code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.CompositeGenericTransform.transform_path_non_affine">
<code class="descname">transform_path_non_affine</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#CompositeGenericTransform.transform_path_non_affine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.CompositeGenericTransform.transform_path_non_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a path, transformed only by the non-affine
part of this transform.</p>
<p><em>path</em>: a <a class="reference internal" href="path_api.html#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> instance.</p>
<p><code class="docutils literal notranslate"><span class="pre">transform_path(path)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">transform_path_affine(transform_path_non_affine(values))</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.transforms.IdentityTransform">
<em class="property">class </em><code class="descclassname">matplotlib.transforms.</code><code class="descname">IdentityTransform</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#IdentityTransform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.IdentityTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.transforms.Affine2DBase</span></code></a></p>
<p>A special class that does one thing, the identity transform, in a
fast way.</p>
<dl class="method">
<dt id="matplotlib.transforms.IdentityTransform.frozen">
<code class="descname">frozen</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#IdentityTransform.frozen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.IdentityTransform.frozen" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a frozen copy of this transform node.  The frozen copy
will not update when its children change.  Useful for storing
a previously known state of a transform where
<code class="docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code> might normally be used.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.IdentityTransform.get_affine">
<code class="descname">get_affine</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#IdentityTransform.get_affine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.IdentityTransform.get_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the corresponding inverse transformation.</p>
<p>The return value of this method should be treated as
temporary.  An update to <em>self</em> does not cause a corresponding
update to its inverted copy.</p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">===</span> <span class="pre">self.inverted().transform(self.transform(x))</span></code></p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.IdentityTransform.get_matrix">
<code class="descname">get_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#IdentityTransform.get_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.IdentityTransform.get_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Affine transformation array for the affine part
of this transform.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.IdentityTransform.inverted">
<code class="descname">inverted</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.transforms.IdentityTransform.inverted" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the corresponding inverse transformation.</p>
<p>The return value of this method should be treated as
temporary.  An update to <em>self</em> does not cause a corresponding
update to its inverted copy.</p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">===</span> <span class="pre">self.inverted().transform(self.transform(x))</span></code></p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.IdentityTransform.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>points</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#IdentityTransform.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.IdentityTransform.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs only the non-affine part of the transformation.</p>
<p><code class="docutils literal notranslate"><span class="pre">transform(values)</span></code> is always equivalent to
<code class="docutils literal notranslate"><span class="pre">transform_affine(transform_non_affine(values))</span></code>.</p>
<p>In non-affine transformations, this is generally equivalent to
<code class="docutils literal notranslate"><span class="pre">transform(values)</span></code>.  In affine transformations, this is
always a no-op.</p>
<p>Accepts a numpy array of shape (N x <code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code>) and
returns a numpy array of shape (N x <code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code>).</p>
<p>Alternatively, accepts a numpy array of length <code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code>
and returns a numpy array of length <code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.IdentityTransform.transform_affine">
<code class="descname">transform_affine</code><span class="sig-paren">(</span><em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.transforms.IdentityTransform.transform_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs only the non-affine part of the transformation.</p>
<p><code class="docutils literal notranslate"><span class="pre">transform(values)</span></code> is always equivalent to
<code class="docutils literal notranslate"><span class="pre">transform_affine(transform_non_affine(values))</span></code>.</p>
<p>In non-affine transformations, this is generally equivalent to
<code class="docutils literal notranslate"><span class="pre">transform(values)</span></code>.  In affine transformations, this is
always a no-op.</p>
<p>Accepts a numpy array of shape (N x <code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code>) and
returns a numpy array of shape (N x <code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code>).</p>
<p>Alternatively, accepts a numpy array of length <code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code>
and returns a numpy array of length <code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.IdentityTransform.transform_non_affine">
<code class="descname">transform_non_affine</code><span class="sig-paren">(</span><em>points</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.transforms.IdentityTransform.transform_non_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs only the non-affine part of the transformation.</p>
<p><code class="docutils literal notranslate"><span class="pre">transform(values)</span></code> is always equivalent to
<code class="docutils literal notranslate"><span class="pre">transform_affine(transform_non_affine(values))</span></code>.</p>
<p>In non-affine transformations, this is generally equivalent to
<code class="docutils literal notranslate"><span class="pre">transform(values)</span></code>.  In affine transformations, this is
always a no-op.</p>
<p>Accepts a numpy array of shape (N x <code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code>) and
returns a numpy array of shape (N x <code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code>).</p>
<p>Alternatively, accepts a numpy array of length <code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code>
and returns a numpy array of length <code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.IdentityTransform.transform_path">
<code class="descname">transform_path</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#IdentityTransform.transform_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.IdentityTransform.transform_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a path, transformed only by the non-affine
part of this transform.</p>
<p><em>path</em>: a <a class="reference internal" href="path_api.html#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> instance.</p>
<p><code class="docutils literal notranslate"><span class="pre">transform_path(path)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">transform_path_affine(transform_path_non_affine(values))</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.IdentityTransform.transform_path_affine">
<code class="descname">transform_path_affine</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.transforms.IdentityTransform.transform_path_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a path, transformed only by the non-affine
part of this transform.</p>
<p><em>path</em>: a <a class="reference internal" href="path_api.html#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> instance.</p>
<p><code class="docutils literal notranslate"><span class="pre">transform_path(path)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">transform_path_affine(transform_path_non_affine(values))</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.IdentityTransform.transform_path_non_affine">
<code class="descname">transform_path_non_affine</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="headerlink" href="#matplotlib.transforms.IdentityTransform.transform_path_non_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a path, transformed only by the non-affine
part of this transform.</p>
<p><em>path</em>: a <a class="reference internal" href="path_api.html#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> instance.</p>
<p><code class="docutils literal notranslate"><span class="pre">transform_path(path)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">transform_path_affine(transform_path_non_affine(values))</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.transforms.LockableBbox">
<em class="property">class </em><code class="descclassname">matplotlib.transforms.</code><code class="descname">LockableBbox</code><span class="sig-paren">(</span><em>bbox</em>, <em>x0=None</em>, <em>y0=None</em>, <em>x1=None</em>, <em>y1=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#LockableBbox"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.LockableBbox" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.transforms.BboxBase" title="matplotlib.transforms.BboxBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.transforms.BboxBase</span></code></a></p>
<p>A <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a> where some elements may be locked at certain values.</p>
<p>When the child bounding box changes, the bounds of this bbox will update
accordingly with the exception of the locked elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>bbox</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Bbox</span></dt>
<dd><p class="first last">The child bounding box to wrap.</p>
</dd>
<dt><strong>x0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or None</span></dt>
<dd><p class="first last">The locked value for x0, or None to leave unlocked.</p>
</dd>
<dt><strong>y0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or None</span></dt>
<dd><p class="first last">The locked value for y0, or None to leave unlocked.</p>
</dd>
<dt><strong>x1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or None</span></dt>
<dd><p class="first last">The locked value for x1, or None to leave unlocked.</p>
</dd>
<dt><strong>y1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or None</span></dt>
<dd><p class="first last">The locked value for y1, or None to leave unlocked.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="matplotlib.transforms.LockableBbox.get_points">
<code class="descname">get_points</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#LockableBbox.get_points"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.LockableBbox.get_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the points of the bounding box directly as a numpy array
of the form: <code class="docutils literal notranslate"><span class="pre">[[x0,</span> <span class="pre">y0],</span> <span class="pre">[x1,</span> <span class="pre">y1]]</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.LockableBbox.locked_x0">
<code class="descname">locked_x0</code><a class="headerlink" href="#matplotlib.transforms.LockableBbox.locked_x0" title="Permalink to this definition">¶</a></dt>
<dd><p>float or None: The value used for the locked x0.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.LockableBbox.locked_x1">
<code class="descname">locked_x1</code><a class="headerlink" href="#matplotlib.transforms.LockableBbox.locked_x1" title="Permalink to this definition">¶</a></dt>
<dd><p>float or None: The value used for the locked x1.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.LockableBbox.locked_y0">
<code class="descname">locked_y0</code><a class="headerlink" href="#matplotlib.transforms.LockableBbox.locked_y0" title="Permalink to this definition">¶</a></dt>
<dd><p>float or None: The value used for the locked y0.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.LockableBbox.locked_y1">
<code class="descname">locked_y1</code><a class="headerlink" href="#matplotlib.transforms.LockableBbox.locked_y1" title="Permalink to this definition">¶</a></dt>
<dd><p>float or None: The value used for the locked y1.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.transforms.ScaledTranslation">
<em class="property">class </em><code class="descclassname">matplotlib.transforms.</code><code class="descname">ScaledTranslation</code><span class="sig-paren">(</span><em>xt</em>, <em>yt</em>, <em>scale_trans</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#ScaledTranslation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.ScaledTranslation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.transforms.Affine2DBase" title="matplotlib.transforms.Affine2DBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.transforms.Affine2DBase</span></code></a></p>
<p>A transformation that translates by <em>xt</em> and <em>yt</em>, after <em>xt</em> and <em>yt</em>
have been transformad by the given transform <em>scale_trans</em>.</p>
<dl class="method">
<dt id="matplotlib.transforms.ScaledTranslation.get_matrix">
<code class="descname">get_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#ScaledTranslation.get_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.ScaledTranslation.get_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Affine transformation array for the affine part
of this transform.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.transforms.Transform">
<em class="property">class </em><code class="descclassname">matplotlib.transforms.</code><code class="descname">Transform</code><span class="sig-paren">(</span><em>shorthand_name=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.transforms.TransformNode</span></code></a></p>
<p>The base class of all <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransformNode</span></code></a> instances that
actually perform a transformation.</p>
<p>All non-affine transformations should be subclasses of this class.
New affine transformations should be subclasses of
<a class="reference internal" href="#matplotlib.transforms.Affine2D" title="matplotlib.transforms.Affine2D"><code class="xref py py-class docutils literal notranslate"><span class="pre">Affine2D</span></code></a>.</p>
<p>Subclasses of this class should override the following members (at
minimum):</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code></a></li>
<li><a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code></a></li>
<li><a class="reference internal" href="#matplotlib.transforms.Transform.transform" title="matplotlib.transforms.Transform.transform"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transform()</span></code></a></li>
<li><a class="reference internal" href="#matplotlib.transforms.Transform.is_separable" title="matplotlib.transforms.Transform.is_separable"><code class="xref py py-attr docutils literal notranslate"><span class="pre">is_separable</span></code></a></li>
<li><a class="reference internal" href="#matplotlib.transforms.Transform.has_inverse" title="matplotlib.transforms.Transform.has_inverse"><code class="xref py py-attr docutils literal notranslate"><span class="pre">has_inverse</span></code></a></li>
<li><a class="reference internal" href="#matplotlib.transforms.Transform.inverted" title="matplotlib.transforms.Transform.inverted"><code class="xref py py-meth docutils literal notranslate"><span class="pre">inverted()</span></code></a> (if <a class="reference internal" href="#matplotlib.transforms.Transform.has_inverse" title="matplotlib.transforms.Transform.has_inverse"><code class="xref py py-attr docutils literal notranslate"><span class="pre">has_inverse</span></code></a> is True)</li>
</ul>
</div></blockquote>
<p>If the transform needs to do something non-standard with
<a class="reference internal" href="path_api.html#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.path.Path</span></code></a> objects, such as adding curves
where there were once line segments, it should override:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#matplotlib.transforms.Transform.transform_path" title="matplotlib.transforms.Transform.transform_path"><code class="xref py py-meth docutils literal notranslate"><span class="pre">transform_path()</span></code></a></li>
</ul>
</div></blockquote>
<p>Creates a new <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransformNode</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>shorthand_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">A string representing the &quot;name&quot; of the transform. The name carries
no significance other than to improve the readability of
<code class="docutils literal notranslate"><span class="pre">str(transform)</span></code> when DEBUG=True.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="matplotlib.transforms.Transform.contains_branch">
<code class="descname">contains_branch</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Transform.contains_branch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Transform.contains_branch" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether the given transform is a sub-tree of this transform.</p>
<p>This routine uses transform equality to identify sub-trees, therefore
in many situations it is object id which will be used.</p>
<p>For the case where the given transform represents the whole
of this transform, returns True.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Transform.contains_branch_seperately">
<code class="descname">contains_branch_seperately</code><span class="sig-paren">(</span><em>other_transform</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Transform.contains_branch_seperately"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Transform.contains_branch_seperately" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether the given branch is a sub-tree of this transform on
each separate dimension.</p>
<p>A common use for this method is to identify if a transform is a blended
transform containing an axes' data transform. e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x_isdata</span><span class="p">,</span> <span class="n">y_isdata</span> <span class="o">=</span> <span class="n">trans</span><span class="o">.</span><span class="n">contains_branch_seperately</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.Transform.depth">
<code class="descname">depth</code><a class="headerlink" href="#matplotlib.transforms.Transform.depth" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of transforms which have been chained
together to form this Transform instance.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For the special case of a Composite transform, the maximum depth
of the two is returned.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Transform.get_affine">
<code class="descname">get_affine</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Transform.get_affine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Transform.get_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the affine part of this transform.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Transform.get_matrix">
<code class="descname">get_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Transform.get_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Transform.get_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Affine transformation array for the affine part
of this transform.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.Transform.has_inverse">
<code class="descname">has_inverse</code><em class="property"> = False</em><a class="headerlink" href="#matplotlib.transforms.Transform.has_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>True if this transform has a corresponding inverse transform.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.Transform.input_dims">
<code class="descname">input_dims</code><em class="property"> = None</em><a class="headerlink" href="#matplotlib.transforms.Transform.input_dims" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of input dimensions of this transform.
Must be overridden (with integers) in the subclass.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Transform.inverted">
<code class="descname">inverted</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Transform.inverted"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Transform.inverted" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the corresponding inverse transformation.</p>
<p>The return value of this method should be treated as
temporary.  An update to <em>self</em> does not cause a corresponding
update to its inverted copy.</p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">===</span> <span class="pre">self.inverted().transform(self.transform(x))</span></code></p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.Transform.is_separable">
<code class="descname">is_separable</code><em class="property"> = False</em><a class="headerlink" href="#matplotlib.transforms.Transform.is_separable" title="Permalink to this definition">¶</a></dt>
<dd><p>True if this transform is separable in the x- and y- dimensions.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.Transform.output_dims">
<code class="descname">output_dims</code><em class="property"> = None</em><a class="headerlink" href="#matplotlib.transforms.Transform.output_dims" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of output dimensions of this transform.
Must be overridden (with integers) in the subclass.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Transform.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>values</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Transform.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Transform.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs the transformation on the given array of values.</p>
<p>Accepts a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code></a>) and
returns a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code></a>).</p>
<p>Alternatively, accepts a numpy array of length <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code></a>
and returns a numpy array of length <a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Transform.transform_affine">
<code class="descname">transform_affine</code><span class="sig-paren">(</span><em>values</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Transform.transform_affine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Transform.transform_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs only the affine part of this transformation on the
given array of values.</p>
<p><code class="docutils literal notranslate"><span class="pre">transform(values)</span></code> is always equivalent to
<code class="docutils literal notranslate"><span class="pre">transform_affine(transform_non_affine(values))</span></code>.</p>
<p>In non-affine transformations, this is generally a no-op.  In
affine transformations, this is equivalent to
<code class="docutils literal notranslate"><span class="pre">transform(values)</span></code>.</p>
<p>Accepts a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code></a>) and
returns a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code></a>).</p>
<p>Alternatively, accepts a numpy array of length <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code></a>
and returns a numpy array of length <a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Transform.transform_angles">
<code class="descname">transform_angles</code><span class="sig-paren">(</span><em>angles</em>, <em>pts</em>, <em>radians=False</em>, <em>pushoff=1e-05</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Transform.transform_angles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Transform.transform_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs transformation on a set of angles anchored at
specific locations.</p>
<p>The <em>angles</em> must be a column vector (i.e., numpy array).</p>
<p>The <em>pts</em> must be a two-column numpy array of x,y positions
(angle transforms currently only work in 2D).  This array must
have the same number of rows as <em>angles</em>.</p>
<dl class="docutils">
<dt><em>radians</em> indicates whether or not input angles are given in</dt>
<dd>radians (True) or degrees (False; the default).</dd>
<dt><em>pushoff</em> is the distance to move away from <em>pts</em> for</dt>
<dd>determining transformed angles (see discussion of method
below).</dd>
</dl>
<p>The transformed angles are returned in an array with the same
size as <em>angles</em>.</p>
<p>The generic version of this method uses a very generic
algorithm that transforms <em>pts</em>, as well as locations very
close to <em>pts</em>, to find the angle in the transformed system.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Transform.transform_bbox">
<code class="descname">transform_bbox</code><span class="sig-paren">(</span><em>bbox</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Transform.transform_bbox"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Transform.transform_bbox" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform the given bounding box.</p>
<p>Note, for smarter transforms including caching (a common
requirement for matplotlib figures), see <a class="reference internal" href="#matplotlib.transforms.TransformedBbox" title="matplotlib.transforms.TransformedBbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransformedBbox</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Transform.transform_non_affine">
<code class="descname">transform_non_affine</code><span class="sig-paren">(</span><em>values</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Transform.transform_non_affine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Transform.transform_non_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs only the non-affine part of the transformation.</p>
<p><code class="docutils literal notranslate"><span class="pre">transform(values)</span></code> is always equivalent to
<code class="docutils literal notranslate"><span class="pre">transform_affine(transform_non_affine(values))</span></code>.</p>
<p>In non-affine transformations, this is generally equivalent to
<code class="docutils literal notranslate"><span class="pre">transform(values)</span></code>.  In affine transformations, this is
always a no-op.</p>
<p>Accepts a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code></a>) and
returns a numpy array of shape (N x <a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code></a>).</p>
<p>Alternatively, accepts a numpy array of length <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code></a>
and returns a numpy array of length <a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Transform.transform_path">
<code class="descname">transform_path</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Transform.transform_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Transform.transform_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a transformed path.</p>
<p><em>path</em>: a <a class="reference internal" href="path_api.html#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> instance.</p>
<p>In some cases, this transform may insert curves into the path
that began as line segments.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Transform.transform_path_affine">
<code class="descname">transform_path_affine</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Transform.transform_path_affine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Transform.transform_path_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a path, transformed only by the affine part of
this transform.</p>
<p><em>path</em>: a <a class="reference internal" href="path_api.html#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> instance.</p>
<p><code class="docutils literal notranslate"><span class="pre">transform_path(path)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">transform_path_affine(transform_path_non_affine(values))</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Transform.transform_path_non_affine">
<code class="descname">transform_path_non_affine</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Transform.transform_path_non_affine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Transform.transform_path_non_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a path, transformed only by the non-affine
part of this transform.</p>
<p><em>path</em>: a <a class="reference internal" href="path_api.html#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> instance.</p>
<p><code class="docutils literal notranslate"><span class="pre">transform_path(path)</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">transform_path_affine(transform_path_non_affine(values))</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.Transform.transform_point">
<code class="descname">transform_point</code><span class="sig-paren">(</span><em>point</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#Transform.transform_point"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.Transform.transform_point" title="Permalink to this definition">¶</a></dt>
<dd><p>A convenience function that returns the transformed copy of a
single point.</p>
<p>The point is given as a sequence of length <a class="reference internal" href="#matplotlib.transforms.Transform.input_dims" title="matplotlib.transforms.Transform.input_dims"><code class="xref py py-attr docutils literal notranslate"><span class="pre">input_dims</span></code></a>.
The transformed point is returned as a sequence of length
<a class="reference internal" href="#matplotlib.transforms.Transform.output_dims" title="matplotlib.transforms.Transform.output_dims"><code class="xref py py-attr docutils literal notranslate"><span class="pre">output_dims</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.transforms.TransformNode">
<em class="property">class </em><code class="descclassname">matplotlib.transforms.</code><code class="descname">TransformNode</code><span class="sig-paren">(</span><em>shorthand_name=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#TransformNode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.TransformNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p><a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransformNode</span></code></a> is the base class for anything that
participates in the transform tree and needs to invalidate its
parents or be invalidated.  This includes classes that are not
really transforms, such as bounding boxes, since some transforms
depend on bounding boxes to compute their values.</p>
<p>Creates a new <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransformNode</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>shorthand_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">A string representing the &quot;name&quot; of the transform. The name carries
no significance other than to improve the readability of
<code class="docutils literal notranslate"><span class="pre">str(transform)</span></code> when DEBUG=True.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="matplotlib.transforms.TransformNode.INVALID">
<code class="descname">INVALID</code><em class="property"> = 3</em><a class="headerlink" href="#matplotlib.transforms.TransformNode.INVALID" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.TransformNode.INVALID_AFFINE">
<code class="descname">INVALID_AFFINE</code><em class="property"> = 2</em><a class="headerlink" href="#matplotlib.transforms.TransformNode.INVALID_AFFINE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.TransformNode.INVALID_NON_AFFINE">
<code class="descname">INVALID_NON_AFFINE</code><em class="property"> = 1</em><a class="headerlink" href="#matplotlib.transforms.TransformNode.INVALID_NON_AFFINE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.TransformNode.frozen">
<code class="descname">frozen</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#TransformNode.frozen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.TransformNode.frozen" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a frozen copy of this transform node.  The frozen copy
will not update when its children change.  Useful for storing
a previously known state of a transform where
<code class="docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code> might normally be used.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.TransformNode.invalidate">
<code class="descname">invalidate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#TransformNode.invalidate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.TransformNode.invalidate" title="Permalink to this definition">¶</a></dt>
<dd><p>Invalidate this <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransformNode</span></code></a> and triggers an
invalidation of its ancestors.  Should be called any
time the transform changes.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.TransformNode.is_affine">
<code class="descname">is_affine</code><em class="property"> = False</em><a class="headerlink" href="#matplotlib.transforms.TransformNode.is_affine" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.TransformNode.is_bbox">
<code class="descname">is_bbox</code><em class="property"> = False</em><a class="headerlink" href="#matplotlib.transforms.TransformNode.is_bbox" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.TransformNode.pass_through">
<code class="descname">pass_through</code><em class="property"> = False</em><a class="headerlink" href="#matplotlib.transforms.TransformNode.pass_through" title="Permalink to this definition">¶</a></dt>
<dd><p>If pass_through is True, all ancestors will always be
invalidated, even if 'self' is already invalid.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.TransformNode.set_children">
<code class="descname">set_children</code><span class="sig-paren">(</span><em>*children</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#TransformNode.set_children"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.TransformNode.set_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the children of the transform, to let the invalidation
system know which transforms can invalidate this transform.
Should be called from the constructor of any transforms that
depend on other transforms.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.transforms.TransformWrapper">
<em class="property">class </em><code class="descclassname">matplotlib.transforms.</code><code class="descname">TransformWrapper</code><span class="sig-paren">(</span><em>child</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#TransformWrapper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.TransformWrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.transforms.Transform</span></code></a></p>
<p>A helper class that holds a single child transform and acts
equivalently to it.</p>
<p>This is useful if a node of the transform tree must be replaced at
run time with a transform of a different type.  This class allows
that replacement to correctly trigger invalidation.</p>
<p>Note that <a class="reference internal" href="#matplotlib.transforms.TransformWrapper" title="matplotlib.transforms.TransformWrapper"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransformWrapper</span></code></a> instances must have the same
input and output dimensions during their entire lifetime, so the
child transform may only be replaced with another child transform
of the same dimensions.</p>
<p><em>child</em>: A class:<a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Transform</span></code></a> instance.  This child may later
be replaced with <a class="reference internal" href="#matplotlib.transforms.TransformWrapper.set" title="matplotlib.transforms.TransformWrapper.set"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set()</span></code></a>.</p>
<dl class="method">
<dt id="matplotlib.transforms.TransformWrapper.frozen">
<code class="descname">frozen</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#TransformWrapper.frozen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.TransformWrapper.frozen" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a frozen copy of this transform node.  The frozen copy
will not update when its children change.  Useful for storing
a previously known state of a transform where
<code class="docutils literal notranslate"><span class="pre">copy.deepcopy()</span></code> might normally be used.</p>
</dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.TransformWrapper.has_inverse">
<code class="descname">has_inverse</code><a class="headerlink" href="#matplotlib.transforms.TransformWrapper.has_inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.TransformWrapper.is_affine">
<code class="descname">is_affine</code><a class="headerlink" href="#matplotlib.transforms.TransformWrapper.is_affine" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.TransformWrapper.is_separable">
<code class="descname">is_separable</code><a class="headerlink" href="#matplotlib.transforms.TransformWrapper.is_separable" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="matplotlib.transforms.TransformWrapper.pass_through">
<code class="descname">pass_through</code><em class="property"> = True</em><a class="headerlink" href="#matplotlib.transforms.TransformWrapper.pass_through" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.TransformWrapper.set">
<code class="descname">set</code><span class="sig-paren">(</span><em>child</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#TransformWrapper.set"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.TransformWrapper.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace the current child of this transform with another one.</p>
<p>The new child must have the same number of input and output
dimensions as the current child.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.transforms.TransformedBbox">
<em class="property">class </em><code class="descclassname">matplotlib.transforms.</code><code class="descname">TransformedBbox</code><span class="sig-paren">(</span><em>bbox</em>, <em>transform</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#TransformedBbox"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.TransformedBbox" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.transforms.BboxBase" title="matplotlib.transforms.BboxBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.transforms.BboxBase</span></code></a></p>
<p>A <a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a> that is automatically transformed by a given
transform.  When either the child bounding box or transform
changes, the bounds of this bbox will update accordingly.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>bbox</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#matplotlib.transforms.Bbox" title="matplotlib.transforms.Bbox"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bbox</span></code></a></span></dt>
<dd></dd>
<dt><strong>transform</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transform</span></code></a></span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="matplotlib.transforms.TransformedBbox.get_points">
<code class="descname">get_points</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#TransformedBbox.get_points"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.TransformedBbox.get_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the points of the bounding box directly as a numpy array
of the form: <code class="docutils literal notranslate"><span class="pre">[[x0,</span> <span class="pre">y0],</span> <span class="pre">[x1,</span> <span class="pre">y1]]</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="matplotlib.transforms.TransformedPatchPath">
<em class="property">class </em><code class="descclassname">matplotlib.transforms.</code><code class="descname">TransformedPatchPath</code><span class="sig-paren">(</span><em>patch</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#TransformedPatchPath"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.TransformedPatchPath" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.transforms.TransformedPath" title="matplotlib.transforms.TransformedPath"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.transforms.TransformedPath</span></code></a></p>
<p>A <a class="reference internal" href="#matplotlib.transforms.TransformedPatchPath" title="matplotlib.transforms.TransformedPatchPath"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransformedPatchPath</span></code></a> caches a non-affine transformed copy of
the <code class="xref py py-class docutils literal notranslate"><span class="pre">Patch</span></code>. This cached copy is automatically
updated when the non-affine part of the transform or the patch changes.</p>
<p>Create a new <a class="reference internal" href="#matplotlib.transforms.TransformedPatchPath" title="matplotlib.transforms.TransformedPatchPath"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransformedPatchPath</span></code></a> from the given
<code class="xref py py-class docutils literal notranslate"><span class="pre">Patch</span></code>.</p>
</dd></dl>

<dl class="class">
<dt id="matplotlib.transforms.TransformedPath">
<em class="property">class </em><code class="descclassname">matplotlib.transforms.</code><code class="descname">TransformedPath</code><span class="sig-paren">(</span><em>path</em>, <em>transform</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#TransformedPath"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.TransformedPath" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#matplotlib.transforms.TransformNode" title="matplotlib.transforms.TransformNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">matplotlib.transforms.TransformNode</span></code></a></p>
<p>A <a class="reference internal" href="#matplotlib.transforms.TransformedPath" title="matplotlib.transforms.TransformedPath"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransformedPath</span></code></a> caches a non-affine transformed copy of
the <a class="reference internal" href="path_api.html#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a>.  This cached copy is
automatically updated when the non-affine part of the transform
changes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Paths are considered immutable by this class. Any update to the
path's vertices/codes will not trigger a transform recomputation.</p>
</div>
<p>Create a new <a class="reference internal" href="#matplotlib.transforms.TransformedPath" title="matplotlib.transforms.TransformedPath"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransformedPath</span></code></a> from the given
<a class="reference internal" href="path_api.html#matplotlib.path.Path" title="matplotlib.path.Path"><code class="xref py py-class docutils literal notranslate"><span class="pre">Path</span></code></a> and <a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transform</span></code></a>.</p>
<dl class="method">
<dt id="matplotlib.transforms.TransformedPath.get_affine">
<code class="descname">get_affine</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#TransformedPath.get_affine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.TransformedPath.get_affine" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.TransformedPath.get_fully_transformed_path">
<code class="descname">get_fully_transformed_path</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#TransformedPath.get_fully_transformed_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.TransformedPath.get_fully_transformed_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a fully-transformed copy of the child path.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.TransformedPath.get_transformed_path_and_affine">
<code class="descname">get_transformed_path_and_affine</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#TransformedPath.get_transformed_path_and_affine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.TransformedPath.get_transformed_path_and_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the child path, with the non-affine part of
the transform already applied, along with the affine part of
the path necessary to complete the transformation.</p>
</dd></dl>

<dl class="method">
<dt id="matplotlib.transforms.TransformedPath.get_transformed_points_and_affine">
<code class="descname">get_transformed_points_and_affine</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#TransformedPath.get_transformed_points_and_affine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.TransformedPath.get_transformed_points_and_affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the child path, with the non-affine part of
the transform already applied, along with the affine part of
the path necessary to complete the transformation.  Unlike
<a class="reference internal" href="#matplotlib.transforms.TransformedPath.get_transformed_path_and_affine" title="matplotlib.transforms.TransformedPath.get_transformed_path_and_affine"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_transformed_path_and_affine()</span></code></a>, no interpolation will
be performed.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="matplotlib.transforms.blended_transform_factory">
<code class="descclassname">matplotlib.transforms.</code><code class="descname">blended_transform_factory</code><span class="sig-paren">(</span><em>x_transform</em>, <em>y_transform</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#blended_transform_factory"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.blended_transform_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new &quot;blended&quot; transform using <em>x_transform</em> to transform
the <em>x</em>-axis and <em>y_transform</em> to transform the <em>y</em>-axis.</p>
<p>A faster version of the blended transform is returned for the case
where both child transforms are affine.</p>
</dd></dl>

<dl class="function">
<dt id="matplotlib.transforms.composite_transform_factory">
<code class="descclassname">matplotlib.transforms.</code><code class="descname">composite_transform_factory</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#composite_transform_factory"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.composite_transform_factory" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new composite transform that is the result of applying
transform a then transform b.</p>
<p>Shortcut versions of the blended transform are provided for the
case where both child transforms are affine, or one or the other
is the identity transform.</p>
<p>Composite transforms may also be created using the '+' operator,
e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="matplotlib.transforms.interval_contains">
<code class="descclassname">matplotlib.transforms.</code><code class="descname">interval_contains</code><span class="sig-paren">(</span><em>interval</em>, <em>val</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#interval_contains"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.interval_contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Check, inclusively, whether an interval includes a given value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>interval</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of scalar</span></dt>
<dd><p class="first last">A 2-length sequence, endpoints that define the interval.</p>
</dd>
<dt><strong>val</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd><p class="first last">Value to check is within interval.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>bool</strong></dt>
<dd><p class="first last">Returns true if given val is within the interval.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="matplotlib.transforms.interval_contains_open">
<code class="descclassname">matplotlib.transforms.</code><code class="descname">interval_contains_open</code><span class="sig-paren">(</span><em>interval</em>, <em>val</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#interval_contains_open"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.interval_contains_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Check, excluding endpoints, whether an interval includes a given value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>interval</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of scalar</span></dt>
<dd><p class="first last">A 2-length sequence, endpoints that define the interval.</p>
</dd>
<dt><strong>val</strong> <span class="classifier-delimiter">:</span> <span class="classifier">scalar</span></dt>
<dd><p class="first last">Value to check is within interval.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>bool</strong></dt>
<dd><p class="first last">Returns true if given val is within the interval.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="matplotlib.transforms.nonsingular">
<code class="descclassname">matplotlib.transforms.</code><code class="descname">nonsingular</code><span class="sig-paren">(</span><em>vmin</em>, <em>vmax</em>, <em>expander=0.001</em>, <em>tiny=1e-15</em>, <em>increasing=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#nonsingular"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.nonsingular" title="Permalink to this definition">¶</a></dt>
<dd><p>Modify the endpoints of a range as needed to avoid singularities.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>vmin, vmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The initial endpoints.</p>
</dd>
<dt><strong>expander</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default: 0.001</span></dt>
<dd><p class="first last">Fractional amount by which <em>vmin</em> and <em>vmax</em> are expanded if
the original interval is too small, based on <em>tiny</em>.</p>
</dd>
<dt><strong>tiny</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default: 1e-15</span></dt>
<dd><p class="first last">Threshold for the ratio of the interval to the maximum absolute
value of its endpoints.  If the interval is smaller than
this, it will be expanded.  This value should be around
1e-15 or larger; otherwise the interval will be approaching
the double precision resolution limit.</p>
</dd>
<dt><strong>increasing</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default: True</span></dt>
<dd><p class="first last">If True, swap <em>vmin</em>, <em>vmax</em> if <em>vmin</em> &gt; <em>vmax</em>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>vmin, vmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Endpoints, expanded and/or swapped if necessary.
If either input is inf or NaN, or if both inputs are 0 or very
close to zero, it returns -<em>expander</em>, <em>expander</em>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="matplotlib.transforms.offset_copy">
<code class="descclassname">matplotlib.transforms.</code><code class="descname">offset_copy</code><span class="sig-paren">(</span><em>trans</em>, <em>fig=None</em>, <em>x=0.0</em>, <em>y=0.0</em>, <em>units='inches'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/matplotlib/transforms.html#offset_copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#matplotlib.transforms.offset_copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new transform with an added offset.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>trans</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transform</span></code></a> instance</span></dt>
<dd><p class="first last">Any transform, to which offset will be applied.</p>
</dd>
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="_as_gen/matplotlib.figure.Figure.html#matplotlib.figure.Figure" title="matplotlib.figure.Figure"><code class="xref py py-class docutils literal notranslate"><span class="pre">Figure</span></code></a>, optional, default: None</span></dt>
<dd><p class="first last">Current figure. It can be None if <em>units</em> are 'dots'.</p>
</dd>
<dt><strong>x, y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default: 0.0</span></dt>
<dd><p class="first last">Specifies the offset to apply.</p>
</dd>
<dt><strong>units</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{'inches', 'points', 'dots'}, optional</span></dt>
<dd><p class="first last">Units of the offset.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>trans</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#matplotlib.transforms.Transform" title="matplotlib.transforms.Transform"><code class="xref py py-class docutils literal notranslate"><span class="pre">Transform</span></code></a> instance</span></dt>
<dd><p class="first last">Transform with applied offset.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>

      <div class="clearer"></div>
    </div>
    <div class="footer">
        &copy; Copyright 2002 - 2012 John Hunter, Darren Dale, Eric Firing, Michael Droettboom and the Matplotlib development team; 2012 - 2018 The Matplotlib development team.
        <br />
      Last updated on Mar 28, 2019.
	Created using
	<a href="http://sphinx-doc.org/">Sphinx</a> 1.8.4.
	Doc version v3.0.3-7-g0f643fdb9.
    </div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-55954603-1', 'auto');
  ga('send', 'pageview');

</script>
</body>
<footer>
</footer>
</html>